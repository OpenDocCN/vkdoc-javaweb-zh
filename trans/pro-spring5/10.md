# 10.带类型转换和格式的验证

在企业应用程序中，验证是至关重要的。验证的目的是验证正在处理的数据满足所有预定义的业务需求，并确保数据完整性和在应用程序的其他层的有用性。

在应用程序开发中，数据验证总是与转换和格式化一起被提及。原因是数据源的格式很可能与应用程序中使用的格式不同。例如，在 web 应用程序中，用户在 web 浏览器前端输入信息。当用户保存该数据时，它被发送到服务器(在本地验证完成之后)。在服务器端，执行数据绑定过程，在该过程中，来自 HTTP 请求的数据被提取、转换并绑定到相应的域对象(例如，用户在 HTML 表单中输入歌手信息，然后绑定到服务器中的`Singer`对象)，这是基于为每个属性定义的格式规则(例如，日期格式模式是`yyyy-MM-dd`)。当数据绑定完成时，验证规则被应用到域对象，以检查任何约束违反。如果一切运行正常，数据将被持久化，并向用户显示一条成功消息。否则，验证错误消息将被填充并显示给用户。

在本章的第一部分，您将了解 Spring 如何为类型转换、字段格式化和验证提供复杂的支持。具体来说，本章涵盖以下主题:

*   Spring 类型转换系统和格式化程序服务提供者接口(SPI):我们介绍泛型类型转换系统和格式化程序 SPI。我们将介绍如何使用新服务来取代以前的`PropertyEditor`支持，以及它们如何在任何 Java 类型之间转换。
*   Spring 中的验证:我们讨论 Spring 如何支持域对象验证。首先，我们简单介绍一下 Spring 自己的`Validator`接口。然后，我们关注 JSR-349 (Bean 验证)支持。

## 属国

与前几章一样，本章中的示例需要一些依赖项，这些依赖项在下面的配置片段中有所描述。您可能会注意到的一个依赖项是`joda-time`。如果你运行的是 Java 8，Spring 5 也支持 JSR-310，也就是`javax.time` API。

```java
//pro-spring-15/build.gradle
ext {
    //spring libs
    springVersion = '5.0.0.RC1'

    jodaVersion = '2.9.9'
    javaxValidationVersion = '2.0.0.Beta2' //1.1.0.Final
    javaElVersion = '3.0.1-b04' // 3.0.0
    glasshfishELVersion = '2.2.1-b05' // 2.2

    hibernateValidatorVersion = '6.0.0.Beta2' //5.4.1.Final

    spring = [...]

    hibernate = [
      validator  :
         "org.hibernate:hibernate-validator:$hibernateValidatorVersion",
      ...
    ]

    misc = [
      validation   :
        "javax.validation:validation-api:$javaxValidationVersion",
      joda         : "joda-time:joda-time:$jodaVersion",
      ...
    ]
    ...
}
//chapter10/build.gradle
dependencies {
        compile spring.contextSupport, misc.slf4jJcl, misc.logback,
       db.h2, misc.lang3, hibernate.em, hibernate.validator,
       misc.joda, misc.validation

        testCompile testing.junit
}

```

## 弹簧式转换系统

在 Spring 3 中，引入了一个新的类型转换系统，提供了一种在 Spring 支持的应用程序中在任何 Java 类型之间进行转换的强大方法。本节展示了这个新服务如何执行先前的`PropertyEditor`支持所提供的相同功能，以及它如何支持任何 Java 类型之间的转换。我们还演示了如何使用转换器 SPI 实现自定义类型的转换器。

## 使用 PropertyEditors 从字符串转换

第 [3](03.html) 章讲述了 Spring 如何通过支持`PropertyEditor` s 来处理从属性文件中的`String`到 POJOs 属性的转换。让我们在这里做一个快速回顾，然后讲述 Spring 的转换器 SPI(从 3.0 开始可用)如何提供一个更强大的选择。

考虑这个简单版本的`Singer`类:

```java
package com.apress.prospring5.ch10;

import java.net.URL;
import java.text.SimpleDateFormat;

import org.joda.time.DateTime;

public class Singer {
    private String firstName;
    private String lastName;
    private DateTime birthDate;
    private URL personalSite;

    //getters and setters
    ...

    public String toString() {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        return String.format("{First name: %s, Last name: %s,
        Birthday: %s, Site: %s}",
          firstName, lastName, sdf.format(birthDate.toDate()), personalSite);
    }
}

```

对于`birthDate`属性，我们使用 JodaTime 的`DateTime`类。此外，如果适用的话，还有一个`URL`类型的字段，指示歌手的个人网站。现在假设我们想在 Spring 的`ApplicationContext`中构造`Singer`对象，其值存储在 Spring 的配置文件或属性文件中。下面的配置片段显示了 Spring XML 配置文件(`prop-editor-app-context.xml`):

```java
<?xml version="1.0" encoding="UTF-8"?>
<beans 
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:util="http://www.springframework.org/schema/util"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util.xsd">

    <context:annotation-config/>

    <context:property-placeholder location="classpath:application.properties"/>

    <bean id="customEditorConfigurer"
          class="org.springframework.beans.factory.config.CustomEditorConfigurer"
          p:propertyEditorRegistrars-ref="propertyEditorRegistrarsList"/>

    <util:list id="propertyEditorRegistrarsList">
        <bean class="com.apress.prospring5.ch10.DateTimeEditorRegistrar">
      <constructor-arg value="${date.format.pattern}"/>
        </bean>
    </util:list>

    <bean id="eric" class="com.apress.prospring5.ch10.Singer"
          p:firstName="Eric"
          p:lastName="Clapton"
          p:birthDate="1945-03-30"
          p:personalSite="http://www.ericclapton.com"/>

    <bean id="countrySinger" class="com.apress.prospring5.ch10.Singer"
          p:firstName="${countrySinger.firstName}"
          p:lastName="${countrySinger.lastName}"
          p:birthDate="${countrySinger.birthDate}"
          p:personalSite="${countrySinger.personalSite}"/>
</beans>

```

这里我们构造了两个不同的`Singer`类的 beans。`eric` bean 是用配置文件中提供的值构造的，而对于`countrysinger` bean，属性被外化到一个属性文件中。此外，还定义了一个自定义编辑器，用于从`String`到 JodaTime 的`DateTime`类型的转换，日期时间格式模式也在属性文件中具体化了。下面的代码片段显示了属性文件(`application.properties`):

```java
date.format.pattern=yyyy-MM-dd

countrySinger.firstName=John
countrySinger.lastName=Mayer
countrySinger.birthDate=1977-10-16
countrySinger.personalSite=http://johnmayer.com/

```

以下代码片段显示了用于将`String`值转换为 JodaTime `DateTime`类型的自定义编辑器:

```java
package com.apress.prospring5.ch10;

import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.springframework.beans.PropertyEditorRegistrar;
import org.springframework.beans.PropertyEditorRegistry;

import java.beans.PropertyEditorSupport;

public class DateTimeEditorRegistrar implements PropertyEditorRegistrar {
    private DateTimeFormatter dateTimeFormatter;

    public DateTimeEditorRegistrar(String dateFormatPattern) {
        dateTimeFormatter = DateTimeFormat.forPattern(dateFormatPattern);
    }

    @Override
    public void registerCustomEditors(PropertyEditorRegistry registry) {
        registry.registerCustomEditor(DateTime.class,
          new DateTimeEditor(dateTimeFormatter));
    }

    private static class DateTimeEditor extends PropertyEditorSupport {
        private DateTimeFormatter dateTimeFormatter;

        public DateTimeEditor(DateTimeFormatter dateTimeFormatter)  {
      this.dateTimeFormatter =  dateTimeFormatter;
        }

        @Override
            public void setAsText(String text) throws IllegalArgumentException  {
      setValue(DateTime.parse(text,  dateTimeFormatter));
        }
    }
}

```

`DateTimeEditorRegistrar`实现`PropertyEditorRegister`接口来注册我们的自定义`PropertyEditor`。然后我们创建一个名为`DateTimeEditor`的内部类，处理从`String`到`DateTime`的转换。我们在这个例子中使用了一个内部类，因为它只被`PropertyEditorRegistrar`实现访问。现在我们来测试一下。下一个代码片段显示了测试程序:

```java
package com.apress.prospring5.ch10;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.support.GenericXmlApplicationContext;

public class PropEditorDemo {

    private static Logger logger =
        LoggerFactory.getLogger(PropEditorDemo.class);

    public static void main(String... args) {
        GenericXmlApplicationContext ctx  =
      new GenericXmlApplicationContext();

        ctx.load("classpath:spring/prop-editor-app-context.xml");
        ctx.refresh();
        Singer eric = ctx.getBean("eric", Singer.class);
        logger.info("Eric info: " + eric);
        Singer countrySinger = ctx.getBean("countrySinger", Singer.class);
        logger.info("John info: " +  countrySinger);

        ctx.close();
    }
}

```

如您所见，这两个`Singer`bean 是从`ApplicationContext`中检索并打印出来的。运行该程序会产生以下输出:

```java
[main] INFO  c.a.p.c.PropEditorDemo - Eric info: {First name: Eric,
   Last name: Clapton, Birthday: 1945-03-30, Site: http://www.ericclapton.com}
[main] INFO  c.a.p.c.PropEditorDemo - John info: {First name: John,
   Last name: Mayer, Birthday: 1977-10-16, Site: http://johnmayer.com/}

```

如输出所示，属性被转换并应用于`Singer`bean。这里使用 XML 而不是 Java 配置类的原因是，要注入的值被声明为文本值，Spring 在后台透明地进行转换。

## 引入弹簧类型转换

在 Spring 3.0 中，引入了一个通用类型转换系统，它位于包`org.springframework.core.convert`下。除了提供对`PropertyEditor`支持的替代，类型转换系统可以被配置成在任何 Java 类型和 POJOs 之间进行转换(而`PropertyEditor`则专注于将属性文件中的`String`表示转换成 Java 类型)。

### 实现自定义转换器

要查看类型转换系统的运行情况，让我们重新看看前面的例子，使用同一个`Singer`类。假设这次我们想使用类型转换系统将`String`格式的日期转换成`Singer`的`birthDate`属性，该属性属于 JodaTime 的`DateTime`类型。为了支持转换，我们通过实现`org.springframework.core.convert.converter.Converter<S,T>`接口来创建一个定制的转换器，而不是创建一个定制的`PropertyEditor`。以下代码片段显示了自定义转换器:

```java
package com.apress.prospring5.ch10;

import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.springframework.core.convert.converter.Converter;

import javax.annotation.PostConstruct;

public class StringToDateTimeConverter  implements Converter<String, DateTime> {
    private static final String DEFAULT_DATE_PATTERN = "yyyy-MM-dd";
    private DateTimeFormatter dateFormat;

    private String datePattern =  DEFAULT_DATE_PATTERN;

    public String getDatePattern() {
        return datePattern;
    }

    public void setDatePattern(String datePattern) {
        this.datePattern = datePattern;
    }

    @PostConstruct
    public void init() {
        dateFormat = DateTimeFormat.forPattern(datePattern);
    }

    @Override
    public DateTime convert(String dateString) {
        return dateFormat.parseDateTime(dateString);
    }
}

```

我们实现了接口`Converter<String, DateTime>`，这意味着转换器负责将一个`String`(源类型`S`)转换成一个`DateTime`(目标类型`T`)。日期时间模式的注入是可选的，可以通过调用 setter `setDatePattern`来完成。如果没有注入，则使用默认模式`yyyy-MM-dd`。然后，在初始化方法(用`@PostConstruct`注释的`init()`方法)中，构造一个 JodaTime 的`DateTimeFormat`类的实例，它将根据指定的模式执行转换。最后，实现`convert()`方法来提供转换逻辑。

### 配置 ConversionService

为了使用转换服务而不是`PropertyEditor`，我们需要在 Spring 的`ApplicationContext`中配置一个`org.springframework.core.convert.ConversionService`接口的实例。以下代码片段显示了 Java 配置类:

```java
package com.apress.prospring5.ch10.config;

import com.apress.prospring5.ch10.Singer;
import com.apress.prospring5.ch10.StringToDateTimeConverter;
import org.joda.time.DateTime;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.context.support.ConversionServiceFactoryBean;
import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;
import org.springframework.core.convert.converter.Converter;

import java.net.URL;
import java.util.HashSet;
import java.util.Set;

@PropertySource("classpath:application.properties")
@Configuration
@ComponentScan(basePackages  =  "com.apress.prospring5.ch10")
public class AppConfig {

    @Value("${date.format.pattern}")
    private String dateFormatPattern;

    @Bean
    public static PropertySourcesPlaceholderConfigurer
       propertySourcesPlaceholderConfigurer() {
        return new PropertySourcesPlaceholderConfigurer();
    }

    @Bean
    public Singer john(@Value("${countrySinger.firstName}") String firstName,
      @Value("${countrySinger.lastName}") String  lastName,
      @Value("${countrySinger.personalSite}") URL personalSite,

      @Value("${countrySinger.birthDate}") DateTime birthDate)

         throws Exception {
        Singer singer =  new Singer();
        singer.setFirstName(firstName);
        singer.setLastName(lastName);
        singer.setPersonalSite(personalSite);
        singer.setBirthDate(birthDate);
        return singer;
    }
    @Bean
    public ConversionServiceFactoryBean conversionService() {
        ConversionServiceFactoryBean conversionServiceFactoryBean  =
      new ConversionServiceFactoryBean();
        Set<Converter> convs = new HashSet<>();
        convs.add(converter());
        conversionServiceFactoryBean.setConverters(convs);
        conversionServiceFactoryBean.afterPropertiesSet();
        return conversionServiceFactoryBean;
    }

    @Bean
    StringToDateTimeConverter converter(){
        StringToDateTimeConverter conv = new StringToDateTimeConverter();
        conv.setDatePattern(dateFormatPattern);
        conv.init();
        return  conv;
    }
}

```

这些值从一个属性文件中读取，该文件的内容与上一节中介绍的文件相同，并使用`@Value`注释注入到创建的 bean 中。

这里我们通过用类`ConversionServiceFactoryBean`声明一个`conversionService` bean 来指示 Spring 使用类型转换系统。如果没有定义转换服务 bean，Spring 将使用基于`PropertyEditor`的系统。

默认情况下，类型转换服务支持常见类型之间的转换，包括字符串、数字、枚举、集合、映射等。此外，在基于`PropertyEditor`的系统中，支持从`String`到 Java 类型的转换。

对于`conversionService` bean，配置了一个自定义转换器，用于从`String`到`DateTime`的转换。测试程序如下所示:

```java
package com.apress.prospring5.ch10;

import com.apress.prospring5.ch10.config.AppConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.GenericApplicationContext;

public class ConvServDemo {
    private static Logger logger = LoggerFactory.getLogger(ConvServDemo.class);

    public static void main(String... args) {
        GenericApplicationContext ctx  =
          new AnnotationConfigApplicationContext(AppConfig.class);

        Singer john =  ctx.getBean("john", Singer.class);
        logger.info("Singer info:  " +  john);
        ctx.close();
    }
}

```

运行测试程序会产生以下输出:

```java
15:41:09.960 main INFO   c.a.p.c.ConvServDemo - Singer info: {First name: John,
   Last name:  Mayer, Birthday:  1977-10-16, Site: http://johnmayer.com/}

```

如您所见，`john` bean 的属性转换结果与我们使用`PropertyEditor` s 时的结果相同。

### 在任意类型之间转换

类型转换系统的真正优势是能够在任意类型之间进行转换。为了查看它的运行情况，假设我们有另一个名为`AnotherSinger`的类，它与`Singer`类相同。代码如下所示:

```java
package com.apress.prospring5.ch10;

import java.net.URL;
import java.text.SimpleDateFormat;

import org.joda.time.DateTime;

public class AnotherSinger {
    private String firstName;
    private String lastName;
    private DateTime birthDate;
    private URL personalSite;

    //seters and  getters
    ...

    public String toString()  {
        SimpleDateFormat sdf  =  new SimpleDateFormat("yyyy-MM-dd");
        return String.format("{First name: %s, Last name: %s,
           Birthday: %s, Site: %s}", firstName, lastName,
           sdf.format(birthDate.toDate()),  personalSite);
    }
}

```

我们希望能够将`Singer`类的任何实例转换成`AnotherSinger`类。转换后，`Singer`的`firstName`和`lastName`值将分别变成`AnotherSinger`的`lastName`和`firstName`。让我们实现另一个自定义转换器来执行转换。以下代码片段显示了自定义转换器:

```java
package com.apress.prospring5.ch10;

import org.springframework.core.convert.converter.Converter;

public class SingerToAnotherSingerConverter
        implements Converter<Singer, AnotherSinger> {

    @Override
    public AnotherSinger convert(Singer singer) {
        AnotherSinger anotherSinger = new AnotherSinger();
        anotherSinger.setFirstName(singer.getLastName());
        anotherSinger.setLastName(singer.getFirstName());
        anotherSinger.setBirthDate(singer.getBirthDate());
        anotherSinger.setPersonalSite(singer.getPersonalSite());

        return anotherSinger;
    }
}

```

类是简单的；只需在`Singer`和`AnotherSinger`类之间交换`firstName`和`lastName`属性值。要将自定义转换器注册到`ApplicationContext`中，请用以下代码片段中的代码片段替换`AppConfig`类中的`conversionService` bean 的定义:

```java
package com.apress.prospring5.ch10.config;

import com.apress.prospring5.ch10.Singer;
import com.apress.prospring5.ch10.SingerToAnotherSingerConverter;
import com.apress.prospring5.ch10.StringToDateTimeConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.support.ConversionServiceFactoryBean;
import org.springframework.core.convert.converter.Converter;

import java.net.URL;
import java.util.HashSet;
import java.util.Set;

@Configuration
@ComponentScan(basePackages  =  "com.apress.prospring5.ch10")
public class AppConfig {

    @Bean
    public Singer john() throws Exception {
        Singer singer = new Singer();
        singer.setFirstName("John");
        singer.setLastName("Mayer");
        singer.setPersonalSite(new URL("http://johnmayer.com/"));
        singer.setBirthDate(converter().convert("1977-10-16"));
        return singer;
    }

    @Bean
    public ConversionServiceFactoryBean conversionService() {
        ConversionServiceFactoryBean  conversionServiceFactoryBean  =
      new ConversionServiceFactoryBean();
        Set<Converter> convs = new HashSet<>();
        convs.add(converter());
        convs.add(singerConverter());
        conversionServiceFactoryBean.setConverters(convs);
        conversionServiceFactoryBean.afterPropertiesSet();
        return conversionServiceFactoryBean;
    }
    @Bean
    StringToDateTimeConverter converter() {
        return new StringToDateTimeConverter();
    }

    @Bean
    SingerToAnotherSingerConverter singerConverter() {
        return new SingerToAnotherSingerConverter();
    }
}

```

converter 属性中 beans 的顺序并不重要。为了测试转换，我们使用下面的测试程序，它是这里显示的`MultipleConvServDemo`类:

```java
package com.apress.prospring5.ch10;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.GenericApplicationContext;
import org.springframework.core.convert.ConversionService;

import com.apress.prospring5.ch10.config.AppConfig;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class MultipleConvServDemo {
    private static Logger logger =
        LoggerFactory.getLogger(MultipleConvServDemo.class);

    public static  void main(String... args) {
        GenericApplicationContext ctx  =
            new AnnotationConfigApplicationContext(AppConfig.class);

        Singer john = ctx.getBean("john", Singer.class);

        logger.info("Singer info:  " + john);

        ConversionService  conversionService  =
           ctx.getBean(ConversionService.class);

        AnotherSinger  anotherSinger  =
      conversionService.convert(john, AnotherSinger.class);
        logger.info("Another  singer info: " +  anotherSinger);

        String[] stringArray = conversionService.convert("a,b,c",
      String[].class);
        logger.info("String array: " + stringArray[0]
           + stringArray[1] + stringArray[2]);
        List<String> listString =  new ArrayList<>();
        listString.add("a");
        listString.add("b");
        listString.add("c");

        Set<String> setString  =
      conversionService.convert(listString,  HashSet.class);

        for (String string: setString)
      System.out.println("Set: " +  string);
    }
}

```

从`ApplicationContext`获得`ConversionService`接口的句柄。因为我们已经用自定义转换器在`ApplicationContext`中注册了`ConversionService`，我们可以用它来转换`Singer`对象，以及在转换服务已经支持的其他类型之间进行转换。如清单所示，出于演示目的，还添加了从`String`(由逗号分隔)转换为`Array`以及从`List`转换为`Set`的示例。运行该程序会产生以下输出:

```java
[main] INFO  c.a.p.c.MultipleConvServDemo - Singer info:
   {First name: John, Last name: Mayer, Birthday: 1977-10-16,
   Site: http://johnmayer.com/}
[main] INFO  c.a.p.c.MultipleConvServDemo - Another singer info:
   {First name: Mayer, Last name: John, Birthday: 1977-10-16,
    Site: http://johnmayer.com/}
[main] INFO  c.a.p.c.MultipleConvServDemo - String array: abc
Set: a
Set: b
Set: c

```

在输出中，您将看到`Singer`和`AnotherSinger`被正确转换，以及`String`到`Array`和`List`到`Set`。使用 Spring 的类型转换服务，您可以轻松地创建自定义转换器，并在应用程序中的任何层执行转换。一个可能的用例是，您有两个系统，需要更新相同的歌手信息。但是，数据库结构不同(例如，系统 A 中的姓表示系统 B 中的名，以此类推)。在保存到每个单独的系统之前，您可以使用类型转换系统来转换对象。

从 Spring 3.0 开始，Spring MVC 大量使用转换服务(以及下一节讨论的格式化程序 SPI)。在 web 应用程序上下文配置中，标记`<mvc:annotation-driven/>`的声明，或者在 Java 配置类中使用 Spring 3.1 中引入的`@EnableWebMvc`，将自动注册所有默认转换器(例如，`StringToArrayConverter`、`StringToBooleanConverter`和`StringToLocaleConverter`，它们都位于`org.springframework.core.convert.support`包下)和格式化程序(例如，`CurrencyFormatter`、`DateFormatter`和`NumberFormatter`，它们都位于`org.springframework.format`包内的各个子包下)。当我们在 Spring 中讨论 web 应用程序开发时，会在第 16 章中涉及更多内容。

## Spring 中的字段格式

除了类型转换系统，Spring 带给开发者的另一个很棒的特性是格式化程序 SPI。如您所料，这个 SPI 可以帮助配置字段格式。

在格式化程序 SPI 中，实现格式化程序的主要接口是`org.springframework.format.Formatter<T>`接口。Spring 提供了一些常用类型的实现，包括`CurrencyFormatter`、`DateFormatter`、`NumberFormatter`和`PercentFormatter`。

### 实现自定义格式化程序

实现自定义格式化程序也很容易。我们将使用相同的`Singer`类，并实现一个自定义格式化程序，用于将`birthDate`属性的`DateTime`类型与`String`类型相互转换。

然而，这一次我们将采取不同的方法；我们将扩展 Spring 的`org.springframework.format.support.FormattingConversionServiceFactoryBean`类，并提供我们的自定义格式化程序。`FormattingConversionServiceFactoryBean`类是一个工厂类，它提供了对底层`FormattingConversionService`类的方便访问，后者支持类型转换系统，以及根据为每个字段类型定义的格式化规则进行字段格式化。

下面的代码片段显示了一个扩展了`FormattingConversionServiceFactoryBean`类的自定义类，其中定义了一个自定义格式化程序来格式化 JodaTime 的`DateTime`类型。

```java
package com.apress.prospring5.ch10;

import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.Formatter;
import org.springframework.format.support.FormattingConversionServiceFactoryBean;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.text.ParseException;
import java.util.HashSet;
import java.util.Locale;
import java.util.Set;

@Component("conversionService")
public class ApplicationConversionServiceFactoryBean extends
        FormattingConversionServiceFactoryBean {
    private static Logger logger  =
      LoggerFactory.getLogger(ApplicationConversionServiceFactoryBean.class);

    private static final  String DEFAULT_DATE_PATTERN  =  "yyyy-MM-dd";
    private DateTimeFormatter dateFormat;
    private  String datePattern =  DEFAULT_DATE_PATTERN;
    private Set<Formatter<?>> formatters =  new HashSet<>();
    public String getDatePattern() {
        return datePattern;
    }

    @Autowired(required =  false)
    public void setDatePattern(String datePattern) {
        this.datePattern =  datePattern;
    }

    @PostConstruct
    public void init() {
        dateFormat = DateTimeFormat.forPattern(datePattern);
        formatters.add(getDateTimeFormatter());
        setFormatters(formatters);
    }

    public Formatter<DateTime> getDateTimeFormatter()  {
        return new Formatter<DateTime>() {

      @Override
      public DateTime parse(String  dateTimeString, Locale locale)

          throws ParseException {
           logger.info("Parsing date string: " +  dateTimeString);
           return dateFormat.parseDateTime(dateTimeString);
      }

      @Override
      public String  print(DateTime dateTime, Locale locale) {

          logger.info("Formatting datetime: " +  dateTime);
          return dateFormat.print(dateTime);
      }
          };
    }
}

```

在前面的清单中，自定义格式化程序带有下划线。它实现了`Formatter<DateTime>`接口，并实现了该接口定义的两个方法。`parse()`方法将`String`格式解析为`DateTime`类型(为了支持本地化，还传递了区域设置)，而`logger.info()`方法将`DateTime`实例格式化为`String`。日期模式可以注入到 bean 中(或者默认为`yyyy-MM-dd`)。同样，在`init()`方法中，自定义格式化程序是通过调用`setFormatters()`方法注册的。您可以根据需要添加任意数量的格式化程序。

### 配置 ConversionServiceFactoryBean

声明一个类型为`FormattingConversionServiceFactoryBean`的 bean 大大减小了`AppConfig`配置类的大小。

```java
package com.apress.prospring5.ch10.config;

import com.apress.prospring5.ch10.ApplicationConversionServiceFactoryBean;
import com.apress.prospring5.ch10.Singer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

import java.net.URL;
import java.util.Locale;

@Configuration
@ComponentScan(basePackages  =  "com.apress.prospring5.ch10")
public class AppConfig {

    @Autowired
    ApplicationConversionServiceFactoryBean conversionService;

    @Bean
    public Singer john() throws Exception {
        Singer singer =  new Singer();
        singer.setFirstName("John");
        singer.setLastName("Mayer");
        singer.setPersonalSite(new URL("http://johnmayer.com/"));
        singer.setBirthDate(conversionService.
          getDateTimeFormatter().parse("1977-10-16", Locale.ENGLISH));
        return singer;
    }
}

```

测试程序如下所示:

```java
package com.apress.prospring5.ch10;

import com.apress.prospring5.ch10.config.AppConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.GenericApplicationContext;
import org.springframework.core.convert.ConversionService;

public class ConvFormatServDemo {

    private static Logger logger =
        LoggerFactory.getLogger(ConvFormatServDemo.class);

    public static void main(String... args) {
        GenericApplicationContext ctx  =
          new AnnotationConfigApplicationContext(AppConfig.class);

        Singer john = ctx.getBean("john", Singer.class);
        logger.info("Singer info:  " +  john);
        ConversionService  conversionService  =
           ctx.getBean("conversionService", ConversionService.class);
        logger.info("Birthdate of singer is : " +
          conversionService.convert(john.getBirthDate(), String.class));

        ctx.close();
    }
}

```

运行该程序会产生以下输出:

```java
Parsing date string: 1977-10-16
[main] INFO  c.a.p.c.ConvFormatServDemo - Singer info: {
     First name: John, Last name: Mayer, Birthday: 1977-10-16,
     Site: http://johnmayer.com/}
Formatting datetime:  1977-10-16T00:00:00.000+03:00
[main] INFO  c.a.p.c.ConvFormatServDemo -
    Birthdate of singer is : 1977-10-16

```

在输出中，您可以看到 Spring 使用我们的自定义格式化程序的`parse()`方法将属性从`String`转换为`birthDate`属性的`DateTime`类型。当我们调用`ConversionService.convert()`方法并传入`birthDate`属性时，Spring 将调用`logger`的`info`方法来格式化输出。

## 春季验证

验证是任何应用程序的关键部分。应用于域对象的验证规则确保所有的业务数据都是结构良好的，并且满足所有的业务定义。理想的情况是，所有的验证规则都在一个集中的位置维护，相同的规则集应用于相同类型的数据，而不管数据来自哪个源(例如，通过 web 应用程序的用户输入、通过 web 服务的远程应用程序、JMS 消息或文件)。

当谈到验证时，转换和格式化也很重要，因为在验证一段数据之前，应该根据为每种类型定义的格式化规则将它转换成所需的 POJO。例如，用户通过浏览器中的 web 应用程序输入一些歌手信息，然后将数据提交给服务器。在服务器端，如果 web 应用程序是在 Spring MVC 中开发的，Spring 将从 HTTP 请求中提取数据，并根据格式规则执行从`String`到所需类型的转换(例如，表示日期的`String`将被转换为`Date`字段，格式规则为`yyyy-MM-dd`)。这个过程称为数据绑定。当数据绑定完成并且构造了域对象后，将对该对象进行验证，并将所有错误返回并显示给用户。如果验证成功，对象将被保存到数据库中。

Spring 支持两种主要类型的验证。第一个是由 Spring 提供的，在其中可以通过实现`org.springframework.validation.Validator`接口来创建自定义验证器。另一个是通过 Spring 对 JSR-349 的支持(Bean 验证)。我们将在接下来的章节中介绍这两种方法。

### 使用 Spring 验证器接口

使用 Spring 的`Validator`接口，我们可以通过创建一个实现接口的类来开发一些验证逻辑。让我们看看它是如何工作的。对于我们到目前为止使用的`Singer`类，假设名字不能为空。为了根据这个规则验证`Singer`对象，我们可以创建一个定制的验证器。以下代码片段显示了验证器类:

```java
package com.apress.prospring5.ch10;

import org.springframework.stereotype.Component;
import org.springframework.validation.Errors;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.Validator;

@Component("singerValidator")
public class SingerValidator implements Validator {
    @Override
    public  boolean supports(Class<?> clazz)  {
        return Singer.class.equals(clazz);
    }

    @Override
    public void validate(Object obj,  Errors e) {
        ValidationUtils.rejectIfEmpty(e,  "firstName",
            "firstName.empty");
    }
}

```

validator 类实现了`Validator`接口并实现了两个方法。`supports()`方法指示验证器是否支持对传入的类类型的验证。`validate()`方法对传入的对象进行验证。结果将存储在`org.springframework.validation.Errors`接口的一个实例中。在`validate()`方法中，我们只对`firstName`属性执行检查，并使用方便的`ValidationUtils.rejectIfEmpty()`方法来确保歌手的名字不为空。最后一个参数是错误代码，可用于从资源包中查找验证消息，以显示本地化的错误消息。

以下代码片段描述了配置类:

```java
package com.apress.prospring5.ch10.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = "com.apress.prospring5.ch10")
public class AppConfig {
}

```

以下代码片段包含测试程序:

```java
package com.apress.prospring5.ch10;

import com.apress.prospring5.ch10.config.AppConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.GenericApplicationContext;
import org.springframework.validation.BeanPropertyBindingResult;
import org.springframework.validation.ObjectError;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.Validator;

import java.util.List;

public class SpringValidatorDemo {

    private static Logger logger =
       LoggerFactory.getLogger(SpringValidatorDemo.class);

    public static void main(String... args) {
        GenericApplicationContext ctx  =
      new AnnotationConfigApplicationContext(AppConfig.class);

        Singer singer = new Singer();
        singer.setFirstName(null);
        singer.setLastName("Mayer");

        Validator singerValidator =  ctx.getBean("singerValidator",
           Validator.class);
        BeanPropertyBindingResult result =
           new BeanPropertyBindingResult(singer, "John");

        ValidationUtils.invokeValidator(singerValidator, singer, result);

        List<ObjectError> errors =  result.getAllErrors();
        logger.info("No of validation errors: " +  errors.size());
        errors.forEach(e -> logger.info(e.getCode()));

        ctx.close();
    }
}

```

用设置为`null`的名字来构造一个`Singer`对象。然后，从`ApplicationContext`中检索验证器。为了存储验证结果，构建了一个`BeanPropertyBindingResult`类的实例。为了执行验证，调用了`ValidationUtils.invokeValidator()`方法。然后我们检查验证错误。运行该程序会产生以下输出:

```java
[main] INFO    c.a.p.c.SpringValidatorDemo - No of validation errors: 1
[main] INFO    c.a.p.c.SpringValidatorDemo - firstName.empty

```

验证产生一个错误，错误代码显示正确。

### 使用 JSR-349 Bean 验证

从 Spring 4 开始，已经实现了对 JSR-349 (Bean 验证)的完全支持。Bean Validation API 在包`javax.validation.constraints`下定义了一组 Java 注释形式的约束(例如，`@NotNull`)，这些约束可以应用于域对象。此外，可以通过使用注释来开发和应用定制验证器(例如，类级别的验证器)。

使用 Bean 验证 API 使您不必耦合到特定的验证服务提供者。通过使用 Bean 验证 API，您可以使用标准注释和 API 来实现域对象的验证逻辑，而无需了解底层的验证服务提供者。例如，Hibernate Validator 版本 5 ( [`http://hibernate.org/subprojects/validator`](http://hibernate.org/subprojects/validator) )就是 JSR-349 参考实现。

Spring 为 Bean 验证 API 提供了无缝支持。主要特性包括支持定义验证约束的 JSR-349 标准注释、定制验证器，以及在 Spring 的`ApplicationContext`中配置 JSR-349 验证。让我们在接下来的章节中一个接一个地讨论它们。当在类路径中使用 Hibernate Validator 版本 4 和 1.0 版本的验证 API 时，Spring 仍然无缝地提供了对 JSR-303 的支持。

#### 定义对象属性的验证约束

让我们从对域对象属性应用验证约束开始。下面的代码片段显示了一个更高级的`Singer`类，其中验证约束应用于`firstName`和`genre`属性:

```java
package com.apress.prospring5.ch10.obj;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class Singer {

    @NotNull

    @Size(min=2, max=60)

    private String firstName;

    private String lastName;

    @NotNull

    private Genre genre;

    private Gender gender;

    //setters and getters
    ...
}

```

这里应用的验证约束显示为下划线。对于`firstName`属性，应用了两个约束。第一个由`@NotNull`注释控制，这表明该值不应该是`null`。此外，`@Size`注释决定了`firstName`属性的长度。`@NotNull`约束也适用于`genre`属性。

以下代码示例分别显示了`Genre`和`Gender`枚举类:

```java
//Genre.java
package com.apress.prospring5.ch10.obj;
public enum Genre {
   POP("P"),
    JAZZ("J"),
   BLUES("B"),
   COUNTRY("C");
   private String code;

   private Genre(String code) {
      this.code = code;
   }

   public String toString()  {
      return this.code;
   }
}

//Genfer.java
package com.apress.prospring5.ch10.obj;

public enum Gender {
   MALE("M"), FEMALE("F");
   private String code;

   Gender(String  code) {
      this.code =  code;
   }

   @Override
   public String toString() {
      return this.code;
   }
}

```

流派表示歌手所属的音乐流派，而性别与音乐生涯并没有太大关系，所以可能是`null`。

### 在 Spring 中配置 Bean 验证支持

为了在 Spring 的`ApplicationContext`中配置 bean 验证 API 的支持，我们在 Spring 的配置中定义了一个类型为`org.springframework.validation.beanvalidation.LocalValidatorFactoryBean`的 Bean。以下代码片段描述了配置类:

```java
package com.apress.prospring5.ch10.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;

@Configuration
@ComponentScan(basePackages = "com.apress.prospring5.ch10")
public class AppConfig {

   @Bean LocalValidatorFactoryBean validator() {
       return new LocalValidatorFactoryBean();
   }
}

```

只需要声明一个类型为`LocalValidatorFactoryBean`的 bean。默认情况下，Spring 会搜索类路径中是否存在 Hibernate 验证器库。现在，让我们创建一个为`Singer`类提供验证服务的服务类。验证器类如下所示:

```java
package com.apress.prospring5.ch10;

import com.apress.prospring5.ch10.obj.Singer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.validation.ConstraintViolation;
import javax.validation.Validator;
import java.util.Set;

@Service("singerValidationService")
public class SingerValidationService {

   @Autowired
   private Validator validator;

   public Set<ConstraintViolation<Singer>>
      validateSinger(Singer singer) {
      return validator.validate(singer);
   }
}

```

注入了`javax.validation.Validator`的一个实例(注意与 Spring 提供的`Validator`接口的不同，后者是`org.springframework.validation.Validator`)。一旦定义了`LocalValidatorFactoryBean`，您就可以在应用程序的任何地方创建一个`Validator`接口的句柄。为了对 POJO 执行验证，调用了`Validator.validate()`方法。验证结果将作为`ConstraintViolation<T>`接口的`List`返回。

测试程序如下所示:

```java
package com.apress.prospring5.ch10;

import com.apress.prospring5.ch10.config.AppConfig;
import com.apress.prospring5.ch10.obj.Singer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.GenericApplicationContext;

import javax.validation.ConstraintViolation;
import java.util.Set;

public class Jsr349Demo {
   private static Logger logger =
      LoggerFactory.getLogger(Jsr349Demo.class);

   public static void main(String... args) {

      GenericApplicationContext ctx  =
        new AnnotationConfigApplicationContext(AppConfig.class);

      SingerValidationService singerBeanValidationService =
          ctx.getBean( SingerValidationService.class);

      Singer singer = new Singer();
      singer.setFirstName("J");
      singer.setLastName("Mayer");
      singer.setGenre(null);
      singer.setGender(null);

      validateSinger(singer, singerBeanValidationService);

      ctx.close();
   }

   private static void validateSinger(Singer singer,
         SingerValidationService singerValidationService) {
      Set<ConstraintViolation<Singer>> violations =
         singerValidationService.validateSinger(singer);
      listViolations(violations);
   }

   private static void listViolations(
       Set<ConstraintViolation<Singer>> violations) {
      logger.info("No. of violations: " + violations.size());
      for (ConstraintViolation<Singer> violation : violations) {
         logger.info("Validation error for property: " +
         violation.getPropertyPath()
         + " with value: " + violation.getInvalidValue()
         + " with error message: " + violation.getMessage());
      }
   }
}

```

如清单所示，`Singer`对象由违反约束的`firstName`和`genre`构成。在`validateSinger()`方法中，调用了`SingerValidationService.validateSinger()`方法，这又将调用 JSR-349 (Bean 验证)。运行该程序会产生以下输出:

```java
[main] INFO  o.h.v.i.u.Version - HV000001:
   Hibernate Validator  6.0.0.Beta2
[main] INFO  c.a.p.c.Jsr349Demo - No.  of violations: 2
[main] INFO  c.a.p.c.Jsr349Demo - Validation error for property:
  firstName with value: J with error message: size must be between 2 and 60
[main] INFO  c.a.p.c.Jsr349Demo - Validation error for property:
  genre with value: null with error message: may not be null

```

如您所见，有两个违规，并且显示了消息。在输出中，您还会看到 Hibernate Validator 已经基于注释构造了默认的验证错误消息。您还可以提供自己的验证错误消息，我们将在下一节中演示。

### 创建自定义验证程序

除了属性级验证，我们还可以应用类级验证。例如，对于`Singer`类，对于乡村歌手，我们希望确保`lastName`和`gender`属性不是`null`，并不是说这真的很重要，只是出于教育目的。在这种情况下，我们可以开发一个定制的验证器来执行检查。在 Bean 验证 API 中，开发自定义验证器是一个两步过程。首先为验证器创建一个`Annotation`类型，如下面的代码片段所示。第二步是开发实现验证逻辑的类。

```java
package com.apress.prospring5.ch10;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import javax.validation.Constraint;
import javax.validation.Payload;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Constraint(validatedBy=CountrySingerValidator.class)
@Documented
public @interface CheckCountrySinger {
    String message() default "Country Singer should
       have gender and last name defined";
    Class<?> groups() default {};
    Class<? extends Payload> payload() default {};
}

```

`@Target(ElementType.TYPE)`注释意味着注释应该只应用于类级别。`@Constraint`注释表明它是一个验证器，而`validatedBy`属性指定了提供验证逻辑的类。在主体中，定义了三个属性(以方法的形式)，如下所示:

*   `message`属性定义了违反约束时返回的消息(或错误代码)。还可以在注释中提供默认消息。
*   如果适用的话,`groups`属性指定验证组。可以将验证器分配给不同的组，并在特定的组上执行验证。
*   属性指定了额外的有效负载对象(实现接口的类的)。它允许您向约束附加附加信息(例如，有效负载对象可以指示违反约束的严重性)。

下面的代码片段显示了提供验证逻辑的`CountrySingerValidator`类:

```java
package com.apress.prospring5.ch10;

import com.apress.prospring5.ch10.obj.Singer;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class CountrySingerValidator implements
        ConstraintValidator<CheckCountrySinger, Singer> {

    @Override
    public void initialize(CheckCountrySinger constraintAnnotation) {
    }

    @Override
    public boolean isValid(Singer singer,
      ConstraintValidatorContext context) {
        boolean result =  true;
        if (singer.getGenre() != null && (singer.isCountrySinger() &&
          (singer.getLastName() ==  null || singer.getGender() ==  null))) {
      result = false;
        }
        return result;
    }
}

```

`CountrySingerValidator`实现了`ConstraintValidator<CheckCountrySinger, Singer>`接口，这意味着验证器检查`Singer`类上的`CheckCountrySinger`注释。实现了`isValid()`方法，底层的验证服务提供者(例如，Hibernate Validator)将验证下的实例传递给方法。在方法中，我们验证如果歌手是乡村音乐歌手，那么`lastName`和`gender`属性不应该是`null`。结果是一个指示验证结果的`Boolean`值。

要启用验证，请将`@CheckCountrySinger`注释应用到`Singer`类，如下所示:

```java
package com.apress.prospring5.ch10.obj;

import com.apress.prospring5.ch10.CheckCountrySinger;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

@CheckCountrySinger

public class Singer {

      @NotNull
      @Size(min =  2, max =  60)
      private String firstName;

      private String lastName;

      @NotNull
      private Genre genre;

      private Gender gender;

      //getters and  setter
      ...

      public boolean isCountrySinger() {
      return genre == Genre.COUNTRY;
      }
}

```

为了测试定制验证，将在测试类`Jsr349CustomDemo`中创建下面的`Singer`实例:

```java
public class Jsr349CustomDemo {
      ...

      Singer singer = new Singer();
      singer.setFirstName("John");
      singer.setLastName("Mayer");
      singer.setGenre(Genre.COUNTRY);
      singer.setGender(null);

      validateSinger(singer, singerValidationService);

      ...
}

```

运行该程序会产生以下输出(另一个输出被省略):

```java
[main] INFO  o.h.v.i.u.Version - HV000001:  Hibernate Validator  6.0.0.Beta2
[main] INFO  c.a.p.c.Jsr349CustomDemo - No. of violations: 1
[main] INFO  c.a.p.c.Jsr349CustomDemo - Validation error for property:
   with value: com.apress.prospring5.ch10.obj.Singer@3116c353
   with error message: Country Singer should have gender and last name defined

```

在输出中，您可以看到被检查的值(即`Singer`实例)违反了乡村歌手的验证规则，因为`gender`属性是`null`。还要注意，在输出中，属性路径是空的，因为这是一个类级别的验证错误。

## 使用 AssertTrue 进行自定义验证

除了实现自定义验证器，在 Bean 验证 API 中应用自定义验证的另一种方式是使用`@AssertTrue`注释。让我们看看它是如何工作的。对于`Singer`类，移除了`@CheckCountrySinge` r 注释，并将`isCountrySinger()`方法修改如下:

```java
public class Singer {

   @NotNull
   @Size(min = 2, max = 60)
   private String firstName;

   private String lastName;

   @NotNull
   private Genre genre;

   private Gender gender;
   ...

   @AssertTrue(message="ERROR! Individual customer should have
       gender and last name defined")
   public  boolean isCountrySinger() {
      boolean result = true;

      if (genre!= null &&
            (genre.equals(Genre.COUNTRY) &&
               (gender ==  null || lastName ==  null))) {
         result = false;
      }

      return result;
   }
}

```

正如您可能推断的那样，`@CheckCountrySinger`注释和`CountrySingerValidator`类不再是必需的。

将`isCountrySinger()`方法添加到`Singer`类中，并用`@AssertTrue`进行注释(在包`javax.validation.constraints`下)。当调用验证时，提供者将调用检查并确保结果为真。JSR-349 还提供了`@AssertFalse`注释来检查一些应该为假的条件。现在运行测试程序`Jsr349AssertTrueDemo`，您将获得与定制验证程序相同的输出。

## 自定义验证的注意事项

那么，对于 JSR-349 中的自定义验证，您应该使用哪种方法:自定义验证器还是`@AssertTrue`注释？一般来说，`@AssertTrue`方法实现起来更简单，您可以在域对象的代码中看到验证规则。然而，对于具有更复杂逻辑的验证器(例如，假设您需要注入一个服务类，访问一个数据库，并检查有效值)，那么实现一个定制的验证器是可行的，因为您永远不希望将服务层对象注入到您的域对象中。此外，自定义验证器可以在相似的域对象中重用。

## 决定使用哪个验证 API

讨论了 Spring 自己的`Validator`接口和 Bean 验证 API 之后，您应该在您的应用程序中使用哪一个？JSR-349 是绝对的出路。以下是主要原因:

*   JSR-349 是一个 JEE 标准，被许多前端/后端框架广泛支持(例如，Spring、JPA 2、Spring MVC 和 GWT)。
*   JSR-349 提供了一个标准的验证 API，它隐藏了底层的提供者，所以你不会被绑定到一个特定的提供者。
*   从版本 4 开始，Spring 与 JSR-349 紧密集成。例如，在 Spring MVC web 控制器中，您可以用`@Valid`注释对方法中的参数进行注释(在包`javax.validation`下)，Spring 将在数据绑定过程中自动调用 JSR-349 验证。而且，在一个 Spring MVC web 应用上下文配置中，一个简单的名为`<mvc:annotation-driven/>`的标签将配置 Spring 自动启用 Spring 类型转换系统和字段格式化，以及对 JSR-349 (Bean Validation)的支持。
*   如果您使用 JPA 2，提供者将在持久化之前自动对实体执行 JSR-349 验证，提供另一层保护。

关于使用 JSR-349 (Bean Validation)配合 Hibernate Validator 作为实现提供者的详细信息，请参考 Hibernate Validator 的文档页: [`http://docs.jboss.org/hibernate/validator/`](http://docs.jboss.org/hibernate/validator/) `5.1/reference/en-US/html`。

## 摘要

在本章中，我们介绍了 Spring 类型转换系统以及现场格式化程序 SPI。除了对`PropertyEditors`的支持之外，您还看到了新的类型转换系统是如何用于任意类型转换的。

我们还介绍了 Spring 中的验证支持，Spring 的`Validator`接口，以及 Spring 中推荐的 JSR-349 (Bean 验证)支持。