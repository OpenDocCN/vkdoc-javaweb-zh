# 9.事务管理

事务是构建可靠的企业应用程序的最关键部分之一。最常见的事务类型是数据库操作。在典型的数据库更新操作中，数据库事务开始，数据被更新，然后事务被提交或回滚，这取决于数据库操作的结果。然而，在许多情况下，根据应用程序的需求和应用程序需要与之交互的后端资源(如 RDBMS、面向消息的中间件、ERP 系统等等)，事务管理可能要复杂得多。

在 Java 应用程序开发的早期(在 JDBC 创建之后，但在 JEE 标准或像 Spring 这样的应用程序框架可用之前)，开发人员以编程方式控制和管理应用程序代码中的事务。当 JEE，更具体地说，EJB 标准可用时，开发人员能够使用容器管理的事务(CMTs)以声明的方式管理事务。但是 EJB 部署描述符中复杂的事务声明很难维护，并且给事务处理带来了不必要的复杂性。一些开发人员喜欢对事务有更多的控制，并选择 bean 管理的事务(BMTs)来以编程的方式管理事务。然而，用 Java 事务 API (JTA)编程的复杂性也阻碍了开发人员的生产力。

正如在第 5 章中所讨论的，事务管理是一个横切关注点，不应该编码在业务逻辑中。实现事务管理的最合适的方式是允许开发人员以声明的方式定义事务需求，并让 Spring、JEE 或 AOP 等框架代表我们编织事务处理逻辑。在本章中，我们将讨论 Spring 如何帮助简化事务处理逻辑的实现。Spring 同时支持声明式和编程式事务管理。

Spring 为声明性事务提供了出色的支持，这意味着您不需要用事务管理代码来混淆您的业务逻辑。您所要做的就是声明那些必须参与事务的方法(在类或层中),以及事务配置的细节，Spring 将负责处理事务管理。更具体地说，本章包括以下内容:

*   Spring 事务抽象层:我们讨论 Spring 事务抽象类的基本组件，并解释如何使用这些类来控制事务的属性。
*   声明式事务管理:我们向您展示了如何使用 Spring 和普通 Java 对象来实现声明式事务管理。我们提供了使用 XML 配置文件和 Java 注释进行声明式事务管理的例子。
*   编程式事务管理:尽管编程式事务管理并不经常使用，但我们解释了如何使用 Spring 提供的`TransactionTemplate`类，它让您可以完全控制事务管理代码。
*   使用 JTA 的全局事务:对于需要跨越多个后端资源的全局事务，我们展示了如何使用 JTA 在 Spring 中配置和实现全局事务。

## 探索 Spring 事务抽象层

在开发应用程序时，无论您是否选择使用 Spring，您都必须在使用事务时做出一个基本的选择，即是使用全局事务还是本地事务。本地事务特定于单个事务性资源(例如，JDBC 连接)，而全局事务由容器管理，可以跨多个事务性资源。

### 交易类型

本地事务易于管理，如果应用程序中的所有操作只需要与一个事务性资源交互(如 JDBC 事务)，使用本地事务就足够了。但是，如果您没有使用 Spring 之类的应用程序框架，那么您需要编写大量的事务管理代码，并且如果将来需要跨多个事务资源扩展事务的范围，那么您必须放弃本地事务管理代码，重新编写它以使用全局事务。

在 Java 世界中，全局事务是通过 JTA 实现的。在这个场景中，一个 JTA 兼容的事务管理器通过各自的资源管理器连接到多个事务资源，这些资源管理器能够通过 XA 协议(一个定义分布式事务的开放标准)与事务管理器通信，两阶段提交(2PC)机制用于确保所有后端数据源都被更新或一起回滚。如果任何一个后端资源失败，整个事务将回滚，因此对其他资源的更新也将回滚。

图 [9-1](#Fig1) 显示了与 JTA 的全球交易的高级视图。如图 [9-1](#Fig1) 所示，一个全局事务(通常也称为分布式事务)有四个主要参与方。第一方是后端资源，比如 RDBMS、消息中间件、企业资源规划(ERP)系统等等。

![A315511_5_En_9_Fig1_HTML.jpg](../Images/A315511_5_En_9_Fig1_HTML.jpg)

图 9-1。

Overview of global transactions with JTA

第二方是资源管理器，一般由后端资源厂商提供，负责与后端资源交互。例如，当连接到 MySQL 数据库时，我们需要与 MySQL 的 Java 连接器提供的`MysqlXADataSource`类进行交互。其他后端资源(例如 MQ、ERP 等等)也提供了它们的资源管理器。

第三方是 JTA 事务管理器，它负责管理、协调事务状态，并与参与事务的所有资源管理器同步事务状态。使用 XA 协议，这是一种广泛用于分布式事务处理的开放标准。JTA 事务管理器还支持 2PC，因此所有的更改将一起提交，如果任何资源更新失败，整个事务将回滚，导致没有任何资源被更新。整个机制由 Java 事务服务(JTS)规范指定。

最后一个组件是应用程序。应用程序本身或者运行应用程序的底层容器或 Spring 框架管理事务(开始、提交、回滚事务，等等)。同时，应用程序通过 JEE 定义的各种标准与底层后端资源进行交互。如图 [9-1](#Fig1) 所示，应用程序通过 JDBC 连接到 RDBMS，通过 JMS 连接到 MQ，通过 Java EE 连接器架构(JCA)连接到 ERP 系统。

所有成熟的符合 JEE 标准的应用服务器(例如，JBoss、WebSphere、WebLogic 和 GlassFish)都支持 JTA，在这些服务器中，可以通过 JNDI 查找来处理事务。至于独立的应用程序或 web 容器(例如，Tomcat 和 Jetty)，也存在开放源代码和商业解决方案，在这些环境中提供对 JTA/XA 的支持(例如，Atomikos、Java Open Transaction Manager[JOTM]和 Bitronix)。

## PlatformTransactionManager 的实现

在 Spring 中，`PlatformTransactionManager`接口使用`TransactionDefinition`和`TransactionStatus`接口来创建和管理事务。这些接口的实际实现必须详细了解事务管理器。

图 [9-2](#Fig2) 显示了`PlatformTransactionManager`在 Spring 中的实现。

![A315511_5_En_9_Fig2_HTML.jpg](../Images/A315511_5_En_9_Fig2_HTML.jpg)

图 9-2。

PlatformTransactionManager implementations as of Spring

Spring 为`PlatformTransactionManager`接口提供了丰富的实现。`CciLocalTransactionManager`类支持 JEE、JCA 和公共客户端接口(CCI)。`DataSourceTransactionManager`类用于一般的 JDBC 连接。对于 ORM 端，有很多实现，包括 JPA(`JpaTransactionManager`类) [<sup>1</sup>](#Fn1) 和 Hibernate 5 ( `HibernateTransactionManager`)。 [<sup>2</sup>](#Fn2) 对于 JMS，实现通过`JmsTransactionManager`类支持 JMS 2.0。 [<sup>3</sup>](#Fn3) 对于 JTA，通用的实现类是`JtaTransactionManager`。Spring 还提供了几个特定于特定应用服务器的 JTA 事务管理器类。这些类为 WebSphere(`WebSphereUowTransactionManager`类)、WebLogic(`WebLogicJtaTransactionManager`类)和 Oracle OC4J(`OC4JJtaTransactionManager`类)提供了本地支持。

## 分析事务属性

在这一节中，我们将讨论 Spring 支持的事务属性，重点是作为后端资源与 RDBMS 进行交互。

事务有四个众所周知的 ACID 属性(原子性、一致性、隔离性和持久性)，事务资源负责维护事务的这些方面。您无法控制事务的原子性、一致性和持久性。但是，您可以控制事务传播和超时，以及配置事务是否应该是只读的和指定隔离级别。

Spring 将所有这些设置封装在一个`TransactionDefinition`接口中。该接口用于 Spring 中事务支持的核心接口，即`PlatformTransactionManager`接口，其实现在特定平台上执行事务管理，如 JDBC 或 JTA。核心方法`PlatformTransactionManager.getTransaction()`将一个`TransactionDefinition`接口作为参数，并返回一个`TransactionStatus`接口。`TransactionStatus`接口用于控制交易执行，更具体地说是设置交易结果，检查交易是否完成或是否是新交易。

### 事务定义接口

正如我们前面提到的，`TransactionDefinition`接口控制事务的属性。让我们更详细地看看这里显示的`TransactionDefinition`接口，并描述它的方法:

```
package org.springframework.transaction;

import java.sql.Connection;

public interface TransactionDefinition {

    // Variable declaration statements omitted
    ...

    int getPropagationBehavior();

    int getIsolationLevel();

    int getTimeout();

    boolean isReadOnly();

    String getName();

}

```

这个接口的简单而明显的方法是`getTimeout()`，它返回事务必须完成的时间(以秒为单位)和`isReadOnly()`，它指示事务是否是只读的。事务管理器实现可以使用这个值来优化执行，并进行检查以确保事务只执行读操作。`getName()`方法返回事务的名称。

另外两种方法`getPropagationBehavior()`和`getIsolationLevel()`，需要更详细的讨论。我们从`getIsolationLevel()`开始，它控制其他事务看到的数据变化。表 [9-1](#Tab1) 列出了您可以使用的事务隔离级别，并解释了在当前事务中其他事务可以访问的更改。隔离级别表示为在`TransactionDefinition`接口中定义的静态值。

表 9-1。

Transaction Isolation Levels

<colgroup><col> <col></colgroup> 
| 隔离级别 | 描述 |
| --- | --- |
| `ISOLATION_DEFAULT` | 基础数据存储区的默认隔离级别。 |
| `ISOLATION_READ_UNCOMMITTED` | 最低水平的隔离；它几乎不是一个事务，因为它允许这个事务看到被其他未提交的事务修改的数据。 |
| `ISOLATION_READ_COMMITTED` | 大多数数据库中的默认级别；它确保其他事务不能读取其他事务未提交的数据。但是，由一个事务读取的数据可以由其他事务更新。 |
| `ISOLATION_REPEATABLE_READ` | 比`ISOLATION_READ_COMMITTED`更严格；它确保一旦选择了数据，您至少可以再次选择相同的集合。但是，如果其他事务插入了新数据，您仍然可以选择新插入的数据。 |
| `ISOLATION_SERIALIZABLE` | 最昂贵、最可靠的隔离级别；所有事务都被视为是一个接一个执行的。 |

选择适当的隔离级别对于数据的一致性很重要，但是做出这些选择会对性能产生很大的影响。最高隔离级别`ISOLATION_SERIALIZABLE`的维护成本特别高。

`getPropagationBehavior()`方法根据是否有活动的事务来指定事务调用会发生什么。表 [9-2](#Tab2) 描述了该方法的数值。传播类型被表示为在`TransactionDefinition`接口中定义的静态值。

表 9-2。

Transaction Isolation Levels

<colgroup><col> <col></colgroup> 
| 传播类型 | 描述 |
| --- | --- |
| `PROPAGATION_REQUIRED` | 支持已经存在的事务。如果没有事务，它将开始一个新的事务。 |
| `PROPAGATION_SUPPORTS` | 支持已经存在的事务。如果没有事务，它将以非事务方式执行。 |
| `PROPAGATION_MANDATORY` | 支持已经存在的事务。如果没有活动事务，将引发异常。 |
| `PROPAGATION_REQUIRES_NEW` | 总是开始一个新的事务。如果活动事务已经存在，它将被挂起。 |
| `PROPAGATION_NOT_SUPPORTED` | 不支持活动事务的执行。总是以非事务方式执行，并挂起任何现有的事务。 |
| `PROPAGATION_NEVER` | 即使存在活动事务，也总是以非事务方式执行。如果存在活动事务，将引发异常。 |
| `PROPAGATION_NESTED` | 如果活动事务存在，则在嵌套事务中运行。如果没有活动的事务，则如同设置了`PROPAGATION_REQUIRED`一样执行。 |

### TransactionStatus 接口

接下来显示的`TransactionStatus`接口允许事务管理器控制事务的执行。该代码可以检查事务是新事务还是只读事务，并且可以启动回滚。

```
package org.springframework.transaction;

public interface TransactionStatus extends SavepointManager {

    boolean isNewTransaction();

    boolean hasSavepoint();

    void setRollbackOnly();

    boolean isRollbackOnly();

    void flush();

    boolean isCompleted();

}

```

`TransactionStatus`接口的方法是不言自明的；最值得注意的是`setRollbackOnly()`，它会导致回滚并结束活动事务。

`hasSavePoint()`方法返回事务内部是否带有保存点(也就是说，事务是作为基于保存点的嵌套事务创建的)。如果适用的话,`flush()`方法是到数据存储的底层会话(例如，当使用 Hibernate 时)。`isCompleted()`方法返回事务是否已经结束(即提交或回滚)。

## 示例代码的示例数据模型和基础结构

本节概述了我们的事务管理示例中使用的数据模型和基础设施。我们使用 JPA 和 Hibernate 作为实现数据访问逻辑的持久层。此外，Spring Data JPA 及其存储库抽象用于简化基本数据库操作的开发。

### 创建一个带有依赖项的简单 Spring JPA 项目

让我们从创建项目开始。因为我们使用的是 JPA，所以我们还需要为本章中的例子添加所需的依赖项。

```
//pro-spring-15/build.gradle
ext {
    //spring libs
    springVersion = '5.0.0.RC1'
    bootVersion = '2.0.0.BUILD-SNAPSHOT'
    springDataVersion = '2.0.0.M3'

    //logging libs
    slf4jVersion = '1.7.25'
    logbackVersion = '1.2.3'
    guavaVersion = '21.0'
    junitVersion = '4.12'

    aspectjVersion = '1.9.0.BETA-5'

    //database library
    h2Version =  '1.4.194'

    //persistency libraries
    hibernateVersion = '5.2.10.Final'
    hibernateJpaVersion = '1.0.0.Final'
    atomikosVersion = '4.0.0M4'

    spring = [
        context       : "org.springframework:spring-context:$springVersion",
        aop           : "org.springframework:spring-aop:$springVersion",
        aspects       : "org.springframework:spring-aspects:$springVersion",
        tx            : "org.springframework:spring-tx:$springVersion",
        jdbc          : "org.springframework:spring-jdbc:$springVersion",
        contextSupport: "org.springframework:spring-context-support:$springVersion",
        orm           : "org.springframework:spring-orm:$springVersion",
        data          : "org.springframework.data:spring-data-jpa:$springDataVersion",
        test          : "org.springframework:spring-test:$springVersion"
    ]

    hibernate = [
        ...
        em            : "org.hibernate:hibernate-entitymanager:$hibernateVersion",
        tx            : "com.atomikos:transactions-hibernate4:$atomikosVersion"
    ]

    boot = [
        ...
        springBootPlugin:
           "org.springframework.boot:spring-boot-gradle-plugin:$bootVersion",
        starterJpa      :
            "org.springframework.boot:spring-boot-starter-data-jpa:$bootVersion"
    ]

    testing = [
        junit: "junit:junit:$junitVersion"
    ]

    misc = [
        ...
        slf4jJcl     : "org.slf4j:jcl-over-slf4j:$slf4jVersion",
        logback      : "ch.qos.logback:logback-classic:$logbackVersion",
        aspectjweaver: "org.aspectj:aspectjweaver:$aspectjVersion",
        lang3        : "org.apache.commons:commons-lang3:3.5",
        guava        : "com.google.guava:guava:$guavaVersion"
    ]

    db = [
        ...
        h2   : "com.h2database:h2:$h2Version"
    ]
}

//chapter09/build.gradle
dependencies {
    //we specify these dependencies for all submodules, except
    // the boot module, that defines its own
    if !project.name.contains"boot" {
        //we exclude transitive dependencies, because spring-data
        //will take care of these
           compile spring.contextSupport {
           exclude  module: 'spring-context'
           exclude  module: 'spring-beans'
           exclude  module: 'spring-core'
        }
        //we exclude the 'hibernate' transitive dependency
        //to have control over the version used
        compile hibernate.tx {
       exclude group: 'org.hibernate', module: 'hibernate'
    }
        compile spring.orm, spring.context, misc.slf4jJcl,
           misc.logback, db.h2, misc.lang3,
         hibernate.em
     }
     testCompile testing.junit
}

```

为了在我们修改事务属性时观察示例代码的详细行为，让我们也在`logback`中打开`DEBUG`级别的日志记录。下面的代码片段显示了`logback.xml`文件:

```
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

    <contextListener class="ch.qos.logback.classic.jul.LevelChangePropagator">
        <resetJUL>true</resetJUL>
    </contextListener>

    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} %thread %-5level %logger{5} - %msg%n</pattern>
        </encoder>
    </appender>

    <logger name="com.apress.prospring5.ch8" level="debug"/>

    <logger name="org.springframework.transaction"  level="info"/>

    <logger name="org.hibernate.SQL" level="debug"/>

    <root level="info">
        <appender-ref ref="console" />
    </root>
</configuration>

```

### 样本数据模型和公共类

为了简单起见，我们将只使用两个表，即我们在关于数据访问的章节中使用的`SINGER`和`ALBUM`表。不需要 SQL 脚本来创建表格，因为您可以使用 Hibernate 属性`hibernate.hbm2ddl.auto`并将其设置为`create-drop`，这样每次测试时我们都会有一个干净的运行。表格将基于`Singer`和`Album`实体生成。下面描述了带有注释字段的片段:

```
//Singer.java
package com.apress.prospring5.ch9.entities;
...

@Entity
@Table(name = "singer")
@NamedQueries({
        @NamedQuery(name=Singer.FIND_ALL, query="select s from Singer s"),
        @NamedQuery(name=Singer.COUNT_ALL, query="select count(s) from Singer s")
})
public class Singer implements Serializable {

    public static final String FIND_ALL = "Singer.findAll";
    public static final String COUNT_ALL = "Singer.countAll";

    @Id
    @GeneratedValue(strategy = IDENTITY)
    @Column(name = "ID")
    private Long id;

    @Version
    @Column(name = "VERSION")
    private int version;

    @Column(name = "FIRST_NAME")
    private String firstName;

    @Column(name = "LAST_NAME")
    private String lastName;

    @Temporal(TemporalType.DATE)
    @Column(name = "BIRTH_DATE")
    private Date birthDate;

    @OneToMany(mappedBy = "singer", cascade=CascadeType.ALL, orphanRemoval=true)
    private Set<Album> albums = new HashSet<>();

    ...
}
/Album.java
package com.apress.prospring5.ch9.entities;
...
@Entity
@Table(name  =  "album")
public class Album  implements Serializable {
    @Id
    @GeneratedValue(strategy = IDENTITY)
    @Column(name = "ID")
    private Long id;

    @Version
    @Column(name = "VERSION")
    private int version;

    @Column
    private String title;

    @Temporal(TemporalType.DATE)
    @Column(name = "RELEASE_DATE")

    private Date releaseDate;

    @ManyToOne
    @JoinColumn(name = "SINGER_ID")
    private Singer singer;
    ...
}

```

这两个类将被隔离在一个名为`base-dao`的项目中，该项目将成为所有事务项目的依赖项。除了实体之外，这个项目中还定义了存储库接口。我们将在稍后的课程中对它们进行描述。还需要一个配置类来定义`DataSource` bean。这里显示了配置类，出于实用和教育目的，将直接使用数据库凭证、驱动程序和 URL，而不是从外部文件读取。(不过，在生产中你永远不会遇到这种情况。我们希望。)

```
package com.apress.prospring5.ch9.config;
...

@Configuration
@EnableJpaRepositories(basePackages = {"com.apress.prospring5.ch9.repos"})
public class DataJpaConfig {

   private static Logger logger =
      LoggerFactory.getLogger(DataJpaConfig.class);

   @SuppressWarnings("unchecked")
   @Bean
   public DataSource dataSource() {
      try {
         SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
         Class<? extends Driver> driver =
            (Class<? extends Driver>) Class.forName("org.h2.Driver");
         dataSource.setDriverClass(driver);
         dataSource.setUrl("jdbc:h2:musicdb");
         dataSource.setUsername("prospring5");
         dataSource.setPassword("prospring5");
         return dataSource;
      } catch (Exception e) {
         logger.error("Populator DataSource bean cannot be created!", e);
         return null;
      }
   }

   @Bean
   public Properties hibernateProperties() {
      Properties hibernateProp = new  Properties();
      hibernateProp.put("hibernate.dialect", "org.hibernate.dialect.H2Dialect");
      hibernateProp.put("hibernate.hbm2ddl.auto", "create-drop");

      //hibernateProp.put("hibernate.format_sql", true);
      hibernateProp.put("hibernate.show_sql", true);
      hibernateProp.put("hibernate.max_fetch_depth", 3);
      hibernateProp.put("hibernate.jdbc.batch_size", 10);
      hibernateProp.put("hibernate.jdbc.fetch_size", 50);
      return hibernateProp;
   }

   @Bean
   public JpaVendorAdapter jpaVendorAdapter() {
      return new HibernateJpaVendorAdapter();
   }

   @Bean
   public EntityManagerFactory entityManagerFactory() {
      LocalContainerEntityManagerFactoryBean factoryBean =
          new LocalContainerEntityManagerFactoryBean();
      factoryBean.setPackagesToScan("com.apress.prospring5.ch9.entities");
      factoryBean.setDataSource(dataSource());
      factoryBean.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
      factoryBean.setJpaProperties(hibernateProperties());
      factoryBean.setJpaVendorAdapter(jpaVendorAdapter());
      factoryBean.afterPropertiesSet();
      return factoryBean.getNativeEntityManagerFactory();
   }
}

```

定义了嵌入式 H2 数据库。凭证直接在代码中设置，`DataSource`实现是`SimpleDriverDataSource`，它被设计成只用于简单的、测试的或教育的应用程序。

目前，使用注释是 Spring 中定义事务需求最常见的方式。主要的好处是，事务需求和详细的事务属性(超时、隔离级别、传播行为等等)都是在代码本身中定义的，这使得应用程序更容易跟踪和维护。配置也是使用注释和 Java 配置类来完成的。为了使用 XML 配置在 Spring 中启用对事务管理的注释支持，我们需要在 XML 配置文件中添加`<tx:annotation-driven>`标记。在下面的配置片段中，您可以看到事务性配置和事务性匹配名称空间的片段。如果您感兴趣，可以在项目中找到完整的配置。

```
<?xml version="1.0" encoding="UTF-8"?>
<beans 
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       ...
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd ...">

    <bean id="transactionManager"

        class="org.springframework.orm.jpa.JpaTransactionManager">
        <property name="entityManagerFactory" ref="emf"/>
    </bean>

    <tx:annotation-driven />

    <bean id="emf"
       class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
        ...
    </bean>

    <context:component-scan
            base-package="com.apress.prospring5.ch9" />

    <jpa:repositories base-package="com.apress.prospring5.ch9.repos"
                      entity-manager-factory-ref="emf"
                      transaction-manager-ref="transactionManager"/>
</beans>

```

因为我们使用 JPA，所以您定义了`JpaTransactionManager` bean。`<tx:annotation-driven>`标签指定我们使用注释进行事务管理。这个简单的定义指示 Spring 寻找一个名为`transactionManager`的类型为`PlatformTransactionManager`的 bean。如果事务 bean 的名称不同，比如说`customTransactionManager`，元素定义必须用属性`transaction-manager`声明，该属性必须接收事务管理 bean 的名称作为值。

```
<tx:annotation-driven transaction-manager="customTransactionManager"/>

```

然后定义了`EntityManagerFactory` bean，后面跟着`<context:component-scan>`标记来扫描服务层类。最后，`<jpa:repositories>`标签用于启用 Spring Data JPA 的存储库抽象。这个元素在`DataJpaConfiguration`类中被替换为`@EnableJpaRepositories`注释。

在专业环境中，将持久性配置(DAO)与事务性配置(服务)分开是一种常见的做法。这就是为什么前面介绍的 XML 内容在 Java 配置中被分成两个配置类。前面介绍的`DataJpaConfig`只包含数据访问 bean，接下来描述的`ServicesConfig`只包含与事务管理相关的 bean:

```
package com.apress.prospring5.ch9.config;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.persistence.EntityManagerFactory;

@Configuration
@EnableTransactionManagement
@ComponentScan(basePackages = "com.apress.prospring5.ch9")
public class ServicesConfig {

    @Autowired EntityManagerFactory entityManagerFactory;

    @Bean
    public PlatformTransactionManager transactionManager()  {
        return new JpaTransactionManager(entityManagerFactory);
    }
}

```

对于`SingerService`接口的实现，我们首先用`SingerService`接口中所有方法的空实现来创建这个类。让我们首先实现`SingerService.findAll()`方法。下面的代码片段显示了实现了`findAll()`方法的`SingerServiceImpl`类:

```
package com.apress.prospring5.ch9.services;

import com.apress.prospring5.ch9.entities.Singer;
import com.apress.prospring5.ch9.repos.SingerRepository;
import com.google.common.collect.Lists;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service("singerService")
@Transactional
public class SingerServiceImpl implements SingerService {

    private SingerRepository singerRepository;

    @Autowired
    public void setSingerRepository(SingerRepository singerRepository) {
       this.singerRepository = singerRepository;
    }

    @Override
    @Transactional(readOnly = true)
    public List<Singer> findAll() {
       return Lists.newArrayList(singerRepository.findAll());
    }
}

```

当使用基于注释的事务管理时，我们需要处理的唯一注释是`@Transactional`。在前面的代码片段中，`@Transactional`注释应用于类级别，这意味着默认情况下，Spring 将确保在执行类中的每个方法之前存在一个事务。`@Transactional`注释支持许多属性，您可以提供这些属性来覆盖默认行为。表 [9-3](#Tab3) 显示了可用的属性，以及可能值和默认值。

表 9-3。

Attributes for the @Transactional Annotation

<colgroup><col> <col> <col></colgroup> 
| 属性名 | 缺省值 | 可能的值 |
| --- | --- | --- |
| `propagation` | `Propagation.REQUIRED` | `Propagation.REQUIRED``Propagation.SUPPORTS``Propagation.MANDATORY``Propagation.REQUIRES_NEW``Propagation.NOT_SUPPORTED``Propagation.NEVER`T6】 |
| `isolation` | `Isolation.DEFAULT`(底层资源的默认隔离级别) | `Isolation.DEFAULT``Isolation.READ_UNCOMMITTED``Isolation.READ_COMMITTED``Isolation.REPEATABLE_READ`T4】 |
| `timeout` | `TransactionDefinition.TIMEOUT_DEFAULT`(底层资源的默认事务超时，以秒为单位) | 大于零的整数值；指示超时的秒数 |
| `readOnly` | 错误的 | { `true`，`false` } |
| `rollbackFor` | 将回滚事务的异常类 | 不适用的 |
| `rollbackForClassName` | 将回滚事务的异常类名 | 不适用的 |
| `noRollbackFor` | 不会回滚事务的异常类 | 不适用的 |
| `noRollbackForClassName` | 不会回滚事务的异常类名 | 不适用的 |
| `value` | `""`(指定交易的限定符值) | 不适用的 |

因此，基于表 [9-3](#Tab3) ，没有任何属性的`@Transactional`注释意味着需要事务传播，隔离是默认的，超时是默认的，模式是读写。对于之前介绍的`findAll()`方法，该方法用`@Transactional(readOnly=true)`标注。这将覆盖在类级别应用的默认注释，所有其他属性不变，但是事务被设置为只读。下面的代码片段显示了`findAll()`方法的测试程序:

```
package com.apress.prospring5.ch9;

import java.util.List;
import com.apress.prospring5.ch9.config.DataJpaConfig;
import com.apress.prospring5.ch9.config.ServicesConfig;
import com.apress.prospring5.ch9.entities.Singer;
import com.apress.prospring5.ch9.services.SingerService;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.GenericApplicationContext;

public class TxAnnotationDemo {
    public static void main(String... args) {
        GenericApplicationContext ctx =
        new AnnotationConfigApplicationContext(ServicesConfig.class,
                DataJpaConfig.class);

        SingerService singerService = ctx.getBean(SingerService.class);

        List<Singer> singers = singerService.findAll();
        singers.forEach(s -> System.out.println(s));
        ctx.close();
    }
}

```

启用适当的日志记录，换句话说，`<logger name="org.springframework.orm.jpa" level="debug"/>`，您将能够在日志中看到与事务处理相关的消息。运行该程序会产生以下缩减的输出(有关完整的详细信息，请参见控制台中的调试日志):

```
DEBUG o.s.o.j.JpaTransactionManager - Creating new transaction with name
  [com.apress.prospring5.ch9.services.SingerServiceImpl.findAll]:
     PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly; ''
DEBUG o.s.o.j.JpaTransactionManager - Participating in existing transaction

Hibernate: select singer0_.ID as ID1_1_, singer0_.BIRTH_DATE as BIRTH_DA2_1_,
   singer0_.FIRST_NAME as FIRST_NA3_1_, singer0_.LAST_NAME as LAST_NAM4_1_,
   singer0_.VERSION as VERSION5_1_ from singer singer0_
DEBUG o.s.o.j.JpaTransactionManager - Closing JPA EntityManager
 [...] after transaction

DEBUG o.s.o.j.JpaTransactionManager - Initiating transaction commit

Singer - Id: 1, First name: John, Last name: Mayer, Birthday: 1977-10-16
Singer - Id: 2, First name: Eric, Last name: Clapton, Birthday: 1945-03-30
Singer - Id: 3, First name: John, Last name: Butler, Birthday: 1975-04-01

```

如前面的输出所示，为了清楚起见，删除了不相关的输出语句。首先，在运行`findAll()`方法之前，Spring 的`JpaTransactionManager`创建了一个具有默认属性的新事务(名称等于带有方法名称的完全限定类名)，但是事务被设置为只读，正如在方法级`@Transactional`注释中定义的那样。然后，提交查询，在完成且没有任何错误的情况下，提交事务。`JpaTransactionManager`处理事务的创建和提交操作。

让我们继续执行更新操作。我们需要在`SingerServiceImpl`接口中实现`findById()`和`save()`方法。以下代码片段显示了实现:

```
package com.apress.prospring5.ch9.services;
...

@Service("singerService")
@Transactional
public class SingerServiceImpl implements SingerService {

    private SingerRepository singerRepository;

    @Autowired
    public void setSingerRepository(SingerRepository singerRepository) {
        this.singerRepository = singerRepository;
    }

    @Override
    @Transactional(readOnly = true)
    public List<Singer> findAll() {
        return Lists.newArrayList(singerRepository.findAll());
    }

    @Override
    @Transactional(readOnly = true)
    public Singer findById(Long id) {
        return singerRepository.findById(id).get();
    }

    @Override
    public Singer save(Singer singer) {
        return singerRepository.save(singer);
    }
}

```

`findById()`方法也用`@Transactional(readOnly=true)`进行了注释。一般来说，`readOnly=true`属性应该应用于所有的查找器方法。主要原因是大多数持久性提供者会对只读事务执行一定程度的优化。例如，Hibernate 不会维护从打开只读的数据库中检索的托管实例的快照。

对于`save()`方法，我们简单地调用`CrudRepository.save()`方法，并且不提供任何注释。这意味着将使用类级别的注释，这是一个读写事务。让我们修改用于测试`save()`方法的`TxAnnotationDemo`类，如下面的代码所示:

```
package com.apress.prospring5.ch9;
...
public class TxAnnotationDemo {
    public static void main(String... args) {
        GenericApplicationContext ctx =
        new AnnotationConfigApplicationContext(ServicesConfig.class,
                DataJpaConfig.class);

        SingerService singerService = ctx.getBean(SingerService.class);

        List<Singer> singers = singerService.findAll();
        singers.forEach(s -> System.out.println(s));

        Singer singer = singerService.findById(1L);
        singer.setFirstName("John Clayton");
        singer.setLastName("Mayer");
        singerService.save(singer);
        System.out.println("Singer saved successfully: " + singer);

        ctx.close();
    }
}

```

检索 ID 为 1 的`Singer`对象，然后更新名字并保存到数据库中。运行代码会产生以下相关输出:

```
Singer saved successfully: Singer - Id: 1, First name: John Clayton,
   Last name: Mayer, Birthday: 1977-10-16

```

`save()`方法获取从类级`@Transactional`注释继承的默认属性。更新操作完成后，Spring 的`JpaTransactionManager`会触发一个事务提交，这会导致 Hibernate 刷新持久性上下文，并将底层的 JDBC 连接提交给数据库。最后，我们来看看`countAll()`的方法。我们将研究这种方法的两种事务配置。虽然`CrudRepository.count()`方法可以达到目的，但我们不会使用那种方法。相反，出于演示的目的，我们将实现另一个方法，主要是因为 Spring 数据中由`CrudRepository`接口定义的方法已经用适当的事务属性进行了标记。

下面的代码片段显示了在`SingerRepository`接口中定义的新方法`countAllSingers()`:

```
package com.apress.prospring5.ch9.repos;

import com.apress.prospring5.ch9.entities.Singer;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;

public interface SingerRepository extends
  CrudRepository<Singer, Long> {
    @Query("select count(s) from Singer s")
    Long countAllSingers();
}

```

对于新的`countAllSingers()`方法，应用了`@Query`注释，其值等于计算联系人数量的 JPQL 语句。下面的代码片段显示了`SingerServiceImpl`类中`countAll()`方法的实现:

```
package com.apress.prospring5.ch9.services;
...

@Service("singerService")
@Transactional
public class SingerServiceImpl implements SingerService {

    private SingerRepository singerRepository;

    @Autowired
    public void setSingerRepository(SingerRepository singerRepository) {
        this.singerRepository = singerRepository;
    }

    @Override
    @Transactional(readOnly=true)
    public long countAll() {
        return singerRepository.countAllSingers();
    }
}

```

注释与其他 finder 方法相同。要测试这个方法，只需在`TxAnnotationDemo`类的`main()`方法中添加`System.out.println("Singer count: " + contactService.countAll());`，并观察控制台。如果您看到类似`Singer count: 3`的消息，则该方法执行正确。

在这个输出中，您可以看到`countAll()`的事务是用只读等于 true 创建的，正如所预期的那样。但是对于`countAll()`函数，我们根本不想让它加入到事务中。我们不需要由底层 JPA `EntityManager`来管理结果。相反，我们只想得到计数并忘记它。在这种情况下，我们可以将事务传播行为覆盖到`Propagation.NEVER`。下面的方法显示了修改后的`countAll()`方法:

```
package com.apress.prospring5.ch9.services;
...

@Service("singerService")
@Transactional
public class SingerServiceImpl implements SingerService {
    ...
    @Override
    @Transactional(propagation = Propagation.NEVER)
    public long countAll() {
        return singerRepository.countAllSingers();
    }
}

```

再次运行测试代码，您会发现调试输出中不会为`countAll()`方法创建事务。

本节介绍了您在日常事务处理中需要处理的一些主要配置。对于特殊情况，您可能需要为特定异常定义超时、隔离级别、回滚(或不回滚)等等。

![A315511_5_En_9_Figa_HTML.jpg](../Images/A315511_5_En_9_Figa_HTML.jpg) Spring 的`JpaTransactionManager`不支持自定义隔离级别。相反，它总是使用基础数据存储区的默认隔离级别。如果您使用 Hibernate 作为 JPA 服务提供者，您可以使用一种变通方法:扩展`HibernateJpaDialect`类以支持定制的隔离级别。

### 使用 AOP 配置进行事务管理

另一种常见的声明式事务管理方法是使用 Spring 的 AOP 支持。在 Spring 版本 2 之前，我们需要使用`TransactionProxyFactoryBean`类来定义 Spring beans 的事务需求。然而，从版本 2 开始，Spring 通过引入`aop`名称空间和使用通用 AOP 配置技术来定义事务需求，提供了一种更简单的方法。当然，在引入注释之后，这种配置事务管理的方式也受到了反对。但是知道它的存在是有用的，以防万一你可能需要包装一个不属于你的项目的事务代码，并且你不能编辑它来添加`@Transaction`注释。

在下面的配置片段中，上一节中的示例是使用 XML 配置的，并使用了`aop`名称空间:

```
<?xml version="1.0" encoding="UTF-8"?>
<beans   
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean name="dataJpaConfig"
       class="com.apress.prospring5.ch9.config.DataJpaConfig" />

    <aop:config>
        <aop:pointcut id="serviceOperation" expression=
                "execution(* com.apress.prospring5.ch9.*ServiceImpl.*(..))"/>
        <aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/>
    </aop:config>

    <tx:advice id="txAdvice">
        <tx:attributes>
            <tx:method name="find*" read-only="true"/>
            <tx:method name="count*" propagation="NEVER"/>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager
        <property name="entityManagerFactory" ref="entityManagerFactory"/>
    </bean>

    <context:component-scan
            base-package="com.apress.prospring5.ch9.services" />
    </beans>

```

该配置与本节开始时介绍的 XML 配置非常相似。基本上，`<tx:annotation-driven>`标记被移除，而`<context:component-scan>`标记被修改为我们用于声明性事务管理的包名。最重要的标签是`<aop:config>`和`<tx:advice>`。

在`<aop:config>`标签下，为服务层内的所有操作定义了一个切入点(即`com.apress.prospring5.ch9.services`包下的所有实现类)。该通知引用了 ID 为`txAdvice`的 bean，它是由`<tx:advice>`标记定义的。在`<tx:advice>`标签中，我们为想要参与事务的各种方法配置了事务属性。如标签所示，您指定所有的 finder 方法(带有前缀`find`的方法)将是只读的，我们指定 count 方法(带有前缀`count`的方法)将不参与事务。对于其余的方法，将应用默认的事务行为。该配置与注释示例中的配置相同。

因为事务管理是通过`aop`显式完成的，所以`SingerServiceImpl`类或其中的方法不再需要`@Transactional`注释。

要测试前面的配置，可以使用下面的类:

```
package com.apress.prospring5.ch9;

import java.util.List;

import com.apress.prospring5.ch9.entities.Singer;
import com.apress.prospring5.ch9.services.SingerService;
import org.springframework.context.support.GenericXmlApplicationContext;

public class TxDeclarativeDemo {
    public static void main(String... args) {
        GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();
        ctx.load("classpath:spring/tx-declarative-app-context.xml");
        ctx.refresh();

        SingerService singerService = ctx.getBean(SingerService.class);

    // Testing  findAll()
        List<Singer> singers = singerService.findAll();
        singers.forEach(s -> System.out.println(s));

    // Testing save()
        Singer singer = singerService.findById(1L);
        singer.setFirstName("John Clayton");
        singerService.save(singer);
        System.out.println("Singer saved successfully: " + singer);

        // Testing  countAll()
        System.out.println("Singer count: " + singerService.countAll());

        ctx.close();
    }
}

```

我们将让您测试程序，并观察 Spring 和 Hibernate 执行的与事务相关的操作的输出。基本上，它们与注释示例相同。

## 使用程序化事务

第三种选择是以编程方式控制事务行为。在这种情况下，我们有两个选择。第一种是在 bean 中注入一个`PlatformTransactionManager`实例，直接与事务管理器交互。另一个选择是使用 Spring 提供的`TransactionTemplate`类，这大大简化了您的工作。在本节中，我们将演示如何使用`TransactionTemplate class`。为了简单起见，我们集中于实现`SingerServiceImpl.countAll()`方法。下面的代码片段描述了为使用编程事务而修改的`ServiceConfig`类:

```
package com.apress.prospring5.ch9.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.support.TransactionTemplate;

import javax.persistence.EntityManagerFactory;

@Configuration
@ComponentScan(basePackages = "com.apress.prospring5.ch9")
public class ServicesConfig {

    @Autowired EntityManagerFactory entityManagerFactory;

    @Bean
    public TransactionTemplate transactionTemplate() {
        TransactionTemplate tt = new TransactionTemplate();
        tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NEVER);
        tt.setTimeout(30);
        tt.setTransactionManager(transactionManager());
        return tt;
    }

    @Bean
    public PlatformTransactionManager transactionManager() {
        return new JpaTransactionManager(entityManagerFactory);
    }
}

```

这里删除了 AOP 事务通知。此外，使用`org.springframework.transaction.support.TransactionTemplate`类定义了一个带有一些事务属性的`transactionTemplate` bean。此外，`@EnableTransactionManagement`也被删除了，因为事务管理现在不是显式完成的。让我们看看`countAll()`方法的实现，如下所示:

```
package com.apress.prospring5.ch9.services;
import com.apress.prospring5.ch9.entities.Singer;
import com.apress.prospring5.ch9.repos.SingerRepository;
import com.google.common.collect.Lists;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.support.TransactionTemplate;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import java.util.List;

@Service("singerService")
@Repository
public class SingerServiceImpl implements SingerService {
    @Autowired
    private SingerRepository singerRepository;

    @Autowired
    private TransactionTemplate transactionTemplate;

    @PersistenceContext
    private EntityManager em;

    @Override
    public long countAll() {
        return transactionTemplate.execute(
        transactionStatus -> em.createNamedQuery(Singer.COUNT_ALL,
       Long.class).getSingleResult());
    }
}

```

这里的`TransactionTemplate`类是从 Spring 注入的。然后在`countAll()`方法中，调用`TransactionTemplate.execute()`方法，传入实现`TransactionCallback<T>`接口的内部类的声明。然后`doInTransaction()`被期望的逻辑覆盖。逻辑将在由`transactionTemplate` bean 定义的属性中运行。您没有清楚地看到前面代码片段中所有内容的原因是因为使用了 Java 8 lambda 表达式。以下代码是前面方法的扩展版本(因为它是在 lambda 表达式引入之前编写的):

```
public long countAll() {
       return transactionTemplate.execute(new TransactionCallback<Long>() {
           public Long doInTransaction(TransactionStatus transactionStatus) {
               return em.createNamedQuery(Singer.COUNT_ALL,
                       Long.class).getSingleResult();
           }
       });
   }

```

以下代码片段显示了测试程序:

```
package com.apress.prospring5.ch9;

import com.apress.prospring5.ch9.config.DataJpaConfig;
import com.apress.prospring5.ch9.config.ServicesConfig;
import com.apress.prospring5.ch9.services.SingerService;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.GenericApplicationContext;

public class TxProgrammaticDemo  {

    public static void main(String... args) {
        GenericApplicationContext ctx =
                 new AnnotationConfigApplicationContext(ServicesConfig.class,
                DataJpaConfig.class);
        SingerService singerService = ctx.getBean(SingerService.class);
        System.out.println("Singer count: " + singerService.countAll());

        ctx.close();
    }
}

```

我们将让您来运行程序并观察结果。尝试调整事务属性，看看在`countAll()`方法的事务处理中会发生什么。

### 关于交易管理的思考

那么，在讨论了实现事务管理的各种方法之后，您应该使用哪一种呢？在所有情况下都推荐使用声明性方法，并且应该尽可能避免在代码中实现事务管理。大多数情况下，当您发现有必要在应用程序中编写事务控制逻辑时，这是由于糟糕的设计，在这种情况下，您应该考虑将您的逻辑重构为可管理的部分，并在这些部分上以声明方式定义事务需求。

对于声明性方法，使用 XML 和使用注释各有利弊。一些开发人员不喜欢在代码中声明事务需求，而另一些开发人员则喜欢使用注释以便于维护，因为您可以在代码中看到所有的事务需求声明。同样，让应用程序需求驱动您的决策，一旦您的团队或公司已经标准化了方法，就要保持与配置风格的一致。

## Spring 的全球事务

许多企业 Java 应用程序需要访问多个后端资源。例如，从外部业务伙伴收到的一条客户信息可能需要更新多个系统(CRM、ERP 等)的数据库。有些人甚至需要为公司内对客户信息感兴趣的所有其他应用程序生成一条消息，并通过 JMS 将其发送到 MQ 服务器。跨越多个后端资源的事务被称为全局(或分布式)事务。

全局事务的一个主要特征是保证原子性，这意味着所涉及的资源都被更新，或者都不被更新。这包括应该由事务管理器处理的复杂的协调和同步逻辑。在 Java 世界中，JTA 是实现全局事务的事实上的标准。

Spring 支持 JTA 事务和本地事务，并在业务代码中隐藏了这种逻辑。在这一节中，我们将演示如何通过在 Spring 中使用 JTA 来实现全局事务。

### 实施 JTA 样本的基础设施

我们使用的表格与本章前面的示例中的表格相同。然而，嵌入式 H2 数据库并不完全支持 XA(至少在编写本文时是这样)，所以在本例中，我们使用 MySQL 作为后端数据库。

我们还想展示如何在独立应用程序或 web 容器环境中实现与 JTA 的全局事务。因此，在这个例子中，我们使用 Atomikos ( [`www.atomikos.com/Main/TransactionsEssentials`](http://www.atomikos.com/Main/TransactionsEssentials) )，这是一个广泛用于非 JEE 环境的开源 JTA 事务管理器。

为了展示全局事务是如何工作的，我们至少需要两个后端资源。为了简单起见，我们将使用一个 MySQL 数据库和两个 JPA 实体管理器来模拟用例。效果是一样的，因为不同的后端数据库有多个 JPA 持久性单元。

在 MySQL 数据库中，我们创建了两个模式和相应的用户，如以下 DDL 脚本所示:

```
CREATE USER 'prospring5_a'@'localhost' IDENTIFIED BY 'prospring5_a';
CREATE SCHEMA MUSICDB_A;
GRANT ALL PRIVILEGES ON MUSICDB_A . * TO 'prospring5_a'@'localhost';
     PRIVILEGES;

CREATE USER 'prospring5_b'@'localhost' IDENTIFIED BY 'prospring5_b';
CREATE SCHEMA  MUSICDB_B;
GRANT ALL PRIVILEGES ON MUSICDB_B . * TO 'prospring5_b'@'localhost';
     PRIVILEGES;

```

设置完成后，我们可以继续进行 Spring 配置和实现。

### 实施与 JTA 的全球交易

首先我们来看看 Spring 的配置。下面的代码片段描述了声明访问两个数据库所需的 beans 的`XAJpaConfig`配置类:

```
package com.apress.prospring5.ch9.config;

import com.atomikos.jdbc.AtomikosDataSourceBean;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.datasource.SimpleDriverDataSource;
import org.springframework.orm.jpa.JpaVendorAdapter;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

import javax.persistence.EntityManagerFactory;
import javax.sql.DataSource;
import java.sql.Driver;
import java.util.Properties;

@Configuration
@EnableJpaRepositories
public class XAJpaConfig {

    private static Logger logger = LoggerFactory.getLogger(XAJpaConfig.class);
    @SuppressWarnings("unchecked")
    @Bean(initMethod = "init", destroyMethod = "close")
    public DataSource dataSourceA() {
        try {
            AtomikosDataSourceBean dataSource = new AtomikosDataSourceBean();
            dataSource.setUniqueResourceName("XADBMSA");
            dataSource.setXaDataSourceClassName(
                   "com.mysql.cj.jdbc.MysqlXADataSource");
            dataSource.setXaProperties(xaAProperties());
            dataSource.setPoolSize(1);
            return dataSource;
        } catch (Exception e) {
            logger.error("Populator DataSource bean cannot be created!", e);
            return null;
        }
    }

    @Bean
    public Properties xaAProperties() {
        Properties xaProp = new Properties();
        xaProp.put("databaseName", "musicdb_a");
        xaProp.put("user", "prospring5_a");
        xaProp.put("password", "prospring5_a");
        return xaProp;
    }

    @SuppressWarnings("unchecked")
    @Bean(initMethod = "init", destroyMethod = "close")
    public DataSource dataSourceB() {
        try {
            AtomikosDataSourceBean dataSource = new AtomikosDataSourceBean();
            dataSource.setUniqueResourceName("XADBMSB");
            dataSource.setXaDataSourceClassName(
                    "com.mysql.cj.jdbc.MysqlXADataSource");
            dataSource.setXaProperties(xaBProperties());
            dataSource.setPoolSize(1);
            return dataSource;
        } catch (Exception e) {
            logger.error("Populator DataSource bean cannot be created!", e);
            return null;
        }
    }

    @Bean
    public Properties xaBProperties() {
        Properties xaProp = new Properties();
        xaProp.put("databaseName", "musicdb_b");
        xaProp.put("user", "prospring5_b");
        xaProp.put("password", "prospring5_b");
        return xaProp;
    }

    @Bean
    public Properties hibernateProperties() {
        Properties hibernateProp = new Properties();
        hibernateProp.put("hibernate.transaction.factory_class",
                     "org.hibernate.transaction.JTATransactionFactory");
        hibernateProp.put("hibernate.transaction.jta.platform",
              "com.atomikos.icatch.jta.hibernate4.AtomikosPlatform");
        // required by Hibernate 5
        hibernateProp.put("hibernate.transaction.coordinator_class", "jta");
        hibernateProp.put("hibernate.dialect",
            "org.hibernate.dialect.MySQL5Dialect");
        // this will work only if users/schemas are created first,
        // use ddl.sql script for this
        hibernateProp.put("hibernate.hbm2ddl.auto", "create-drop");
        hibernateProp.put("hibernate.show_sql", true);
        hibernateProp.put("hibernate.max_fetch_depth", 3);
        hibernateProp.put("hibernate.jdbc.batch_size", 10);
        hibernateProp.put("hibernate.jdbc.fetch_size", 50);
        return hibernateProp;
    }

    @Bean
    public EntityManagerFactory emfA() {
        LocalContainerEntityManagerFactoryBean factoryBean =
             new LocalContainerEntityManagerFactoryBean();
        factoryBean.setPackagesToScan("com.apress.prospring5.ch9.entities");
        factoryBean.setDataSource(dataSourceA());
        factoryBean.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
        factoryBean.setJpaProperties(hibernateProperties());
        factoryBean.setPersistenceUnitName("emfA");
        factoryBean.afterPropertiesSet();
        return factoryBean.getObject();
    }

    @Bean
    public EntityManagerFactory emfB() {
        LocalContainerEntityManagerFactoryBean factoryBean =
             new LocalContainerEntityManagerFactoryBean();
        factoryBean.setPackagesToScan("com.apress.prospring5.ch9.entities");
        factoryBean.setDataSource(dataSourceB());
        factoryBean.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
        factoryBean.setJpaProperties(hibernateProperties());
        factoryBean.setPersistenceUnitName("emfB");
        factoryBean.afterPropertiesSet();
        return factoryBean.getObject();
    }
}

```

配置长但不太复杂。首先，定义两个`DataSource`bean 来表示两个数据库资源。bean 名称是`dataSourceA`和`dataSourceB`，它们分别连接到模式`musicdb_a`和`musicdb_a`。两个`DataSource`bean 都使用类`com.atomikos.jdbc.AtomikosDataSourceBean`，该类支持 XA 兼容的`DataSource`，在两个 bean 的定义中，定义了 MySQL 的 XA `DataSource`实现类:`com.mysql.cj.jdbc.MysqlXADataSource`，它是 MySQL 的资源管理器。然后，提供数据库连接信息。注意，`poolSize`属性定义了 Atomikos 需要维护的连接池中的连接数。这不是强制性的。但是，如果没有提供该属性，Atomikos 将使用默认值 1。

然后，定义两个`EntityManagerFactory`bean，命名为`emfA`和`emfB`。常见的 JPA 属性一起包装在`hibernateProperties` bean 中。两个 beans 唯一的区别就是被注入了相应的数据源(即`dataSourceA`注入了`emfA`，而`dataSourceB`注入了`emfB`)。因此，`emfA`将通过`dataSourceA` bean 连接到 MySQL 的`prospring5_a`模式，而`emfB`将通过`dataSourceB` bean 连接到`prospring5_b`模式。看看`emfBase` bean 中的属性`hibernate.transaction.factory_class`和`hibernate.transaction.jta.platform`。这两个属性非常重要，因为 Hibernate 使用它们来查找底层的`UserTransaction`和`TransactionManager`bean，以参与它管理的全局事务的持久性上下文。同样重要的是让 Hibernate 4 的 Atomikos 类与 Hibernate 5 一起工作所需的`hibernate.transaction.coordinator_class`。 [<sup>4</sup>](#Fn4)

下面的代码片段描述了`ServicesConfig`，它声明了用于实现全局事务管理的 beans:

```
package com.apress.prospring5.ch9.config;

import com.atomikos.icatch.config.UserTransactionService;
import com.atomikos.icatch.config.UserTransactionServiceImp;
import com.atomikos.icatch.jta.UserTransactionImp;
import com.atomikos.icatch.jta.UserTransactionManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.DependsOn;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.transaction.jta.JtaTransactionManager;

import javax.transaction.SystemException;
import javax.transaction.UserTransaction;
import java.util.Properties;

@Configuration
@EnableTransactionManagement
@ComponentScan(basePackages = "com.apress.prospring5.ch9.services")
public class ServicesConfig {

    private Logger logger = LoggerFactory.getLogger(ServicesConfig.class);
    @Bean(initMethod = "init", destroyMethod = "shutdownForce")
    public UserTransactionService userTransactionService(){
        Properties atProps = new Properties();
        atProps.put("com.atomikos.icatch.service",
          "com.atomikos.icatch.standalone.UserTransactionServiceFactory");
        return new UserTransactionServiceImp(atProps);
    }

    @Bean (initMethod = "init", destroyMethod = "close")
    @DependsOn("userTransactionService")
    public UserTransactionManager atomikosTransactionManager(){
        UserTransactionManager utm = new UserTransactionManager();
        utm.setStartupTransactionService(false);
        utm.setForceShutdown(true);
        return utm;
    }

    @Bean
    @DependsOn("userTransactionService")
    public UserTransaction userTransaction(){
        UserTransactionImp ut = new UserTransactionImp();
        try {
            ut.setTransactionTimeout(300);
        } catch (SystemException se) {
            logger.error("Configuration  exception.", se);
            return null;
        }
        return ut;
    }

    @Bean
    public PlatformTransactionManager transactionManager(){
        JtaTransactionManager ptm = new JtaTransactionManager();
        ptm.setTransactionManager(atomikosTransactionManager());
        ptm.setUserTransaction(userTransaction());
        return ptm;
    }
}

```

对于 Atomikos 部分，定义了两个 bean，即`atomikosTransactionManager`和`atomikosUserTransaction`bean。实现类由 Atomikos 提供，它分别实现了标准的 Spring `org.springframework.transaction.PlatformTransactionManager`和`javax.transaction.UserTransaction`接口。这些 beans 提供 JTA 所需的事务协调和同步服务，并通过支持 2PC 的 XA 协议与资源管理器通信。然后，定义 Spring 的`transactionManager` bean(用`org.springframework.transaction.jta.JtaTransactionManager`作为实现类)，注入 Atomikos 提供的两个事务 bean。这指示 Spring 使用 Atomikos JTA 进行事务管理。另外，请注意用于配置 Atomikos 事务服务来管理未决事务的`UserTransactionService` bean。 [<sup>5</sup>](#Fn5)

下面的代码片段显示了 JTA 的`SingerServiceImpl`类。注意，为了简单起见，只实现了`save()`方法。

```
package com.apress.prospring5.ch9.services;

import com.apress.prospring5.ch9.entities.Singer;
import org.apache.commons.lang3.NotImplementedException;
import org.springframework.orm.jpa.JpaSystemException;
import org.springframework.stereotype.Repository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.PersistenceException;
import java.util.List;

@Service("singerService")
@Repository
@Transactional
public class SingerServiceImpl implements SingerService {

    @PersistenceContext(unitName = "emfA")
    private EntityManager emA;
    @PersistenceContext(unitName = "emfB")
    private EntityManager emB;

    @Override
    @Transactional(readOnly = true)
    public List<Singer> findAll() {
        throw new NotImplementedException("findAll");
    }

    @Override
    @Transactional(readOnly = true)
    public Singer findById(Long id) {
        throw new NotImplementedException("findById");
    }

    @Override
    public Singer save(Singer singer) {
        Singer singerB = new Singer();
        singerB.setFirstName(singer.getFirstName());
        singerB.setLastName(singer.getLastName());
        if (singer.getId() == null) {
            emA.persist(singer);
            emB.persist(singerB);
            //throw new JpaSystemException(new PersistenceException());
        } else {
            emA.merge(singer);
            emB.merge(singer);
        }
        return singer;
    }

    @Override
    public long countAll() {
        return 0;
    }
}

```

定义的两个实体管理器被注入到`SingerServiceImpl`类中。在`save()`方法中，我们将联系对象分别持久化到两个模式中。此刻忽略抛出异常语句；稍后我们将使用它来验证当保存到模式`prospring5_b`失败时，事务被回滚。以下代码片段显示了测试程序:

```
package com.apress.prospring5.ch9;

import com.apress.prospring5.ch9.config.ServicesConfig;
import com.apress.prospring5.ch9.config.XAJpaConfig;
import com.apress.prospring5.ch9.entities.Singer;
import com.apress.prospring5.ch9.services.SingerService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.GenericApplicationContext;

import java.util.Date;
import java.util.GregorianCalendar;

public class TxJtaDemo {
    private static Logger logger = LoggerFactory.getLogger(TxJtaDemo.class);

    public static void main(String... args) {
        GenericApplicationContext ctx =
            new AnnotationConfigApplicationContext(ServicesConfig.class,
                XAJpaConfig.class);
        SingerService singerService = ctx.getBean(SingerService.class);
        Singer singer = new Singer();
        singer.setFirstName("John");
        singer.setLastName("Mayer");
        singer.setBirthDate(new  Date(
                (new GregorianCalendar(1977, 9, 16)).getTime().getTime()));
        singerService.save(singer);
        if (singer.getId() != null) {
            logger.info("--> Singer saved successfully");
        }  else {
            logger.info("--> Singer was  not saved, check the configuration!!");
        }
        ctx.close();
    }
}

```

程序创建一个新的 contact 对象并调用`SingerService.save()`方法。该实现将尝试将同一个对象保存到两个数据库中。假设一切顺利，运行程序会产生以下输出(另一个输出被省略):

```
--> Singer saved successfully

```

Atomikos 创建一个复合事务，与 XA `DataSource`(这里是 MySQL)通信，执行同步，提交事务，等等。从数据库中，您将看到新的联系人被分别保存到数据库的两个模式中。但是如果您想检查代码中的保存，您可以为`findAll()`方法提供一个实现来完成这项工作。

```
package com.apress.prospring5.ch9.services;
...
@Service("singerService")
@Repository
@Transactional
public class SingerServiceImpl implements SingerService {

    private static final String FIND_ALL= "select s from Singer s";

    @PersistenceContext(unitName = "emfA")
    private EntityManager emA;
    @PersistenceContext(unitName = "emfB")
    private EntityManager emB;

    @Override
    @Transactional(readOnly = true)
    public List<Singer> findAll()
    {
        List<Singer> singersFromA = findAllInA();
        List<Singer> singersFromB = findAllInB();
        if (singersFromA.size()!= singersFromB.size()){
            throw new AsyncXAResourcesException("
               XA resources do not contain the same expected data.");
        }
        Singer sA = singersFromA.get(0);
        Singer sB = singersFromB.get(0);
        if (!sA.getFirstName().equals(sB.getFirstName()))  {
            throw new AsyncXAResourcesException("
               XA resources do not contain the same expected data.");
        }
        List<Singer> singersFromBoth = new ArrayList<>();
        singersFromBoth.add(sA);
        singersFromBoth.add(sB);
        return  singersFromBoth;
    }

    private List<Singer> findAllInA(){
        return emA.createQuery(FIND_ALL).getResultList();
    }

    private List<Singer> findAllInB(){
        return emB.createQuery(FIND_ALL).getResultList();
    }
    ...
}

```

因此，测试保存在两个数据库中的歌手的代码可以修改如下:

```
package com.apress.prospring5.ch9;
...
public class TxJtaDemo {
    private static Logger logger = LoggerFactory.getLogger(TxJtaDemo.class);

    public static void main(String... args) {
        GenericApplicationContext ctx =
        new AnnotationConfigApplicationContext(ServicesConfig.class,
                XAJpaConfig.class);
        SingerService singerService = ctx.getBean(SingerService.class);
        Singer singer = new Singer();
        singer.setFirstName("John");
        singer.setLastName("Mayer");
        singer.setBirthDate(new Date(
                (new GregorianCalendar(1977, 9, 16)).getTime().getTime()));
        singerService.save(singer);
        if (singer.getId() != null) {
             logger.info("--> Singer saved successfully");
        }  else {
            logger.error("--> Singer was not saved, check the configuration!!");
        }

        // check saving in  both databases
        List<Singer> singers = singerService.findAll();
        if (singers.size()!= 2) {
            logger.error("--> Something went wrong.");
        } else {
            logger.info("--> Singers form both DBs: " + singers);
        }

        ctx.close();
    }
}

```

现在让我们看看回滚是如何工作的。如下面的代码片段所示，我们没有调用`emB.persist()`，而是抛出一个异常来模拟出了问题，数据无法保存在第二个数据库中。

```
package com.apress.prospring5.ch9.services;
...
@Service("singerService")
@Repository
@Transactional
public class SingerServiceImpl implements SingerService {

    private static final String FIND_ALL= "select s from Singer s";

    @PersistenceContext(unitName = "emfA")
    private EntityManager emA;
    @PersistenceContext(unitName = "emfB")
    private EntityManager emB;
    ...
    @Override
    public Singer save(Singer singer) {
        Singer singerB = new Singer();
        singerB.setFirstName(singer.getFirstName());
        singerB.setLastName(singer.getLastName());
        if (singer.getId() == null) {
            emA.persist(singer);
            if(true) {
                throw new JpaSystemException(new PersistenceException(
                   "Simulation of something going wrong."));
            }
            emB.persist(singerB);
        } else {
            emA.merge(singer);
            emB.merge(singer);
        }
        return singer;
    }

    @Override
    public long countAll() {
        return 0;
    }
}

```

再次运行该程序会产生以下结果:

```
...
INFO  o.h.h.i.QueryTranslatorFactoryInitiator - HHH000397:
   Using ASTQueryTranslatorFactory
INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Initialized JPA
   EntityManagerFactory for persistence unit 'emfA'
INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Initialized JPA
   EntityManagerFactory for persistence unit 'emfB'
INFO  o.s.t.j.JtaTransactionManager - Using JTA UserTransaction:
   com.atomikos.icatch.jta.UserTransactionImp@6da9dc6
INFO  o.s.t.j.JtaTransactionManager - Using JTA TransactionManager:
   com.atomikos.icatch.jta.UserTransactionManager@2216effc
DEBUG o.s.t.j.JtaTransactionManager - Creating new transaction with name
[com.apress.prospring5.ch9.services.SingerServiceImpl.save]:
   PROPAGATION_REQUIRED,ISOLATION_DEFAULT; ''
DEBUG  o.s.o.j.EntityManagerFactoryUtils - Opening JPA EntityManager
DEBUG  o.s.o.j.EntityManagerFactoryUtils - Registering transaction synchronization
   for JPA EntityManager
Hibernate: insert  into singer (BIRTH_DATE, FIRST_NAME, LAST_NAME, VERSION)
values (?, ?, ?, ?)
DEBUG  o.s.o.j.EntityManagerFactoryUtils - Closing JPA EntityManager
DEBUG  o.s.t.j.JtaTransactionManager - Initiating transaction rollback
WARN   c.a.j.AbstractConnectionProxy - Forcing close of pending statement:
   com.mysql.cj.jdbc.PreparedStatementWrapper@3f685162
Exception in  thread "main" org.springframework.orm.jpa.JpaSystemException:
   Simulation of something going wrong.;
...
Caused by: javax.persistence.PersistenceException:
   Simulation of something going wrong.

```

如前面的输出所示，第一个歌手被持久化(注意`insert`语句)。但是，当保存到第二个`DataSource`时，因为抛出了异常，Atomikos 将回滚整个事务。你可以看一下模式`musicdb_a`来检查新歌手没有被保存。

### 春船 JTA

JTA Spring Boot 入门版开箱即用，带有一组预配置的 beans，旨在帮助您专注于代码的业务功能，而不是环境设置。再说一遍，这是所有 Spring Boot 入门库都做的事情，不管是什么组件，所以前面的句子可能看起来有点多余。JTA 版的 Spring Boot 包含一个使用 Atomikos 的库，它会提取适当的库并为您配置 Atomikos 组件。将前面的例子迁移到 Spring Boot 意味着将`DataSource`和事务管理器配置导入到 Spring Boot 应用程序中。但是由于本节的目的是展示 Spring Boot 如何通过所提供的预配置 beans 来帮助加速涉及全局事务管理的应用程序的开发，因此有必要提供一个不同的示例。我们将假设我们想要向消息队列传输一条消息，表明创建了一个新的`Singer`实例。显然，如果将`Singer`记录保存到数据库失败，我们希望回滚事务并阻止消息被发送。为了总结这个例子，我们需要做以下事情:

*   Configure the Spring Boot Gradle project for JTA and JMS usage. The configuration is as follows:

    ```
    //build.gradle
    ext {
       ...
       bootVersion = '2.0.0.M1'
       atomikosVersion = '4.0.4'

       boot = [
             ...
        starterJpa :
          "org.springframework.boot:spring-boot-starter-data-jpa:$bootVersion",
        starterJta :
          "org.springframework.boot:spring-boot-starter-jta-atomikos:$bootVersion",
        starterJms :
          "org.springframework.boot:spring-boot-starter-artemis:$bootVersion"
       ]

       misc = [
             ...
             artemis      : "org.apache.activemq:artemis-jms-server:2.1.0"
       ]

       db = [
             ...
             h2   : "com.h2database:h2:$h2Version"
       ]
    }
    //chapter09/boot-jta/build.gradle
    buildscript {
       repositories {
          ...
       }

       dependencies {
          classpath boot.springBootPlugin
       }
    }

    apply plugin:  'org.springframework.boot'

    dependencies {
       compile boot.starterJpa, boot.starterJta, boot.starterJms, db.h2
       compilemisc.artemis {
          exclude group: 'org.apache.geronimo.specs',
              module: 'geronimo-jms_2.0_spec'
       }
    }

    ```

    In Figure [9-3](#Fig3) you can see the Spring Boot starter libraries declared earlier as dependencies for the project, and you can see the dependencies they add to the project.

    ![A315511_5_En_9_Fig3_HTML.jpg](../Images/A315511_5_En_9_Fig3_HTML.jpg)

    图 9-3。

    Spring Boot Starter libraries and their dependencies
*   定义`Singer`实体类和处理它的存储库。`Singer`实体类的结构与前面提到的相同，但是没有任何相关的实体。并且`SingerRepository`将被留空，因为只有`CrudRepository`已经提供的方法将在本例中使用:`save(..)`和`count()`。
*   定义一个将保存`Singer`记录并发送确认消息的服务类。

    ```
    package com.apress.prospring5.ch9.services;

    import com.apress.prospring5.ch9.entities.Singer;
    import com.apress.prospring5.ch9.ex.AsyncXAResourcesException;
    import com.apress.prospring5.ch9.repos.SingerRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.jms.core.JmsTemplate;
    import org.springframework.stereotype.Repository;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import javax.persistence.EntityManager;
    import javax.persistence.PersistenceContext;

    @Service("singerService")
    @Transactional
    public class SingerServiceImpl implements SingerService {

        private SingerRepository singerRepository;
        private JmsTemplate jmsTemplate;

        public SingerServiceImpl(SingerRepository singerRepository,
           JmsTemplate jmsTemplate) {
           this.singerRepository = singerRepository;
           this.jmsTemplate = jmsTemplate;
        }

        @Override
        public Singer save(Singer singer) {
           jmsTemplate.convertAndSend("singers", "Just saved:" + singer);
           if(singer == null) {
              throw new AsyncXAResourcesException(
                 "Simulation of something going wrong.");
           }
           singerRepository.save(singer);
           return singer;
        }

        @Override public long count() {
           return singerRepository.count();
        }
    }

    ```

    不需要`@Autowired`注释来注入存储库 bean，对于`JmsTemplate`也是如此。Spring Boot 就是这么神奇，它注入所需的豆子，如果只有它们被声明的话。
*   一个 bean，它将监听传递到`singers`队列的消息并打印它们。

    ```
    package com.apress.prospring5.ch9;

    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    import org.springframework.jms.annotation.JmsListener;
    import org.springframework.stereotype.Component;

    @Component
    public class Messages {
       private static Logger logger = LoggerFactory.getLogger(Messages.class);

       @JmsListener(destination="singers")
       public void onMessage(String content){
          logger.info("--> Received content: " + content);
       }
    }

    ```

*   配置 Artemis JMS 服务器，创建一个名为`singers`的嵌入式队列。这是通过在`application.properties`文件中用值`singers`设置`spring.artemis.embedded.queues`属性来完成的，该文件可用于配置 Spring Boot 应用程序。

    ```
    spring.artemis.embedded.queues=singers
    spring.jta.log-dir=out

    ```

    前面的配置片段描述了`application.properties`文件的内容。除了`spring.artemis.embedded.queues`属性之外，`spring.jta.log-dir`用于设置 Atomikos 应该在哪里写入 JTA 日志，在本例中设置了`out`目录。
*   下面是一个应用程序类，它将所有这些打包在一起并进行测试:

    ```
    package com.apress.prospring5.ch9;

    import com.apress.prospring5.ch9.entities.Singer;
    import com.apress.prospring5.ch9.services.SingerService;
    import com.atomikos.jdbc.AtomikosDataSourceBean;
    import org.h2.jdbcx.JdbcDataSource;
    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    import org.springframework.beans.factory.annotation.Autowired;
    import  org.springframework.boot.CommandLineRunner;
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.context.ConfigurableApplicationContext;
    import org.springframework.context.annotation.Bean;
    import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
    import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

    import javax.persistence.EntityManagerFactory;
    import javax.sql.DataSource;
    import java.util.Date;
    import java.util.GregorianCalendar;
    import java.util.Properties;

    import static org.hibernate.cfg.AvailableSettings.*;
    import static org.hibernate.cfg.AvailableSettings.STATEMENT_FETCH_SIZE;

    @SpringBootApplication(scanBasePackages = "com.apress.prospring5.ch9.services")
    public class Application implements CommandLineRunner {

        private static Logger logger = LoggerFactory.getLogger(Application.class);

        public static void main(String... args) throws Exception {
           ConfigurableApplicationContext ctx =
                SpringApplication.run(Application.class, args);

           System.in.read();
           ctx.close();
        }

        @Autowired SingerService singerService;

        @Override public void run(String...  args) throws Exception {
           Singer singer = new Singer();
           singer.setFirstName("John");
           singer.setLastName("Mayer");
           singer.setBirthDate(new  Date(
                 (new GregorianCalendar(1977, 9, 16)).getTime().getTime()));
           singerService.save(singer);

           long count = singerService.count();
           if (count == 1) {
              logger.info("--> Singer saved successfully");
           }  else {
              logger.error("--> Singer was not saved, check the configuration!!");
           }

           try {
              singerService.save(null);
           } catch (Exception ex) {
              logger.error(ex.getMessage() + "Final count:" + singerService.count());
           }
        }
    }

    ```

如果您运行`Application`，您将看到类似如下的输出:

```
...
INFO  c.a.j.AtomikosConnectionFactoryBean - AtomikosConnectionFactoryBean
    'jmsConnectionFactory': init...
INFO  o.s.t.j.JtaTransactionManager - Using JTA  UserTransaction:
   com.atomikos.icatch.jta.UserTransactionManager@408a247c
INFO  c.a.j.AtomikosJmsXaSessionProxy - atomikos xa session proxy for resource
    jmsConnectionFactory: calling createQueue on JMS driver session...
INFO  c.a.j.AtomikosJmsXaSessionProxy - atomikos xa session proxy for resource
    jmsConnectionFactory: calling getTransacted on JMS driver session...
DEBUG o.s.t.j.JtaTransactionManager - Participating in existing transaction
DEBUG o.s.t.j.JtaTransactionManager - Initiating transaction commit
INFO  c.a.d.x.XAResourceTransaction - XAResource.start ...
INFO  c.a.d.x.XAResourceTransaction - XAResource.end ...
DEBUG o.s.t.j.JtaTransactionManager - Initiating transaction commit
DEBUG o.s.t.j.JtaTransactionManager - Creating new transaction with name
   [com.apress.prospring5.ch9.services.SingerServiceImpl.save]:
    PROPAGATION_REQUIRED,ISOLATION_DEFAULT; ''
INFO  c.a.i.i.BaseTransactionManager - createCompositeTransaction ( 10000 ):
   created new ROOT transaction with id 127.0.0.1.tm0000200001
DEBUG o.s.t.j.JtaTransactionManager - Participating in existing transaction
INFO  c.a.p.c.Application - --> Singer saved successfully
...//etc

```

从日志中，您可以清楚地看到为每个操作创建和重用的全局事务。如果您通过按任意键正常退出应用程序，然后回车，请耐心等待，因为应用程序需要一段时间才能正常关闭。

以下是关于使用 Spring Boot 创建 JTA 应用程序的一些结论:虽然看起来很容易，但是当处理多个数据源时，配置环境是您无法回避的事情。此外，如果 JTA 提供者是由 JEE 服务器提供的，事情会变得相当复杂。但是对于用于教育目的和测试的示例应用程序，它非常实用。

### 关于使用 JTA 事务管理器的思考

是否使用 JTA 进行全球交易管理正在激烈辩论中。例如，Spring 开发团队通常不推荐使用 JTA 进行全局事务。

作为一般原则，当您的应用程序被部署到一个成熟的 JEE 应用服务器时，不使用 JTA 是没有意义的，因为流行的 JEE 应用服务器的所有供应商都已经为他们的平台优化了他们的 JTA 实现。这是你花钱购买的一个主要功能。

对于独立或 web 容器部署，让应用程序需求驱动您的决策。尽可能早地执行负载测试，以验证使用 JTA 不会影响性能。

一个好消息是，Spring 可以与大多数主流 web 和 JEE 容器中的本地和全局事务无缝协作，所以当您从一种事务管理策略切换到另一种时，通常不需要修改代码。如果您决定在应用程序中使用 JTA，请确保使用 Spring 的`JtaTransactionManager`。

## 摘要

在几乎任何类型的应用程序中，事务管理都是确保数据完整性的关键部分。在这一章中，我们讨论了如何使用 Spring 来管理事务，而几乎不影响您的源代码。您还学习了如何使用本地和全局事务。

我们提供了各种事务实现的例子，包括使用 XML 配置和注释的声明性方法，以及编程方法。

本地事务在 JEE 应用服务器内部/外部都得到支持，只需要简单的配置就可以在 Spring 中启用本地事务支持。然而，设置一个全局事务环境需要做更多的工作，并且很大程度上取决于您的应用程序需要与哪个 JTA 提供者和相应的后端资源进行交互。

Footnotes [1](#Fn1_source)

JDO 的支持在春天 5 月被放弃；因此，`JdoTransactionManager`从类图中消失了。

  [2](#Fn2_source)

Spring 5 只能和 Hibernate 5 一起用；Hibernate 3 和 Hibernate 4 的实现已经删除。

  [3](#Fn3_source)

对 JMS 1.1 的支持在 Spring 5 中被删除。

  [4](#Fn4_source)

这个配置是在 Atomikos 官方文档的帮助下创建的，用于在 [`https://www.atomikos.com/Documentation/SpringIntegration`](https://www.atomikos.com/Documentation/SpringIntegration) 和 [`https://stackoverflow.com/questions/33127854/hibernate-5-with-spring-jta`](https://stackoverflow.com/questions/33127854/hibernate-5-with-spring-jta) 的堆栈溢出社区的帮助下与 Spring 集成。

  [5](#Fn5_source)

该配置是 XML 配置的注释配置改编，在 [`https://www.atomikos.com/Documentation/SpringIntegration#The_Advanced_Case_40As_of_3.3_41`](https://www.atomikos.com/Documentation/SpringIntegration#The_Advanced_Case_40As_of_3.3_41) 的 Atomikos 文档中作为示例给出。