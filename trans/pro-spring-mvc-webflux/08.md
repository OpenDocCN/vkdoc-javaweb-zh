# 8.解析和实现视图

到目前为止，我们主要使用 JavaServer Pages (JSP)和 HTML 模板作为我们的视图技术；然而，Spring MVC 提供了一个非常强大和灵活的机制来解析和实现视图。你已经在第 4 章中简单的看了一下视图解析机制。本章着眼于不同的`ViewResolver`实现，并展示如何创建和使用我们自己的实现。您可以看到 Spring MVC 开箱即用地支持哪些视图技术。我们创建了一些定制的实现。然而，在我们深入内部之前，让我们回顾一下视图呈现过程和 API。

## 视图解析器和视图

第 4 章讨论了 dispatcher servlet 的请求处理工作流。解析和呈现视图是该过程的一部分。图 [8-1](#Fig1) 显示了视图渲染过程(参见 [4](04.html) 章节中的“渲染视图”部分)。

![../images/300017_2_En_8_Chapter/300017_2_En_8_Fig1_HTML.jpg](../images/300017_2_En_8_Chapter/300017_2_En_8_Fig1_HTML.jpg)

图 8-1

查看渲染过程

控制器可以返回一个`org.springframework.web.servlet.View`实现或者一个视图的引用(视图名)。在后一种情况下，会参考已配置的 ViewResolvers 来将引用转换为具体的实现。当实现可用时，它被指示呈现；否则，抛出`javax.servlet.ServletException`。

`ViewResolver`(见清单 [8-1](#PC1) )只有一个方法来解析视图。

```java
package org.springframework.web.servlet;

import java.util.Locale;

public interface ViewResolver {
    View resolveViewName(String viewName, Locale locale) throws Exception;
}

Listing 8-1ViewResolver API

```

当一个视图被选中时，dispatcher servlet 调用视图实例上的 render 方法(参见清单 [8-2](#PC2) )。在`View`实例上调用`getContentType()`方法来确定内容的类型。该值设置响应的内容类型；它还被`org.springframework.web.servlet.view.ContentNegotiatingViewResolver`用来确定最佳匹配视图(更多信息见下一节)。

```java
package org.springframework.web.servlet;

import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public interface View {

    String getContentType();

    void render(Map<String, ?> model,
        HttpServletRequest request,
        HttpServletResponse response) throws Exception;
}

Listing 8-2View API

```

## 查看解析器

第 4 章展示了不同 ViewResolver 实现的层次结构。让我们仔细看看通用的可用实现，它们是如何工作的，以及它们是如何配置的。图 [8-2](#Fig2) 再次显示了不同的实现。特定于特定视图技术的实现将在本章后面的“视图技术”一节中解释。

![../images/300017_2_En_8_Chapter/300017_2_En_8_Fig2_HTML.jpg](../images/300017_2_En_8_Chapter/300017_2_En_8_Fig2_HTML.jpg)

图 8-2

视图解析器层次结构

### BeanNameViewResolver

默认情况下，`org.springframework.web.servlet.view.` `BeanNameViewResolver`实现是最基本的可用和配置。它获取视图的名称，并在`org.springframework.context.ApplicationContext`中查看是否有同名的视图。如果有，解析器返回它；否则，它返回 null。这个视图解析器在小型应用程序中很有用；然而，它有一个很大的缺点:每个视图都需要在应用程序上下文中使用 bean 进行配置。它有一个可以配置的属性，这就是它被调用的顺序(见表 [8-1](#Tab1) )。

表 8-1

`BeanNameViewResolver`属性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

财产

 | 

目的

 |
| --- | --- |
| `Order` | 此视图解析程序在链中的调用顺序。数字越大，在链中的顺序越低。 |

清单 [8-3](#PC3) 显示了视图解析器如何服务和解析索引页面的配置。我们还需要添加一个`View`实例，因为我们使用了一个支持 JSTL 的 JSP，所以我们返回了`org.springframework.web.servlet.view.JstlView`。

```java
package com.apress.prospringmvc.bookstore.web.config;

import org.springframework.web.servlet.view.BeanNameViewResolver;
import org.springframework.web.servlet.view.JstlView;
// Other imports omitted

@Configuration
public class ViewConfiguration {

    @Bean
    public ViewResolver viewResolver() {
        BeanNameViewResolver viewResolver = new BeanNameViewResolver();
        viewResolver.setOrder(1);
        return viewResolver;
    }

    @Bean
    public View index() {
        JstlView view = new JstlView();
        view.setUrl("/WEB-INF/views/index.jsp");
        return view;
    }
}

Listing 8-3BeanNameViewResolver Configuration

```

### UrlBasedViewResolver

`org.springframework.web.servlet.view.` `UrlBasedViewResolver`期望视图名称直接映射到 URL。它可以通过向视图名称添加前缀和/或后缀来选择性地修改 URL。一般来说，这个类是不同视图技术的基类，比如 JSP 和基于模板的视图技术(参见本章后面的“视图技术”一节)。表 [8-2](#Tab2) 描述了这种视图解析器的属性。

表 8-2

`UrlBasedViewResolver`属性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

财产

 | 

目的

 |
| --- | --- |
| `staticAttributes` | 此视图解析程序解析的每个视图中包含的属性。属性及其值通过方法`setAttributes(Properties)`和`setAttributeMap(Map<String,?>)`作为`Properties`或`Map<String,?>`实例提供。 |
| `cacheUnresolved` | 是否应该缓存未解析的视图？也就是说，如果一个视图已经解析为 null，是否应该将它放入缓存中？默认值为 true。(继承自`AbstractCachingViewResolver`。) |
| `contentType` | 设置内容类型 <sup>[1](#Fn1)</sup> (text/HTML，application/JSON 等。)对于由该视图解析器解析的所有视图，除了那些自己确定或返回内容类型并忽略该属性的视图实现(如 JSP)。 |
| `exposePathVariables` | 路径变量(见第 [5](05.html) 章)是否应该添加到模型中？一般来说，视图自己决定；设置此属性可以重写该行为。 |
| `Order` | 此视图解析程序在链中的调用顺序。数字越大，在链中的顺序越低。 |
| `Prefix` | 添加到视图名称以生成 URL 的前缀。 |
| `redirectContextRelative` | 以/开头的重定向 URL 是否应该被解释为相对于 servlet 上下文？默认值为 true。当此属性设置为 false 时，URL 相对于当前 URL 进行解析。 |
| `redirectHttp10Compatible` | 重定向应该与 HTTP 1.0 兼容吗？当为真时，HTTP 状态代码 302 发出重定向；否则，一个 HTTP 状态代码 303 将被重定向。默认值为`true`。 |
| `requestContextAttribute` | 为所有视图设置`org.springframework.web.servlet.support.RequestContext`属性的名称。默认值为 null，这意味着您没有公开 RequestContext。当使用 useBean 等标准 JSP 标签或 Velocity 等无法访问请求的技术时，公开一个`RequestContext`会很有用。`RequestContext`是特定请求状态的上下文持有者。 |
| `Suffix` | 添加到视图名称以生成 URL 的后缀。 |
| `viewClass` | 要创建的视图的类型；这需要是`org.springframework.web.servlet.view.AbstractUrlBasedView`的子类。该属性是必需的。 |
| `viewNames` | 此视图解析程序可以处理的视图的名称。名称可以包含用于匹配名称的通配符`*`。默认值为 null，表示解析所有视图。 |

清单 [8-4](#PC4) 是这个视图解析器的示例配置。我们需要指定视图类(必需的)。通常，还需要添加前缀和/或后缀来生成指向实际视图实现的 URL。使用`UrlBasedViewResolver`的优点是，在我们的配置中，我们不需要为每个`View`实例准备一个 bean。我们依靠`UrlBasedViewResolver`使用配置的属性和一个符号视图名来创建一个`View`。

```java
package com.apress.prospringmvc.bookstore.web.config;

// Other imports omitted

import org.springframework.web.servlet.view.JstlView;
import org.springframework.web.servlet.view.UrlBasedViewResolver;

@Configuration
public class ViewConfiguration {

    @Bean
    public ViewResolver viewResolver() {
        UrlBasedViewResolver viewResolver = new UrlBasedViewResolver();
        viewResolver.setOrder(1);
        viewResolver.setPrefix("/WEB-INF/views/");
        viewResolver.setSuffix(".jsp");
        viewResolver.setViewClass(JstlView.class);
        return viewResolver;
    }
}

Listing 8-4UrlBasedViewResolver Configuration

```

### InternalResourceViewResolver

这个对`UrlBasedViewResolver`的扩展是一个方便的子类，它将视图类预配置为`org.springframework.web.servlet.view.InternalResourceView`及其子类。清单 [8-5](#PC5) 显示了`org.springframework.web.servlet.view.`T3 的示例配置。结果基本上与清单 [8-4](#PC4) 中的相同。

```java
package com.apress.prospringmvc.bookstore.web.config;

// Other imports omitted*
import org.springframework.web.servlet.view.InternalResourceViewResolver;

@Configuration
public class ViewConfiguration {

    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver viewResolver;
        viewResolver = new InternalResourceViewResolver();
        viewResolver.setOrder(1);
        viewResolver.setPrefix("/WEB-INF/views/");
        viewResolver.setSuffix(".jsp");
        return viewResolver;
    }
}

Listing 8-5InternalResourceViewResolver configuration

```

### XsltViewResolver

`org.springframework.web.servlet.web.view.xslt.` `XsltViewResolver`可以将视图名称解析为 XSLT 样式表，从而将模型转换为向用户显示的内容。为了使用这个视图解析器和视图，我们需要一个 XSLT 模板来将模型转换成视图。返回的视图中，`org.springframework.web.servlet.view.xslt.XsltView`的一个实例检测要渲染哪个模型对象。它支持以下类型。

*   `javax.xml.transform.Source`

*   `org.w3c.dom.Document`

*   `org.w3c.dom.Node`

*   `java.io.Reader`

*   `java.io.InputStream`

*   `org.springframework.core.io.Resource`

`XsltView`接受支持的类型并使用 XSLT 样式表转换它。尽管这种机制可能很强大，但我们认为这不是为 web 应用程序创建视图层的东西。一般来说，从控制器返回 XML(或 JSON)并在客户端用 JavaScript 直接处理更容易。

### ContentNegotiatingViewResolver

`org.springframework.web.servlet.view.` `ContentNegotiatingViewResolver`是一个非常特殊的视图解析器；它可以通过名称和内容类型来解析视图。它首先确定所请求的内容类型。有三种方法可以做到。

表 8-3

ContentNegotiatingViewResolver 属性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

财产

 | 

目的

 |
| --- | --- |
| `contentNegotiationManager` | bean 确定请求的媒体类型。 |
| `cnmFactoryBean` | `ContentNegotiationManagerFactoryBean` bean 创建一个`ContentNegotiationManager`实例。 |
| `defaultViews` | 设置要参考的默认视图。当找不到特定视图时使用。在使用封送视图或返回 JSON 时非常有用。 |
| `useNotAcceptableStatusCode` | 当找不到合适的视图时，我们是否应该向客户端发送 HTTP 响应代码 406？默认值为 false。 |
| `viewResolvers` | 要咨询的视图解析器列表。默认情况下，它检测应用程序上下文中的所有视图解析器。 |
| `Order` | 此视图解析程序在链中的调用顺序。数字越大，在链中的顺序越低。 |

*   检查文件扩展名。

*   检查`Accept`割台。

*   默认勾选一个名为`format`的请求参数(参数名称可配置；参见表 [8-3](#Tab3) 。

在确定了内容类型之后，解析器会咨询所有已配置的视图解析器，以便按名称收集候选视图。最后，它通过检查是否支持所请求的内容类型来选择最佳匹配的视图。表 [8-3](#Tab3) 显示了视图解析器的可配置属性。

![../images/300017_2_En_8_Chapter/300017_2_En_8_Figa_HTML.jpg](../images/300017_2_En_8_Chapter/300017_2_En_8_Figa_HTML.jpg)当使用多个视图解析器时，`ContentNegotiatingViewResolver`必须具有最高的顺序才能正常工作。默认情况下已经设置好了，但是如果你改变了顺序，请记住这一点。

### 实现自己的 ViewResolver

本节解释了如何实现我们自己的视图解析器。我们创建了一个简单的实现，它从配置视图的映射中解析视图名。

实现自己的观点很容易做到；你创建一个类，让它实现`ViewResolver`接口(参见清单 [8-1](#PC1) ，并提供必要的实现。清单 [8-6](#PC6) 显示我们的`com.apress.prospringmvc.bookstore.web.view.SimpleConfigurableViewResolver`。

```java
package com.apress.prospringmvc.bookstore.web.view;

// Other imports omitted*
import org.springframework.web.servlet.View;
import org.springframework.web.servlet.ViewResolver;

public class SimpleConfigurableViewResolver implements ViewResolver {
    private Map<String, ? extends View> views = new HashMap<>();

    @Override
    public View resolveViewName(String viewName, Locale locale) {
        return this.views.get(viewName);
    }

    public void setViews(Map<String, ? extends View> views) {
        this.views = views;
    }
}

Listing 8-6SimpleConfigurableViewResolver

```

我们将在下一节中使用这个实现来添加 PDF 和 Excel 的视图。

## 查看技术

Spring MVC 支持许多不同的技术，如果没有支持，您可以通过实现`org.springframework.web.servlet.View`或扩展所提供的视图类来添加它。本节讨论几种视图技术，并展示 Spring MVC 如何支持它们。对一些人来说，有广泛的支持；对其他人来说，很少。图 [8-3](#Fig3) 显示了视图类的层次结构，在这里你可以看到一些支持的视图技术。对于某些技术，我们需要指定一个特定的`ViewResolver`来工作；其他的与配置的视图解析器一起工作。

![../images/300017_2_En_8_Chapter/300017_2_En_8_Fig3_HTML.jpg](../images/300017_2_En_8_Chapter/300017_2_En_8_Fig3_HTML.jpg)

图 8-3

视图层次结构

本节的下一部分将简要介绍一些受支持的视图技术。它展示了支持类以及如何设置 Spring 来使用指定的技术。它没有深入介绍所有不同的受支持视图技术；这里提到的大部分技术都有其他的书籍。

![../images/300017_2_En_8_Chapter/300017_2_En_8_Figb_HTML.jpg](../images/300017_2_En_8_Chapter/300017_2_En_8_Figb_HTML.jpg)`TilesViewResolver`在本节的大多数清单中有 2 阶，以确保它在正确的时刻执行，特别是当使用`ContentNegotiatingViewResolver`时，它应该在`TilesViewResolver`之前执行(这是默认的)。

### JavaServer 页面

到目前为止，我们的应用程序一直使用 JavaServer Pages。Spring 对它有很好的支持，包括它自己的标签库(见章节 [5](05.html) 和 [6](06.html) )。Spring 有支持和集成类，一般来说，它是与`org.springframework.web.servlet.view.InternalResourceViewResolver`一起使用的工具，以启用 JSTL 支持并与 Sun 的默认格式和函数库集成。

### 瓷砖

Apache Tiles <sup>该项目现已退休，Spring 框架团队非常喜欢百里叶 <sup>[3](#Fn3)</sup> 和小胡子、 <sup>[4](#Fn4)</sup> 但 Tiles 在很长一段时间内都是 Spring 的最爱，仍然值得关注。这些页面组件可以在不同的页面布局中重用和配置。最初它被设计成一个 JSP 组合框架；但是，它也可以构成基于 FreeMarker 的视图。</sup>

#### 配置图块

要开始使用 Tiles，我们必须为它配置和引导引擎。接下来，我们需要配置视图解析器来返回基于 tiles 的视图，最后，我们需要指定页面组成并添加不同的模板(Tiles)。

我们需要将`org.springframework.web.servlet.view.tiles3.TilesConfigurer`添加到我们的配置中。接下来，我们需要特殊的 org . spring framework . web . servlet . view . tiles 3 . tilesviewrolver。清单 [8-7](#PC7) 显示了图块的最基本配置。

```java
package com.apress.prospringmvc.bookstore.web.config;

*// Other imports omitted*

import org.springframework.web.servlet.view.tiles3.TilesConfigurer;
import org.springframework.web.servlet.view.tiles3.TilesViewResolver;

@Configuration
public class ViewConfiguration {

    @Bean
    public TilesConfigurer tilesConfigurer() {
        return new TilesConfigurer();
    }

    @Bean
    public TilesViewResolver tilesViewResolver() {
        TilesViewResolver tilesViewResolver = new TilesViewResolver();
        tilesViewResolver.setOrder(2);
        return tilesViewResolver;
    }
}

Listing 8-7ViewConfiguration for Tiles

```

默认情况下，`TilesConfigurer`从`WEB-INF`目录加载一个名为`tiles.xml`的文件；该文件包含页面定义。在我们查看定义文件之前，让我们看看表 [8-4](#Tab4) 中的配置器的属性。

表 8-4

`TilesConfigurer`属性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

财产

 | 

目的

 |
| --- | --- |
| `checkRefresh` | 我们应该检查图块定义的变化吗？默认为`false`；将其设置为 true 会影响性能，但在开发过程中会很有用。 |
| `completeAutoload` | 当设置为 true(默认为`false`)时，图块的初始化完全由图块本身完成。它使这个配置器类的其他属性变得无用。 |
| `definitions` | 包含定义的文件列表。默认是指`/WEB-INF/tiles.xml`。 |
| `definitionsFactoryClass` | 设置用于创建图块定义的`org.apache.tiles.definition.DefinitionsFactory`实现。默认情况下使用`org.apache.tiles.definition.UrlDefinitionsFactory`类。 |
| `preparerFactoryClass` | 设置要使用的`org.apache.tiles.preparer.PreparerFactory`实现。默认情况下使用`org.apache.tiles.preparer.BasicPreparerFactory`类。 |
| `tilesInitializer` | 设置自定义初始值设定项来初始化图块。当设置自定义实现时，初始化器应该完全初始化 Tiles，因为设置这个属性会使这个类上的其他属性变得无用。 |
| `useMutableTilesContainer` | 我们应该使用可变瓷砖容器吗？默认为`false`。 |
| `validateDefinitions` | 指定我们是否应该验证定义 XML 文件。默认为`true`。 |

TilesViewResolver 没有要设置的附加属性；它与 UrlBasedViewResolver 具有相同的属性集。它是一个方便的子类，可以自动配置要返回的正确视图类型。对于图块，我们需要创建`org.springframework.web.servlet.view.tiles3.TilesView`的实例。

#### 配置和创建模板

平铺需要一个或多个文件来定义我们的页面；这些被称为**定义文件**。TilesConfigurer 加载的默认文件是`/WEB-INF/tiles.xml`(参见清单 [8-8](#PC8) )。

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE tiles-definitions PUBLIC
    "-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN"
    "http://tiles.apache.org/dtds/tiles-config_3_0.dtd">

<tiles-definitions>
    <!-- definition 1 -->
    <definition name="template" template="/WEB-INF/templates/template.jsp">
        <put-attribute name="header" value="/WEB-INF/templates/header.jsp"/>
        <put-attribute name="footer" value="/WEB-INF/templates/footer.jsp"/>
    </definition>

    <!-- definition 2 -->
    <definition name="*" extends="template">
        <put-attribute name="title" value="{1}.title" />
        <put-attribute name="body" value="/WEB-INF/views/{1}.jsp" />
    </definition>

    <!-- definition 3 -->
    <definition name="*/*" extends="template">
        <put-attribute name="title" value="{1}.{2}/title" />
        <put-attribute name="body" value="/WEB-INF/views/{1}/{2}.jsp" />
    </definition>

</tiles-definitions>

Listing 8-8Tiles Definitions

```

我们创造了三个定义。

1.  名为 template 的定义是总体布局配置。

2.  其他定义扩展了这种常规布局(并且可以覆盖预定义的属性)。通过在定义名称中使用通配符(`*`)来声明多个定义。`{1}`占位符指的是星星的值。

3.  更多的定义扩展了这种常规布局，但是位于更深层次的目录中。位置层级由`/`表示。占位符`{1}`表示第一颗星的值，`{2}`表示第二颗星的值。 <sup>[5](#Fn5)</sup>

为了让 Spring 选择正确的定义，我们的定义名称必须与视图匹配(或者像我们在示例中那样使用*通配符)。我们的模板页面(`template.jsp`)由三个瓦片(`header`、`footer`和`body`)组成，我们需要一个包含消息键的属性标题，这样我们就可以使用我们的消息源(参见章节 [5](05.html) 国际化的讨论)来解析实际的标题。清单 [8-9](#PC9) 显示的是`template.jsp`，为总图。

```java
<!DOCTYPE HTML>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<%@ tagib prefix="spring" uri="http://www.springframework.org/tags" %>
<%@ taglib prefix="tiles" uri="http://tiles.apache.org/tags-tiles" %>

<html>
  <head>
      <meta charset="utf-8">
      <c:set var="titleKey">
        <tiles:getAsString name="title" />
      </c:set>
      <title>
        Bookstore | <spring:message code="${titleKey}"
          text="Your Home in Books"/>
      </title>
      <link rel="stylesheet" type="text/css"
          href="<c:url value="/resources/css/style.css"/>" >
  </head>

  <body>
      <div id="wrap">
        <tiles:insertAttribute name="header"/>
        <div class="center_content">
          <div class="left_content">
              <h1>
                <spring:message code="${titleKey}"
                   text="${titleKey}"/>
              </h1>
              <tiles:insertAttribute name="body" />
          </div><!--end of left content-->
        <div class="right_content">
        <div class="right_box">
          <div class="title">
              <span class="title_icon">
                <img
                   src="<c:url value="/resources/images/bullet4.gif"/>"
                   alt="" title="" />
                </span>
                <spring:message code="main.title.randombooks"/>
          </div>
          <c:forEach items="${randomBooks}" var="book">
              <div class="new_prod_box">
                <c:url value="/book/${book.id}" var="bookUrl" />
                <a href="${bookUrl}">${book.title}</a>
                <div class="new_prod_img">
                  <c:url
                    value="/book/${book.isbn}/image" var="bookImage"/>
                  <a href="${bookUrl}">
                      <img src="${bookImage}" alt="${book.title}"
                        title="${book.title}" class="thumb"
                        border="0" width="100px"/>
                  </a>
                </div>
              </div>
          </c:forEach>
        </div><!--end of right box-->
        </div><!--end of right content-->
        <div class="clear"></div>
        </div><!--end of center content-->

      <tiles:insertAttribute name="footer" />
      </div>
  </body>
</html>

Listing 8-9template.jsp content

```

突出显示的代码根据来自我们的`tiles.xml`的`title`属性的内容设置了一个变量。这样，我们可以在 tiles 配置上指定一个键，并使用 Spring 消息标记来检索国际化值。清单 [8-10](#PC10) 显示了我们的`index.jsp`，它被用作欢迎页面的主体。

```java
<p>Welcome to the Book Store</p>

Listing 8-10index.jsp Used as Content

```

图 [8-4](#Fig4) 显示了结果页面。

![../images/300017_2_En_8_Chapter/300017_2_En_8_Fig4_HTML.jpg](../images/300017_2_En_8_Chapter/300017_2_En_8_Fig4_HTML.jpg)

图 8-4

结果欢迎页面

### FreeMarker 和百里香叶

FreeMarker <sup>[6](#Fn6)</sup> 和百里香叶都是用 Java 编写的模板框架。您可以使用它们来创建 HTML 页面的模板。它们是基于文本的模板引擎，两者都广泛用于各种模板解决方案的应用程序中。

Spring 使用的另一个 HTML 模板框架叫做 Velocity，但是它不再被支持了。Velocity 包在 Spring 4.3 中被弃用，并在 5.0.1 <sup>[7](#Fn7)</sup> 中被完全移除，以支持 FreeMarker。速度是相当古老的；最新版本发布于 2010 年。

FreeMarker 和 Thymeleaf 模板不像 JSP 那样编译成 Java 代码。它们在运行时由它们的模板引擎解释，这很像我们前面讨论的 XSLT 处理。您可能认为这种解释(而不是编译)会导致应用程序的性能下降，但这通常不是真的。两个引擎都有大量的解释模板缓存，这使得它们很快。

与 JSP 相比，使用模板方法的另一个优点是，在后一种情况下，您可能会倾向于将 Java 代码放在 JSP 中。将 Java 代码放在页面中，尽管是可能的，但不是您应该采用的方法。这通常会导致页面难以维护、调试和修改。

当使用 FreeMarker 和 Thymeleaf 模板时，需要额外的配置来设置正确的模板引擎和视图解析器。首先，我们需要配置我们选择的模板引擎。然后，我们需要为模板引擎配置视图解析。

#### 配置模板引擎

Spring 框架广泛支持 FreeMarker 和 Thymeleaf，并且有一些助手类可以使引擎的配置更加容易。FreeMarker 有`org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer`(见表 [8-5](#Tab5) )。

表 8-5

`FreeMarkerConfigurer`属性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

财产

 | 

目的

 |
| --- | --- |
| `configLocation` | 包含 FreeMarker 引擎设置的配置文件的位置。 |
| `defaultEncoding` | 设置 FreeMarker 配置文件的编码。默认情况下使用平台编码。 |
| `freemarkerSettings` | 直接设置模板引擎的属性。它可以覆盖配置文件中的属性，或者完全配置模板引擎。 |
| `freemarkerVariables` | 设置已知 FreeMarker 对象的贴图。这些对象作为变量传递给 FreeMarker 配置。 |
| `postTemplateLoaders` | 指定 freemarker . cache . template loader 来加载模板。它们是在默认模板加载器之后注册的。 |
| `preferFileSystemAccess` | 我们应该选择文件系统访问来加载 FreeMarker 模板吗？默认值为 true 如果您的模板不在文件系统上，例如，在 jar 文件的类路径上，则将此设置为 false。 |
| `preTemplateLoaders` | 指定 freemarker . cache . template loader 来加载模板。它们在默认模板加载器之前注册。 |
| `templateLoaderPathtemplateLoaderPaths` | 设置 FreeMarker 模板的路径。`templateLoaderPaths`的值可以是逗号分隔的路径列表。它可以混合不同的资源路径(参见第 [2](02.html) 章中的“资源加载”)。 |

该表中最重要的属性是设置加载模板的位置的属性:`templateLoaderPath`。最佳实践是让 web 客户端无法访问它们，这可以通过将它们放在`WEB-INF`目录中来实现。

![../images/300017_2_En_8_Chapter/300017_2_En_8_Figd_HTML.jpg](../images/300017_2_En_8_Chapter/300017_2_En_8_Figd_HTML.jpg)还有`org.springframework.beans.factory.FactoryBean`来配置 FreeMarker 模板引擎，引导引擎使用非 web 模板，如电子邮件。

百里香发动机通过`org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver`和`org.thymeleaf.spring5.SpringTemplateEngine`两种类型与弹簧框架轻松集成(见表 [8-6](#Tab6) )。需要一个`SpringResourceTemplateResolver` bean 来支持百里香模板资源。

表 8-6

百里香叶的特性`SpringResourceTemplateResolver`

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

财产

 | 

目的

 |
| --- | --- |
| `applicationContext` | 这个属性需要被设置为 Spring `ApplicationContext`实例，这样它就可以访问模板资源。 |
| `prefix` | 添加到所有模板名称的前缀，用于将*模板名称*转换为*资源名称*。 |
| `suffix` | 添加到所有模板名称的后缀，用于将*模板名称*转换为*资源名称*。 |
| `forceSuffix` | 模板上应该强制使用后缀吗？如果设置为`true`，无论模板名称的扩展名如何，都将应用配置的后缀。默认为`false`。 |
| `templateMode` | 应用于百里香解析器解析的模板的模板模式。默认为 HTML。 |
| `forceTemplateMode` | 是否应该在模板资源上强制使用模板模式？如果设置为`true`，则解析不在模板资源名称上，而是在配置的`suffix`上。默认是`false`。 |
| `characterEncoding` | 读取资源的字符编码。 |
| `cacheable` | 百里香解析器解析的模板应该缓存吗？默认值是`true`，但是在开发过程中，我们建议您将该属性设置为`false`。 |
| `order` | 此视图解析程序在链中的调用顺序。数字越大，在链中的顺序越低。默认值为 1。 |

上表中最重要的属性是定义模板资源位置的属性(`suffix`和`prefix`)，以及必须访问它们的`applicationContext`。最佳实践是让 web 客户端无法访问它们，这可以通过将它们放在`WEB-INF`目录中来实现。

![../images/300017_2_En_8_Chapter/300017_2_En_8_Fige_HTML.jpg](../images/300017_2_En_8_Chapter/300017_2_En_8_Fige_HTML.jpg)还有另一个特定于 Spring 的实现，由实现`ServletContextAware`的`org.thymeleaf.templateresolver.ServletContextTemplateResolver`类提供，并且依赖于 servlet 上下文。这个实现使用 Servlet 资源解析机制来解析模板，而`SpringResourceTemplateResolver`使用 Spring 的资源解析机制来解析模板。这些类大多是可互换的，但是推荐使用`SpringResourceTemplateResolver`,因为它可以自动与 Spring 的资源解析基础设施集成。

除了设置不同的引擎，我们还需要配置一个视图解析器来解析正确的视图实现。春运用`org.springframework.web.servlet.view.freemarker.FreemarkerViewResolver`。百里香框架为同样的目的提供了`org.thymeleaf.spring5.view.ThymeleafViewResolver`。不要求使用这些专门的视图解析器；配置广泛的`InternalResourceViewResolver`也可以。然而，使用这些专门的视图解析器使我们的生活变得更容易。清单 [8-11](#PC11) 显示了一个 FreeMarker 配置示例。

```java
package com.apress.prospringmvc.bookstore.web.config;

// Other imports omitted
import org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer;
import org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver;

@Configuration
public class ViewConfiguration {

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer freeMarkerConfigurer;
        freeMarkerConfigurer = new FreeMarkerConfigurer();
        freeMarkerConfigurer.setTemplateLoaderPath("WEB-INF/freemarker");
        return freeMarkerConfigurer;
    }

    @Bean
    public ViewResolver freeMarkerViewResolver() {
        FreeMarkerViewResolver viewResolver = new FreeMarkerViewResolver();
        viewResolver.setSuffix(".ftl");
        return viewResolver;
    }
}

Listing 8-11FreeMarker Configuration

```

当控制器现在返回`index`作为视图名称时，对于 FreeMarker 模板，它变成了`WEB-INF/freemarker/index.ftl`。视图名称前有`templateLoaderPath`。视图解析器还允许设置额外的前缀(从`AbstractTemplateViewResolver`继承而来)。表 [8-7](#Tab7) 描述了视图解析器的不同属性。

表 8-7

FreeMarker 视图解析器的其他属性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

财产

 | 

目的

 |
| --- | --- |
| `allowRequestOverride` | 当我们合并模型时，请求属性应该覆盖模型属性吗？当设置为 true 时，当以相同的名称存储时，请求属性可以覆盖模型属性。默认值为 false，这将在遇到同名属性时导致异常。 |
| `allowSessionOverride` | 当我们合并模型时，会话属性应该覆盖模型属性吗？设置为 true 时，会话属性可以覆盖以相同名称存储的模型属性。默认值为 false，这将在遇到同名属性时导致异常。 |
| `exposeRequestAttributes` | 所有的请求属性都应该放在模型中吗？默认值为 false。 |
| `exposeSessionAttributes` | 是否应该将所有会话属性都放入模型中？默认值为 false。 |
| `exposeSpringMacroHelpers` | 是否应该暴露宏(见表 [8-8](#Tab8) )以便它们可用于渲染？默认值为 true。 |

清单 [8-12](#PC12) 显示了百里香叶配置样本。

```java
package com.apress.prospringmvc.bookstore.web.config;

// Other imports omitted
import org.thymeleaf.spring5.SpringTemplateEngine;
import org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver;
import org.thymeleaf.spring5.view.ThymeleafViewResolver;

@Configuration
public class ViewConfiguration implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }

    @Bean
    public SpringResourceTemplateResolver templateResolver() {
        var resolver = new SpringResourceTemplateResolver();
        resolver.setApplicationContext(applicationContext);
        resolver.setPrefix("/WEB-INF/thymeleaf/");
        resolver.setSuffix(".html");
        //HTML is the default value, added here for clarity
        resolver.setTemplateMode(TemplateMode.HTML);
        resolver.setCharacterEncoding("UTF-8");
        return resolver;

    }

    @Bean
    @Description("Thymeleaf Template Engine")
    public SpringTemplateEngine templateEngine() {
        var templateEngine = new SpringTemplateEngine();
        templateEngine.setTemplateResolver(templateResolver());
        return templateEngine;
    }

    @Bean
    @Description("Thymeleaf View Resolver")
    public ThymeleafViewResolver viewResolver() {
        var viewResolver = new ThymeleafViewResolver();
        viewResolver.setTemplateEngine(templateEngine());
        return viewResolver;
    }
}

Listing 8-12Thymeleaf Configuration

```

当控制器现在返回`index`作为视图名称时，对于百里香模板，它变成了`WEB-INF/AbstractTemplateViewResolver/index.html`。将`prefix`值添加到视图名称之前，并将`suffix`值添加到视图名称之后。

#### 模板语言

既然我们已经配置了环境，我们还需要编写一个显示页面的模板。FreeMarker 和百里香有点相似。列表 [8-13](#PC13) 和 [8-14](#PC14) 分别显示了 FreeMarker 和百里香的图书搜索页面。

```java
<html xmlns:th="http://www.thymeleaf.org">

  <head th:replace="~{template/layout :: head('Search books')}"></head>
  <body>
    <div id="header" th:replace="~{template/layout :: header}" ></div>
    <h1 id="pagetitle" th:text="#{book.searchcriteria}">SEARCH TITLE</h1>
    <form action="#" th:action="@{/book/search}" th:object="${bookSearchCriteria}" method="GET" id="bookSearchForm">
      <fieldset>
        <legend th:text="#{book.searchcriteria}">SEARCH CRITERIA</legend>
            <table>
                <tr>
                    <td><label for="title" th:text="#{book.title}">TITLE</label></td>
                    <td><input type="text" th:field="*{title}"/></td>
                </tr>
                <tr>
                    <td><label for="category" th:text="#{book.category}">CATEGORY</label></td>
                    <td>
                        <select th:field="*{category}">
                            <option th:each="c : ${categories}" th:value="${c.id}" th:text="${c.name}" th:selected="${i==1}">
                            </option>
                        </select>
                    </td>
                </tr>
            </table>
        </fieldset>
        <button id="search" th:text="#{button.search}">SEARCH</button>
    </form>
 <!-- Javascript functions ommitted -->
   <table id="bookSearchResults" th:if="${bookList ne null and not #lists.isEmpty(bookList)}">
        <thead>
        <tr>
            <th th:text="#{book.title}">TITLE</th>
            <th th:text="#{book.description}">DESCRIPTION</th>
            <th th:text="#{book.price}">PRICE</th>
            <th></th>
        </tr>
        </thead>
        <tbody>
        <th:block th:each="book : ${bookList}">
            <tr>
                <td><a th:href="@{/book/detail/} + ${book.id}" th:text="${book.title}">TITLE</a></td>
                <td th:text="${book.description}">DESC</td>
                <td th:text="${book.price}">PRICE</td>
                <td><a th:href="@{/cart/add/} + ${book.id}" th:text="${book.addtocart}">CART</a></td>
            </tr>
        </th:block>
        </tbody>
    </table>
  </body>
</html>

Listing 8-14books/search.html Thymeleaf Template

```

```java
<#ftl>
<#import "/spring.ftl" as spring />
<!DOCTYPE HTML>
<html>
 <head>
     <title>Booksearch</title>
 </head>
 <body>
     <h1><@spring.message code="book.title" /></h1>
     <p>
      <form method="POST">
      <fieldset>
          <legend><@spring.message code="book.searchcriteria" /></legend>
          <table>
           <tr>
               <td><@spring.message code="book.title" /></td>
               <td><@spring.formInput"searchCriteria.title" /></td>
           </tr>
           <tr>
           <td><@spring.message code="book.category" /></td>
           <td><@spring.formSingleSelect
                "searchCriteria.category", categories, "" /></td>
           </tr>
          </table>
      </fieldset>
      <button id="search"><@spring.message code="book.search" /></button>
      </form>
 <!-- Javascript functions ommitted -->
      <#if bookList?has_content>
      <table>
          <tr>

           <th><@spring.message code="book.title"/></th>
           <th><@spring.message
                     code="book.description"/></th>
           <th><@spring.message code="book.price" /></th>
          </tr>
          <#list bookList as book>
          <tr>
           <td>${book.title}</td>
           <td>${book.description}</td>
           <td>${book.price}</td>
           <td><a
            href="<@spring.url "/cart/add/${book.id}"/>">
                <@spring.message code="book.addtocart"/></a></td>
          </tr>
          </#list>
      </table>
      </#if>
     </p>
 </body>
</html>

Listing 8-13books/search.ftl FreeMarker Template.

```

FreeMarker 模板类似于 Apache 图块模板。FreeMarker(参见清单 [8-13](#PC13) )模板也有可用的标签库(在绑定到 Spring 的清单中)。这两个库为 JSP 提供了与 Spring Form 标记库相同的支持。

百里香叶不同于 FreeMarker。百里叶是一个现代的服务器端 Java 模板引擎，适用于 web 和独立环境。当 Spring 开始远离 Apache Tiles 时，它转向了百里香，因为它的创建者为 Spring 设计了这个模板框架。

Thymeleaf 支持多种模板:HTML、XML、JavaScript、CSS，甚至纯文本，但是最容易设计和使用的是 HTML 模板。百里香模板对于开发流程来说是优雅而自然的，因为它们是用 HTML 编写的，所以可以在设计阶段使用浏览器进行测试。百里香的最大优点是它可以很容易地与 Spring 控制器、本地化和验证集成。

前一个模板包含几个百里香标签，这些标签很自然地适合 HTML 内容。它们以`th:`为前缀，由百里香模板引擎解释生成相应的 HTML 页面。

表 [8-8](#Tab8) 提供了不同 FreeMarker 标签的概述。百里香等效结构只是丰富的 HTML 标签，因此没有必要进行比较。

表 8-8

Tage 可用于 FreeMarker 和百里香等效的 HTML 构造

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

巨

 | 

FreeMarker

 |
| --- | --- |
| **消息**(根据 code 参数从资源包中输出一个字符串) |  |
| **messageText** (根据 code 参数从资源包中输出一个字符串，返回默认参数的值) |  |
| **url** (用应用程序的上下文根作为相对 url 的前缀) |  |
| **formInput** (用于收集用户输入的标准输入字段) |  |
| **formHiddenInput *** (用于提交非用户输入的隐藏输入字段，例如 CSRF 令牌) |  |
| **formPasswordInput** *(收集密码的标准输入字段) |  |
| **formTextarea** (用于收集长的自由格式文本输入的大文本字段) |  |
| **formSingleSelect** (允许选择单个所需值的下拉框) |  |
| **formMultiSelect** (允许用户选择 0 个或多个值的选项列表框) |  |
| **formRadioButtons** (一组单选按钮，允许从可用选项中进行单项选择) |  |
| **表单复选框**(一组允许选择 0 个或多个值的复选框) |  |
| **表单复选框**(单个复选框) |  |
| **显示错误** |  |

列出的任何宏的参数都有一致的含义。

*   **path** :要绑定的字段名称(即`searchCriteria.title`)。

*   **选项**:包含可从输入栏中选择的所有可用值的映射。映射的键表示从表单回发并绑定到命令对象的值。属于键的值被用作向用户显示的标签。通常，这种图由控制器作为参考数据提供。根据所需的行为，可以使用任何 Map 实现。

*   **分隔符**:当多个选项作为离散元素(单选按钮或复选框)可用时，字符序列在列表中分隔每个选项(例如，`<br/>`)。

*   **属性**:包含在 HTML 标签本身中的任意标签或文本的附加字符串。该字符串由宏直接回显。例如，在 textarea 字段中，您可以提供属性作为`rows="5" cols="60"`，或者您可以传递样式信息，如`style="border:1px solid silver"`。

*   **classOrStyle** :对于 showErrors 宏，包装每个错误的 span 标签使用的 CSS 类的名称。如果没有提供任何信息(或者值为空)，错误将被包含在`<b></b>`标签中。

表中标记(*)的两个宏用于 FreeMarker 然而，它们不是必需的，因为您可以使用普通的`formInput`宏指定 hidden 或 password 作为`fieldType`参数的值。

使用 FreeMarker，您可以指定使用哪个库。在 FreeMarker 中，我们需要使用 import 指令来指定库(参见清单 [8-13](#PC13) )。

百里香不使用任何需要在模板中引用的特殊标签库。百里香模板引擎寻找`th:`结构并动态解析它们。最重要的百里香叶构建体用于以下目的。

*   **th:fragment** 声明了一个 HTML 元素，它是布局的一部分，可以被子页面继承或覆盖。片段可以接收一个参数。比如`<head th:fragment="head(title)"/>`。

*   **th:replace** 声明了一个 HTML 元素，它替换了一个从布局继承的元素。如果片段被参数化，则需要一个参数。比如`<head th:replace="~{template/layout :: head('Search')}"/>`。

*   **th:text** (对于带有文本值的 HTML 元素)告诉百里香叶引擎用一个动态获得的值替换这个结构的值。编写 HTML 模板时，HTML 元素的默认值通常用大写字母书写。这有助于在浏览器中打开模板，因为它描绘了正确的视图。当描述默认文本而不是动态解析的文本时，它还有助于发现引擎配置问题。`th:text`结构中的值要么是模型属性`<title th:text="${title}"> TITLE </title>`的值，要么是国际化文本`<title th:text="#{book.title}"> TITLE </title>`的值。

*   **th:href** 为`<a/>`和`<link />` HTML 元素设置带有上下文 URL 的`href`属性。元素`<link rel="stylesheet" type="text/css" th:href="@{/resources/css/style.css}" >`的`href`属性由一个 URL 填充，该 URL 指向应用程序上下文中的`style.css`文件。

*   **th:if** 决定页面上是否应该显示 HTML 元素或文本。例如，我们可以使用类似于`<li th:if="${session.account ne null}"><a th:href="@{/logout}" th:text="#{nav.logout}">LOGOUT</a></li>`的结构，以用户会话中存在一个`account`实例作为注销选项的条件。

百里叶使用 Spring 表达式语言进行表达式求值，并且有这个库的扩展用于 Spring 安全支持。这种与 Spring 框架的强大集成清楚地表明了为什么这个模板框架是 Spring web 应用程序的完美之选。

### 便携文档格式

Spring 可以集成 iText <sup>[8](#Fn8)</sup> 或者 OpenPDF <sup>[9](#Fn9)</sup> 来支持渲染 PDF 视图。Spring 团队推荐 OpenPDF，因为它得到了积极的维护，并修复了不受信任的 PDF 内容的一个重要漏洞。

为了能够呈现 PDF 视图，我们需要编写自己的视图实现，为此，我们需要扩展`org.springframework.web.servlet.view.document.AbstractPdfView`。当我们扩展这个类时，我们必须实现`buildPdfDocument`方法。

我们创建了一个 PDF 文件，在我们的帐户页面上概述了我们的一个订单。清单 [8-15](#PC15) 显示了视图实现。

```java
package com.apress.prospringmvc.bookstore.web.view;

// Other imports omitted
import org.springframework.web.servlet.view.document.AbstractPdfView;
import com.lowagie.text.Document;
import com.lowagie.text.Paragraph;
import com.lowagie.text.Table;
import com.lowagie.text.pdf.PdfWriter;

public class OrderPdfView extends AbstractPdfView {

    @Override
    protected void buildPdfDocument(Map<String, Object> model,
        Document document,
        PdfWriter writer,
        HttpServletRequest request,
        HttpServletResponse response)
    throws Exception {
        Order order = (Order) model.get("order");
        document.addTitle("Order :" + order.getId());
        document.add(new Paragraph("Order date: " + order.getOrderDate()));
        document.add(new Paragraph("Delivery date: " + order.getDeliveryDate()));
        Table orderDetails = new Table(4);
        orderDetails.addCell("Title");
        orderDetails.addCell("Price");
        orderDetails.addCell("#");
        orderDetails.addCell("Total");

        for (OrderDetail detail : order.getOrderDetails()) {
            orderDetails.addCell(detail.getBook().getTitle());
            orderDetails.addCell(detail.getBook().getPrice().toString());
            orderDetails.addCell(String.valueOf(detail.getQuantity()));
            orderDetails.addCell(detail.getPrice().toString());
        }
        document.add(orderDetails);
    }
}

Listing 8-15View Implementation to Create a PDF

```

接下来，我们来补充一下`org.springframework.web.servlet.view`。`ContentNegotiatingViewResolver`对我们的视图进行配置。我们这样做是为了让我们的订单页面呈现为 HTML 或 PDF 格式，我们不想改变`com.apress.prospringmvc.bookstore.web.controller.OrderController`，因为它已经在做我们想要做的事情了——将选中的订单添加到模型中。清单 [8-16](#PC16) 显示了变更后的`com.apress.prospringmvc.bookstore.web.config.ViewConfiguration`。这也是我们开始使用自定义视图解析器的地方。

```java
package com.apress.prospringmvc.bookstore.web.config;

// Other imports omitted

import org.springframework.web.servlet.view.ContentNegotiatingViewResolver;
import org.springframework.web.servlet.view.document.AbstractPdfView;
import com.apress.prospringmvc.bookstore.web.view.OrderPdfView;
import com.apress.prospringmvc.bookstore.web.view.SimpleConfigurableViewResolver;

@Configuration
public class ViewConfiguration {

    @Bean
    public ContentNegotiatingViewResolver contentNegotiatingViewResolver() {
        ContentNegotiatingViewResolver viewResolver;
        viewResolver = new ContentNegotiatingViewResolver();
        List<ViewResolver> viewResolvers = new ArrayList<ViewResolver>();
        viewResolvers.add(pdfViewResolver());
        viewResolver.setViewResolvers(viewResolvers);
        return viewResolver;
    }

    @Bean
    public ViewResolver pdfViewResolver() {
        SimpleConfigurableViewResolver viewResolver;
        viewResolver = new SimpleConfigurableViewResolver();
        Map<String, AbstractPdfView> views;
        views = new HashMap<String, AbstractPdfView>();
        views.put("order", new OrderPdfView());
        viewResolver.setViews(views);
        return viewResolver;
    }

// Other methods omitted
}

Listing 8-16ViewConfiguration with ContentNegotiatingViewResolver

```

更改后的配置包含了我们的视图解析器，我们用它来解析`com.apress.prospringmvc.bookstore.web.view.OrderPdfView`。此配置还允许我们解析 Excel 文档的订单视图(参见“Excel”一节)。

经过这些更改后，我们需要重新部署我们的应用程序。如果我们登录并导航到我们的帐户页面，我们现在可以单击 PDF 链接并获得 PDF 而不是 HTML 版本。图 [8-5](#Fig5) 显示了点击 PDF 链接的结果。

![../images/300017_2_En_8_Chapter/300017_2_En_8_Fig5_HTML.jpg](../images/300017_2_En_8_Chapter/300017_2_En_8_Fig5_HTML.jpg)

图 8-5

生成的 PDF

虽然这种方法非常灵活，但缺点是我们需要为我们想要的每个 PDF 编码 PDF 的构造。如果我们有一些复杂的 PDF 或需要应用某种样式，这是繁琐和难以维护的。在这种情况下，可能值得考虑像 JasperReports 这样的解决方案(参见“JasperReports”一节)。

### 超过

Spring 有两种呈现 Excel 文档的方式。第一种是使用 JExcel 库， <sup>[10](#Fn10)</sup> ，另一种是使用 Apache POI 库。 <sup>[11](#Fn11)</sup> 这两种方法都需要我们实现一个视图(和 PDF 一样)；为此，我们扩展了`org.springframework.web.servlet.view.document.AbstractXlsView`或`org.springframework.web.servlet.view.document.AbstractXlsxView`。它们分别适用于 XLS 和 XLSX 格式。两种实现都隐藏了设置，并允许加载和处理 XLS 模板；我们需要添加特定于视图的渲染。我们需要为此实现 buildExcelDocument 方法。清单 [8-17](#PC17) 显示了一个使用 Apache POI 的 Excel 文档订单的`View`实现示例。

```java
package com.apress.prospringmvc.bookstore.web.view;

// Other imports omitted

import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.springframework.web.servlet.view.document.AbstractXlsView;

public class OrderExcelView extends AbstractXlsView {

    @Override
    protected void buildExcelDocument(Map<String, Object> model,
        WritableWorkbook workbook,
        HttpServletRequest request,
        HttpServletResponse response)
    throws Exception {
        response.setHeader("Content-Disposition",
           "attachment; filename=\"order.xls\"");
        Order order = (Order) model.get("order");
        Sheet sheet = workbook.createSheet();
        sheet.createRow(1).createCell(0)
            .setCellValue("Order: " + order.getId());
        sheet.createRow(2).createCell(0)
            .setCellValue("Order Date: " + order.getOrderDate());
        sheet.createRow(3).createCell(0)
            .setCellValue("Delivery Date: " + order.getDeliveryDate());
        sheet.createRow(4).createCell(0)
            .setCellValue("Order: " + order.getId());

        Row header = sheet.createRow(5);
        header.createCell(0).setCellValue("Quantity");
        header.createCell(1).setCellValue("Title");
        header.createCell(2).setCellValue("Price");

        int row = 5;
        for (OrderDetail detail : order.getOrderDetails()) {
            row++;
            Row detailRow = sheet.createRow(row);
            detailRow.createCell(0).setCellValue(detail.getQuantity());
            detailRow.createCell(1)
                  .setCellValue(detail.getBook().getTitle());
            detailRow.createCell(2).setCellValue(
                    detail.getPrice().doubleValue() * detail.getQuantity());
        }

        row++;
        Row footer = sheet.createRow(row);
        footer.createCell(0).setCellValue("Total");
        footer.createCell(1).setCellValue(
                order.getTotalOrderPrice().doubleValue());
    }
}

Listing 8-17OrderExcelView

```

在视图旁边，我们需要添加一个视图解析器。在我们的示例应用程序中，我们将这个(就像 PDF 视图一样)添加到我们的`ViewConfiguration`类中。我们添加了自定义实现的另一个实例(参见清单 [8-18](#PC18) )并让`ContentNegotiatingViewResolver`决定做什么。

```java
package com.apress.prospringmvc.bookstore.web.config;

//Other imports omitted
import org.springframework.web.servlet.view.document.AbstractJExcelView;
import org.springframework.web.servlet.view.document.AbstractPdfView;
import com.apress.prospringmvc.bookstore.web.view.OrderExcelView;

@Configuration

public class ViewConfiguration {

    @Bean
    public ContentNegotiatingViewResolver contentNegotiatingViewResolver() {
        ContentNegotiatingViewResolver viewResolver;
        viewResolver = new ContentNegotiatingViewResolver();
        List<ViewResolver> viewResolvers = new ArrayList<ViewResolver>();
        viewResolvers.add(pdfViewResolver());
        viewResolvers.add(xlsViewResolver());
        viewResolver.setViewResolvers(viewResolvers);
        return viewResolver;
    }

    @Bean
    public ViewResolver xlsViewResolver() {
        SimpleConfigurableViewResolver viewResolver;
        viewResolver = new SimpleConfigurableViewResolver();
        Map<String, AbstractJExcelView> views;
        views = new HashMap<String, AbstractJExcelView>();
        views.put("order", new OrderExcelView());
        viewResolver.setViews(views);
        return viewResolver;
    }
// Other methods omitted
}

Listing 8-18ViewConfiguration with OrderExcelView

```

但是，等等，难道我们的应用程序不会因为我们有多个解析为订单视图名称的视图实现而崩溃吗？特殊的视图解析器`ContentNegotiatingViewResolver`可以在这里帮助我们。它使用`Accept`头确定哪个解析的视图最匹配请求的内容类型。不需要改变我们的控制器，只需添加一些配置(和视图实现)，我们就可以区分哪个视图被服务。

要测试，点击`XLS`链接，会下载一个 Excel 文档供您查看。

### XML 和 JSON

Spring MVC 有另一种方式向我们的客户提供 XML 或 JSON。我们可以利用`ContentNegotiatingViewResolver`成为我们的优势。Spring 有两个特殊的视图实现来将对象转换成 XML 或 JSON，分别是`org.springframework.web.servlet.view.xml.MarshallingView`和`org.springframework.web.servlet.view.json.MappingJackson2JsonView`。基于 XML 的视图使用 Spring XML 支持将我们的模型编组为 XML。JSON 视图使用 Jackson 库。 <sup>[12](#Fn12)</sup> 我们可以轻松地配置视图解析器，将 XML 和/或 JSON 公开给客户。我们可以简单地为 XML 和 JSON 添加一个默认视图(我们也可以添加额外的视图解析器，就像我们对 PDF 和 Excel 文档所做的那样)。清单 [8-19](#PC19) 是修改后的配置(参见突出显示的部分)。

```java
package com.apress.prospringmvc.bookstore.web.config;

// Other imports omitted
import org.springframework.oxm.Marshaller;
import org.springframework.oxm.xstream.XStreamMarshaller;
import org.springframework.web.servlet.view.json.MappingJackson2JsonView;
import org.springframework.web.servlet.view.xml.MarshallingView;
import com.apress.prospringmvc.bookstore.web.view.OrderExcelView;
import com.apress.prospringmvc.bookstore.web.view.OrderPdfView;

@Configuration
public class ViewConfiguration {

    @Bean
    public ContentNegotiatingViewResolver contentNegotiatingViewResolver() {
    ContentNegotiatingViewResolver viewResolver;
    viewResolver = new ContentNegotiatingViewResolver();
    List<ViewResolver> viewResolvers = new ArrayList<ViewResolver>();
        viewResolvers.add(pdfViewResolver());
        viewResolvers.add(xlsViewResolver());
        viewResolver.setViewResolvers(viewResolvers);
        List<View> defaultViews = new ArrayList<View>();
        defaultViews.add(jsonOrderView());
        defaultViews.add(xmlOrderView());
        viewResolver.setDefaultViews(defaultViews);
        return viewResolver;
    }

    @Bean
    public MappingJackson2JsonView jsonOrderView() {
        MappingJackson2JsonView jsonView = new MappingJackson2JsonView();
        jsonView.setModelKey("order");
        return jsonView;
    }

    @Bean

    public MarshallingView xmlOrderView() {
        MarshallingView xmlView = new MarshallingView(marshaller());
        xmlView.setModelKey("order");
        return xmlView;
    }

    @Bean
    public Marshaller marshaller() {
        return new XStreamMarshaller();
    }

// Other methods omitted, see previous listings
}

Listing 8-19ViewConfiguration for XML and JSON

```

为了让 XML 工作，我们还需要配置一个`org.springframework.oxm.Marshaller`实现。我们在这里选择使用 XStream <sup>[13](#Fn13)</sup> 库是因为使用起来快捷方便。要使用另一种解决方案，只需配置适当的封送拆收器。关于编组和 XML 的更多信息可以在 *Spring 参考指南*中找到。将`modelKey`属性设置为要封送的对象。如果未指定，将在模型映射中搜索受支持的值类型。

在 ORM 实现中使用这种类型的视图时(就像在我们的例子中)，由于集合正在初始化，您可能会遇到延迟加载或加载一半数据库的情况。

如果我们现在将浏览器中的 URL 改为。json 或者。xml，我们得到订单的 JSON 或 XML 表示(见图 [8-6](#Fig6) 是 JSON 示例)。现在，我们有五种不同的方式来查看订单(HTML、PDF、Excel、JSON 和 XML ),无需触摸控制器，只需更改配置即可。

![../images/300017_2_En_8_Chapter/300017_2_En_8_Fig6_HTML.jpg](../images/300017_2_En_8_Chapter/300017_2_En_8_Fig6_HTML.jpg)

图 8-6

JSON 表示我们的`order`

## 摘要

本章讲述了 Spring MVC 的视图部分。我们通过介绍几种通用的 ViewResolver 实现来研究视图解析。我们还介绍了 Spring MVC 支持的几种视图技术，并解释了如何配置 Spring 来使用它们。我们从 JSP 开始，我们简要介绍了 JSF 以及如何将 Spring 集成到 JSF 应用程序中。接下来，您看到了几种模板解决方案；具体来说，瓷砖，速度和自由标记。

在基于 web 的视图之后，我们研究了不同的视图技术，比如如何在不改变控制器的情况下创建 PDF 和 Excel，只是简单地添加了`ContentNegotiatingViewResolver`和一个适当的视图实现。

前一章介绍了 JSON，这一章介绍了另一种将模型公开为 JSON 或 XML 的方法。最后，我们看了呈现 PDF 和 Excel 视图。

从这一章学到的一件重要的事情是控制器逻辑和视图逻辑的分离(通过我们的顺序的不同表示来证明)。这显示了应用关注点分离的力量以及它给人的灵活性。

您可能永远不会在一个应用程序中使用所有的技术。您可能只使用两到三种不同的技术(对于我们的页面，可能会创建一个 PDF 或 Excel 文件)。但是，能够灵活地更改或简单地向我们的应用程序添加一个新的视图层也不错。

<aside aria-label="Footnotes" class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

[T2`https://www.iana.org/assignments/media-types/media-types.xhtml`](https://www.iana.org/assignments/media-types/media-types.xhtml)

  [2](#Fn2_source)

[T2`https://attic.apache.org/projects/tiles.html`](https://attic.apache.org/projects/tiles.html)

  [3](#Fn3_source)

[T2`https://www.thymeleaf.org/`](https://www.thymeleaf.org/)

  [4](#Fn4_source)

[T2`https://mustache.github.io/`](https://mustache.github.io/)

  [5](#Fn5_source)

[T2`https://tiles.apache.org/framework/tutorial/advanced/wildcard.html`](https://tiles.apache.org/framework/tutorial/advanced/wildcard.html)

  [6](#Fn6_source)

[T2`https://freemarker.apache.org/`](https://freemarker.apache.org/)

  [7](#Fn7_source)

[T2`https://github.com/spring-projects/spring-framework/issues/18368`](https://github.com/spring-projects/spring-framework/issues/18368)

  [8](#Fn8_source)

[T2`https://itextpdf.com/`](https://itextpdf.com/)

  [9](#Fn9_source)

[T2`https://github.com/LibrePDF/OpenPDF`](https://github.com/LibrePDF/OpenPDF)

  [10](#Fn10_source)

[T2`http://jexcelapi.sourceforge.net`](http://jexcelapi.sourceforge.net)

  [11](#Fn11_source)

[T2`https://poi.apache.org/`](https://poi.apache.org/)

  [12](#Fn12_source)

[T2`https://github.com/FasterXML/jackson`](https://github.com/FasterXML/jackson)

  [13](#Fn13_source)

[T2`https://x-stream.github.io/`](https://x-stream.github.io/)

 </aside>