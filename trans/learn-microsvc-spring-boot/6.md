# 6.从微服务开始

这一章从我们的实践旅程的暂停开始。重要的是，我们要花时间分析我们到目前为止是如何构建我们的应用的，以及我们未来转向微服务的影响。

首先，我们将了解从单一代码库开始的优势。然后，我们将描述我们的新需求，包括基本游戏化技术的简短总结。之后，我们将了解在转向微服务时需要考虑哪些因素，以及在做出决定时应该考虑的利弊。

这一章的第二部分又都是实用的了。我们将使用我们在前面章节中学到的设计模式构建新的微服务，并将它连接到我们现有的应用程序，即第一个微服务。然后，我们将分析由于我们新的*分布式系统*我们将面临的一些新挑战。

## 小型整体式方法

上一章以一个包含所有必需功能的单一部署单元结束(如果我们愿意的话，甚至包括前端)。尽管已经确定了两个领域:挑战和用户，我们还是选择了这种单一应用程序策略。它们的域对象有关系，但是它们是松散耦合的。然而，我们从一开始就决定不将它们分成多个应用或微服务。

我们可以认为我们的乘法应用程序是一个小的整体。

## 为什么是小石块？

与微服务相比，从单个代码库开始简化了开发过程，因此我们减少了部署产品第一个版本所需的时间。此外，它使得在项目生命周期的开始阶段改变我们的架构和软件设计变得更加容易，这是在我们验证了我们的想法之后进行调整的关键。

如果你还没有在使用微服务的组织中工作过，你可能会低估微服务在软件项目中引入的技术复杂性。理想的情况是，当你读完这本书时，你会有一个更清晰的想法。接下来的章节重点关注当你转向微服务时应该采用的不同模式和技术要求，正如你将看到的，它们并不容易实现。

### 微服务从一开始就存在问题

作为我们采用的方法的替代方案，我们可以从一开始就选择微服务架构，并将用户和挑战分成两个独立的 Spring Boot 应用程序。

直接从拆分开始的一个原因是，我们的组织中可能有多个团队，他们可以并行工作而不会互相干扰。我们可以从一开始就利用将微服务映射到团队的优势。在我们的例子中，只有两个域，但是想象我们已经识别了十个不同的有界上下文。理论上，我们可以利用大组织的力量，这样我们可以更早地完成项目。

我们还可以通过拆分为微服务来实现我们的目标架构。这个计划通常被称为*反康威*。康威定律(参见 [`https://tpd.io/conway`](https://tpd.io/conway) )指出，系统设计倾向于类似于建造它的组织的结构。因此，我们尝试使用这种预测，并使我们的组织与我们想要实现的软件架构相似，这是有意义的。我们起草完整的软件架构，确定领域，并在团队之间进行划分。

能够并行工作并实现目标架构似乎是很大的优势。然而，过早拆分为微服务背后有两个问题。首先，当我们以敏捷的方式开发软件时，我们通常不会花几周的时间预先设计完整的系统。当试图识别松散耦合的域时，我们会犯错误。当我们意识到有缺陷时，就太晚了。基于错误的领域划分，很难对抗多个团队同时工作的惰性，特别是如果组织没有足够的灵活性来应对这些变化。在这种情况下，反向康威和早期分裂将对我们的目标不利。我们将创建一个反映我们最初架构的软件系统，但这可能不再是我们想要的。查看 [`https://tpd.io/reverse-conway`](https://tpd.io/reverse-conway) 在那里我给出了更多关于这个话题的见解。

直接从微服务开始的第二个大问题是，这通常意味着我们不会将系统分成垂直的部分。我们从上一章开始，描述了为什么尽早交付软件是个好主意，这样我们就可以得到反馈。然后，我们解释了如何构建应用程序层的一小部分来交付价值，而不是一个接一个地设计和实现完整的层。如果我们从零开始使用多个微服务，我们将走向横向。微服务架构总是引入技术复杂性。它们更难设置、部署、编排和测试。这只会让我们花费更多的时间来开发一个最小可行的产品，这也可能会产生技术上的影响。在最坏的情况下，我们可能会基于错误的假设进行软件设计，因此在我们得到用户的反馈后，它们就会过时。

### 小独石是为小团队准备的

如果我们能在开始时保持团队的小规模，一个小的整体是一个好的计划。我们可以专注于领域定义和实验。当我们的产品想法得到验证，有了更清晰的软件架构，更多的人可以逐渐加入团队，我们可以考虑拆分代码库，整合新的团队。然后，根据我们的需求，我们可以转向微服务或选择另一种方法，如模块化系统(我们将在本章末尾详细介绍这两种方法)。

然而，有时候我们无法避免和一个大团队一起开始一个项目。在我们的组织里这是理所当然的。我们无法让合适的人相信这不是一个好主意。如果是这样的话，这个小的整体可能会很快变成一个大的整体，有一个意大利面条式的代码库，以后可能很难模块化。此外，很难一次只关注一个垂直领域，因为那样会有很多人无所事事。在这种组织约束下，小团队想法的小整体并不能很好地工作。我们需要做一些拆分。在这种情况下，我们必须付出额外的努力，不仅要定义有界的上下文，还要定义这些未来模块之间的通信接口。每当我们设计跨多个模块或微服务的功能时，我们都确保让相应的团队参与进来，以定义这些模块将产生和消费什么样的输入/输出。我们对这些合同定义得越好，团队就越独立。在敏捷环境中，这意味着特性的交付可能会比开始时预期的要慢，因为团队不仅需要定义这些合同，还需要定义许多公共的技术基础。

### 拥抱重构

另一个小的整体看起来有问题的情况是当我们的组织不接受代码变更的时候。如前所述，我们从一个小的整体开始，验证产品想法并获得反馈。然后，我们会在某个时间点看到开始将整体分割成微服务的需要。这种拆分带来了组织和技术上的优势，我们将在后面详述。技术人员和项目经理都应该在项目开始时进行对话，根据功能和技术需求来决定何时进行这种拆分。

然而，有时我们作为开发者认为这个时刻永远不会到来:如果我们从一个庞然大物开始，我们将永远被它束缚。我们担心在项目的路线图中永远不会有停顿来计划和完成所需的微服务重构。考虑到这一点，技术人员可能会尝试从一开始就推动组织和强制微服务。这是一个坏主意，因为它通常会让那些认为这样的技术复杂性会不必要地延迟项目的人感到沮丧。与其将销售微服务架构作为唯一的选择，不如改善与业务利益相关者和项目经理的沟通，以形成一个好的计划。

## 规划未来分裂的小块巨石

当你选择一个小块的时候，你可以遵循一些好的做法，然后不费吹灰之力就可以把它分割开来。

*   *将代码划分到定义域上下文的根包中*:这就是我们在应用程序中对挑战和用户根包所做的。然后，如果您开始处理许多类，您可以为分层创建子包(例如，控制器、存储库、域和服务)，以确保层隔离。确保遵循类可见性的良好实践(例如，接口是公共的，但是它们的实现是包私有的)。使用这种结构的主要优点是，您可以保持跨域上下文的业务逻辑不可访问，并且如果您需要的话，以后您应该能够提取一个完整的根包作为微服务，只需较少的重构。

*   利用依赖注入的优势:让你的代码基于接口，让 Spring 完成注入实现的工作。使用这种模式进行重构要容易得多。例如，您可以更改一个实现，以便稍后调用不同的微服务，而不是使用本地类，而不会影响其余的逻辑。

*   *一旦你确定了上下文(例如，挑战和用户)，在你的应用中给它们起一个一致的名字*:正确地命名概念在设计阶段的开始是至关重要的，以确保每个人都理解不同的领域边界。

*   *在设计阶段，不要害怕移动类(对于小块来说更容易),直到边界变得清晰*:之后，尊重边界。不要因为可以就走捷径，将业务逻辑与上下文混为一谈。永远记住，整块石头应该准备好进化。

*   *找到共同的模式，并确定哪些可以在以后提取为共同的库，例如*:将它们移动到不同的根包中。

*   *使用同行评审来确保架构设计是合理的，并促进知识转移*:最好在一个小组中完成，而不是遵循自上而下的方法，即所有设计都来自一个人。

*   *清楚地向项目经理和/或业务代表传达* *以计划稍后分割整块石头的时间*:解释战略并创造文化。重构是必要的，这没有错。

至少在你第一次发布之前，尽量保持一个小的整体。不要害怕它；一个小的独石会给你带来一些好处。

*   在早期阶段更快的开发可以更好地获得产品的快速反馈。

*   您可以轻松地更改域边界。

*   人们习惯了相同的技术指南。这有助于实现未来的一致性。

*   常见的跨域功能可以作为库(或指南)来识别和共享。

*   团队将获得系统的完整视图，而不仅仅是部分视图。然后，这些人可以转移到其他团队，并带来有用的知识。

## 新需求和游戏化

想象一下，我们发布我们的应用程序，并将其连接到一个分析引擎。我们每天都有新用户，也有定期回来的老用户，这要感谢我们最近展示尝试历史的功能。然而，我们在我们的指标中看到，一周后，用户倾向于放弃用新的挑战训练他们大脑的惯例。

因此，我们根据我们的数据做出决定，试图改善这些数字。这个简单的过程被称为*数据驱动决策* (DDDM)，它对所有类型的项目都很重要。我们使用数据来选择我们的下一步行动，而不是基于直觉或仅仅是观察。如果你对 DDDM 感兴趣，网上有很多文章和课程。在 [`https://tpd.io/dddm`](https://tpd.io/dddm) 的文章是一个很好的开始。

在我们的例子中，我们计划引入一些*游戏化*来提高应用程序的参与度。请记住，我们将游戏化减少到点数、徽章和排行榜，以使本书专注于技术主题。如果你对这个领域感兴趣，那么《T2 现实被打破》和《T4 为了胜利》是很好的起点。在介绍游戏化以及它如何应用到我们的应用程序之前，让我们先介绍一下我们的新用户故事。

用户故事 3

作为应用程序的用户，我希望每天都有动力不断解决挑战，不要过一段时间就放弃。这样我就不断锻炼脑子，日积月累提高。

### 游戏化:点数、徽章和排行榜

游戏化是将游戏中使用的技术应用到另一个非游戏领域的设计过程。你这样做是因为你想从游戏中获得一些众所周知的好处，比如激发玩家的积极性，与你的进程、应用程序或者你正在*游戏化的*东西互动。

用其他东西制作游戏的一个基本想法是引入*点*:每次你完成一个动作，并且做得很好，你就会得到一些分数。如果你表现得不好，你甚至可以得到分数，但这应该是一个公平的机制:如果你做得更好，你会得到更多。赢得分数会让玩家觉得他们在进步，并给他们反馈。

*排行榜*让每个人都能看到分数，因此他们通过激发竞争的感觉来激励玩家。我们希望得到比我们上面的人更多的分数，排名更高。如果你和朋友一起玩，这就更有趣了。

最后但同样重要的是，*徽章*是获得地位的虚拟象征。我们喜欢徽章，因为它们不仅仅代表积分。此外，它们可以代表不同的事情:你可以与另一个玩家拥有相同的分数(例如，五个正确答案)，但你可以用不同的方式赢得它们(例如，一分钟五个！).

一些不是游戏的软件应用很好地运用了这些元素。以 StackOverflow 为例。它充满了游戏元素，鼓励人们不断参与。

我们要做的是给用户提交的每个正确答案打分。为了简单起见，只有当他们发出一个正确的尝试，我们才会给分。我们每次给它 10 分。

页面上会显示得分最高的排行榜，这样玩家可以在排名中找到自己，并与其他人竞争。

我们还将创建一些基本徽章:铜牌(10 次正确尝试)、银牌(25 次正确尝试)和金牌(50 次正确尝试)。因为第一次正确的尝试值得一个好的反馈信息，我们还将引入第一次正确！徽章。此外，为了引入一个惊喜元素，我们将有一个徽章，只有当用户解决了一个数字 42 是其中一个因素的乘法时，他们才能获胜。

有了这些基础，我们相信我们会激励我们的用户回来继续玩，与他们的同龄人竞争。

## 转向微服务

在我们的新要求中，没有什么是我们用我们的小单体不能实现的。实际上，如果这是一个只有一个开发人员的项目，并且目标不是教育性的，那么最好的选择就是创建一个名为`gamification`的新根包，并开始在同一个可部署单元中编写我们的类。

让我们把自己放在一个不同的场景中。想象一下，我们发现了可以帮助我们实现业务目标的其他新特性。其中一些改进可能如下:

*   根据用户的统计数据调整挑战的复杂性。

*   添加提示。

*   允许用户登录，而不是使用别名。

*   要求一些用户的个人信息，以收集更好的指标。

这些改进将影响现有的挑战和用户领域。此外，由于我们的第一次发布非常顺利，让我们想象一下我们也得到了一些资本投资。我们的团队可以成长。我们应用程序的开发不再需要按顺序进行。我们可以在游戏化领域工作，同时我们也在用额外的功能改进现有的领域。

我们还可以说，投资者带来了一些条件，现在我们希望扩大到每月 100，000 活跃用户。我们需要设计我们的架构来应对这种情况。我们可能很快就会意识到，我们计划构建的新游戏化组件不如主要功能(解决挑战)重要。如果游戏化功能在短时间内不可用，只要用户仍然可以解决挑战，我们就没事。

从我们的分析中，我们可以得出以下结论:

1.  用户和挑战领域在我们的应用程序中至关重要。我们应该致力于保持它们的高可用性。水平可伸缩性非常适合这种情况:我们部署第一个应用程序的多个实例，如果其中一个实例出现故障，我们使用负载平衡并转移流量。此外，复制服务还会给我们更多的能力来处理许多并发用户。

2.  新的游戏化领域在可用性方面有不同的要求。我们不需要以同样的速度扩大这一逻辑。我们可以接受它比其他域执行得慢，也可以允许它停止工作一段时间。

3.  由于我们的团队在成长，我们可以从拥有可独立部署的单元中获益。如果我们保持游戏化模块松散耦合并独立发布，我们可以在我们的组织中与多个团队一起工作，并将干扰降至最低。

考虑到那些非功能性需求(例如，可伸缩性、可用性和可扩展性)，转移到微服务似乎是个好主意。让我们更详细地介绍一下这些优势。

### 独立的工作流程

我们在前面的章节中已经看到了如何遵循 DDD 原则完成模块化架构。我们可以将得到的有界上下文分割成不同的代码库，这样多个团队可以更加独立地工作。

然而，如果这些模块是同一个可部署单元的一部分，我们在团队之间仍然有一些依赖。我们需要将所有这些模块集成在一起，确保它们能够相互协作，并将整个系统部署到我们的生产环境中。如果其他基础设施元素跨模块共享，如数据库，这些依赖性会变得更大。

微服务将模块化带到了一个新的高度，因为我们可以独立部署它们。团队不仅可以有不同的存储库，还可以有不同的工作流。

在我们的系统中，我们可以在不同的存储库中开发一些 Spring Boot 应用程序。它们都有自己的嵌入式 web 服务器，所以我们可以分别部署它们。这消除了在一个大的整体发布过程中产生的所有摩擦:测试、打包、相互依赖的数据库更新等等。

如果我们还考虑维护和支持方面，微服务有助于构建 DevOps 文化，因为每个应用程序可能拥有其相应的基础架构元素:web 服务器、数据库、指标、日志等。当我们使用像 Spring Boot 这样的框架时，系统可以被看作是一组相互交互的微型应用程序。如果其中一个部分出现问题，拥有该微服务的团队可以修复它。对于一块巨石，通常很难画出这些线。

### 水平可扩展性

当我们想要纵向扩展一个单一的应用程序时，我们可以选择使用更大的服务器/容器纵向扩展*，或者使用更多的实例和负载平衡器横向扩展*。水平可伸缩性通常是首选，因为多台小型机器比一台强大的机器便宜。此外，通过打开和关闭实例，我们可以更好地对不同的工作负载模式做出反应。**

 **借助微服务，您可以选择更加灵活的可扩展性策略。在我们的实际例子中，我们认为乘法应用程序是我们系统的关键部分，必须处理大量的并发请求。因此，我们可以决定部署两个乘法微服务实例，但只部署一个游戏化微服务实例(尚未开发)。如果我们将所有的逻辑放在一个地方，我们也将复制游戏化逻辑，即使我们可能不需要那些资源。图 [6-1](#Fig1) 显示了一个这样的例子。

![../images/458480_2_En_6_Chapter/458480_2_En_6_Fig1_HTML.jpg](../images/458480_2_En_6_Chapter/458480_2_En_6_Fig1_HTML.jpg)

图 6-1

整体服务与微服务的水平可扩展性

### 细粒度的非功能需求

我们可以将水平可伸缩性的优势推广到其他非功能性需求。例如，我们说过，如果新的游戏化微服务在短时间内不可用，也没那么糟糕。如果我们正在运行一个单一的应用程序，整个系统可能会由于游戏化模块上的意外情况而崩溃。借助微服务，我们可以选择允许系统中的完整部分停机一段时间。我们将在本书的后面看到如何实现弹性模式来构建一个容错能力更强的后端。

例如，这同样适用于安全。我们可能需要对管理用户个人数据的微服务进行更多限制，但我们不需要处理游戏化领域的安全开销。作为独立的应用程序，微服务带来了更多的灵活性。

### 其他优势

我们选择微服务架构还有其他一些原因。然而，我把它们分开分组，因为我认为你不应该把它们当作做出决定的因素。

*   多种技术:例如，我们可能想用 Java 构建一些微服务，用 Golang 构建一些微服务。然而，这是有代价的，因为使用公共工件或框架或者跨团队共享知识并不容易。我们可能还想使用不同的数据库引擎，但这在模块化整体中也是可能的。

*   *与组织结构的一致性*:正如我们在本章前面所描述的，您可能会尝试使用康威法则，尝试按照您的组织结构来设计微服务，反之亦然。但是我们已经讨论了它的利弊，这也取决于您是直接在项目生命周期的开始还是后期进行拆分。

*   *替换系统部件的能力*:如果微服务给你的软件架构带来更多的隔离，逻辑上认为应该更容易替换它们，而不会对其他服务造成太大影响。但是，在现实生活中，当一些基本规则没有得到遵守时，微服务也可能变得相互强烈耦合。另一方面，你可以用一个好的模块化系统实现可替换性。因此，我也不认为这是变革的决定性驱动力。

### 不足之处

正如我们在前面章节中已经提到的，微服务架构也有很多缺点，所以它们不是解决整体架构可能出现的所有问题的灵丹妙药。我们讨论了这些缺点，同时分析了为什么从一个小的整体开始是个好主意。

*   *您需要更多时间来交付第一个工作版本*:由于微服务架构的复杂性，与单一服务相比，它需要更多时间来正确设置。

*   *跨域移动功能变得更加困难*:一旦您进行了第一次拆分，与单个代码库或部署单元相比，需要额外的工作来合并代码或跨微服务移动功能。

*   *有一个新范式的隐含介绍*:假设微服务架构使你的系统是分布式的，你将面临新的挑战，比如异步处理、分布式事务和最终的一致性。我们将在本章和下一章详细分析这些新的范例。

*   需要学习新的模式:当你有一个分布式系统时，你最好知道如何实现路由、服务发现、分布式跟踪和日志记录等。这些模式不容易实现和维护。我们将在第八章[中讲述它们。](8.html)

*   *你可能需要采用新的工具*:有一些框架和工具可以帮助你实现一个微服务架构:Spring Cloud、Docker、Message Brokers、Kubernetes 等。在单一架构中，您可能不需要它们，这意味着额外的维护、设置、潜在成本和学习所有这些新概念的时间。同样，本书将在接下来的章节中帮助你理解这些工具。

*   运行您的系统需要更多资源*:在项目开始时，当系统流量还不高时，维护一个基于微服务的系统可能比一个整体系统要昂贵得多。拥有多个空闲服务比拥有一个空闲服务效率更低。此外，周围的工具和模式(我们将在本书中讨论)引入了额外的过载。只有当您从可伸缩性、容错和其他我们将在本书后面描述的特性中受益时，这种影响才开始变得积极。*

**   *可能会偏离标准* *和通用实践*:转移到微服务的原因之一可能是跨团队实现更多的独立性。然而，如果每个人都开始创建自己的解决方案来解决相同的问题，而不是重用公共模式，这也可能会产生负面影响。这可能会浪费时间，并使人们更难理解系统的其他部分。

    *   架构要复杂得多*:用微服务架构解释你的系统如何工作可能会变得更加困难。这意味着新加入者需要额外的时间来理解整个系统是如何工作的。有人可能会说，只要人们了解他们工作的领域，就不需要这样做，但是了解所有部分如何相互作用总是更好的。*

    **   *你可能会被你不需要的新技术分散注意力*:一旦你登上一列周围都是花哨工具的微服务列车，一些人可能会被实施起来*酷*的新产品和模式所吸引。然而，你可能不需要它们，所以它们只是分散注意力。尽管这种情况在任何类型的架构中都可能发生，但在使用微服务时会发生得更频繁。** 

 **其中的一些要点你可能还不清楚。不要担心，在我们的旅程结束时，你将能够确切地理解它们的意思。本书对这些主题采取了务实和现实的方法，帮助您理解微服务架构的优势和劣势，以便您可以在未来做出最佳决策。

## 架构概述

在比较了我们现有的备选方案并分析了微服务的利弊之后，我们决定采取行动，为我们的游戏化需求创建一个新的 Spring Boot 应用程序。给定我们假设的场景，系统和组织的可伸缩性在这个决策中扮演着重要的角色。

现在我们可以把这两个应用称为乘法微服务和游戏化微服务。直到现在，称我们的第一个应用为微服务才有意义，因为它还不是微服务架构的一部分。

图 [6-2](#Fig2) 表示我们系统中的不同组件，以及在本章结束时它们将如何连接。

![../images/458480_2_En_6_Chapter/458480_2_En_6_Fig2_HTML.jpg](../images/458480_2_En_6_Chapter/458480_2_En_6_Fig2_HTML.jpg)

图 6-2

逻辑视图

让我们回顾一下这个设计中新增的内容。

*   会有新的微服务，游戏化。为了防止本地端口冲突，我们将它部署在端口 8081 上。

*   乘法微服务会将每次尝试发送到游戏化微服务，以处理新的分数、徽章和更新排行榜。

*   我们的 React UI 中将会有一个新组件，用于显示带有分数和徽章的排行榜。如图所示，我们的 UI 将调用这两个微服务。

关于此设计的一些注意事项:

*   我们还可以从一个嵌入式 web 服务器部署 UI。然而，最好将 UI 服务器视为不同的部署单元。同样的优势也适用于此:独立的工作流、灵活的可伸缩性等。

*   UI 需要调用两个服务，这看起来可能有点奇怪。你可以考虑将一个反向代理放在另外两个代理的前面，来完成路由并保持 API 客户端不知道后端的软件架构(参见 [`https://en.wikipedia.org/wiki/Reverse_proxy`](https://en.wikipedia.org/wiki/Reverse_proxy) )。这实际上是网关模式，我们将在本书后面详细讨论它。现在让我们保持简单。

*   如果你关注了这本书的总结，从乘法到游戏化的同步调用肯定会引起你的注意。这确实不是最好的设计，但是让我们保留演进方法的例子，并且首先了解为什么它不是最好的想法。

## 设计和实现新服务

在这一节中，我们将设计和实现游戏化微服务，采用与我们第一个 Spring Boot 服务 Multiplication 相似的方法。

### 接口

通常在使用模块化系统时，我们必须注意模块之间的*契约*。对于微服务，这一点更加重要，因为作为一个团队，我们希望尽快明确所有预期的依赖关系。

在我们的例子中，游戏化微服务需要公开一个接口来接受新的尝试。它需要这些数据来计算用户的统计数据。目前，这个接口将是一个 REST API。交换的 JSON 对象可以简单地包含与我们存储在乘法微服务上的尝试相同的字段:尝试的数据和用户的数据。在游戏化方面，我们将只使用我们需要的数据。

另一方面，UI 需要收集排行榜细节。我们还将在游戏化微服务中创建新的 REST 端点来访问这些数据。

信息

从这里开始，本章的小节将介绍新游戏化微服务的源代码。很高兴看一看它，因为我们将在不同的层中使用一些新的小功能。然而，我们在前面的章节中已经看到了主要的概念，所以你可以决定走捷径。那也有可能。如果你不想深入游戏化微服务的开发，你可以直接跳到“使用我们的服务”一节，使用本章的代码，可在 [`https://github.com/Book-Microservices-v2/chapter06`](https://github.com/Book-Microservices-v2/chapter06) 获得。

### 游戏化的 Spring Boot 框架

我们可以在 [`https://start.spring.io/`](https://start.spring.io/) 再次使用 Spring Initializr 为我们的新应用程序创建基本框架。这一次，我们预先知道我们将需要一些额外的依赖项，所以我们可以从这里直接添加它们:Lombok、Spring Web、Validation、Spring Data JPA 和 H2 数据库。如图 [6-3](#Fig3) 所示填写详细信息。

![../images/458480_2_En_6_Chapter/458480_2_En_6_Fig3_HTML.jpg](../images/458480_2_En_6_Chapter/458480_2_En_6_Fig3_HTML.jpg)

图 6-3

创建游戏化应用程序

下载 zip 文件，并将其解压缩为现有`multiplication`文件夹旁边的`gamification`文件夹。您可以将这个新项目作为一个单独的模块添加到同一个工作区中，以便将所有内容组织在同一个 IDE 实例中。

### 领域

让我们对我们的游戏化领域建模，尝试尊重上下文边界，并最小化与现有功能的耦合。

*   我们创建了一个*记分卡*对象，它保存用户在给定挑战尝试中获得的分数。

*   类似地，我们有一个*徽章卡*对象，代表用户在给定时间赢得的特定类型的徽章。它不需要绑定到记分卡，因为当你超过给定的分数阈值时，你可能会赢得徽章。

*   为了模拟排行榜，我们创建了一个*排行榜位置*。我们将显示这些域对象的有序列表，向用户显示排名。

在这个模型中，我们现有的领域对象和新的领域对象之间存在一些关系，如图 [6-4](#Fig4) 所示。

![../images/458480_2_En_6_Chapter/458480_2_En_6_Fig4_HTML.jpg](../images/458480_2_En_6_Chapter/458480_2_En_6_Fig4_HTML.jpg)

图 6-4

新的游戏化领域

如您所见，我们仍然保持这些域的松散耦合:

*   用户域保持完全隔离。它不保留对任何其他对象的任何引用。

*   挑战领域只需要了解用户。我们不需要将他们的对象与游戏化概念联系起来。

*   游戏化领域需要参考用户，挑战尝试。我们计划在发送一个尝试后获取这些数据，所以我们将在本地存储一些引用(用户和尝试的标识符)。

域对象可以很容易地映射到 Java 类。我们还将为这个服务使用 JPA/Hibernate，这样我们就可以添加 JPA 注释了。首先，清单 [6-1](#PC1) 展示了`ScoreCard`类，它有一个额外的构造函数来设置一些默认值。

源代码

您可以在 GitHub 的`chapter06`资源库中找到本章的所有源代码。

[`https://github.com/Book-Microservices-v2/chapter06`见](https://github.com/Book-Microservices-v2/chapter06)。

```java
package microservices.book.gamification.game.domain;

import lombok.*;
import javax.persistence.*;

/**
 * This class represents the Score linked to an attempt in the game,
 * with an associated user and the timestamp in which the score
 * is registered.
 */
@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ScoreCard {

    // The default score assigned to this card, if not specified.
    public static final int DEFAULT_SCORE = 10;

    @Id
    @GeneratedValue
    private Long cardId;
    private Long userId;
    private Long attemptId;
    @EqualsAndHashCode.Exclude
    private long scoreTimestamp;
    private int score;

    public ScoreCard(final Long userId, final Long attemptId) {
        this(null, userId, attemptId, System.currentTimeMillis(), DEFAULT_SCORE);
    }

}

Listing 6-1The ScoreCard Domain/Data Class

```

我们这次用了一个新的 Lombok 注释，`@EqualsAndHashCode.Exclude`。顾名思义，这将使 Lombok 不在生成的`equals`和`hashCode`方法中包含该字段。原因是，当我们比较对象时，这将使我们的测试更容易，事实上，我们不需要时间戳来确定两张卡是否相等。

不同的徽章在一个枚举中定义，`BadgeType`。我们将添加一个`description`字段，为每个字段取一个友好的名称。见清单 [6-2](#PC2) 。

```java
package microservices.book.gamification.game.domain;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * Enumeration with the different types of Badges that a user can win.
 */
@RequiredArgsConstructor
@Getter
public enum BadgeType {

    // Badges depending on score
    BRONZE("Bronze"),
    SILVER("Silver"),
    GOLD("Gold"),

    // Other badges won for different conditions
    FIRST_WON("First time"),
    LUCKY_NUMBER("Lucky number");

    private final String description;
}

Listing 6-2The BadgeType Enum

```

正如您在前面的代码中看到的，我们也从 enums 中的一些 Lombok 注释中受益。在这种情况下，我们使用它们为`description`字段生成一个构造函数和 getter。

`BadgeCard`类使用`BadgeType`，它也是一个 JPA 实体。见清单 [6-3](#PC3) 。

```java
package microservices.book.gamification.game.domain;

import lombok.*;
import javax.persistence.*;

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
public class BadgeCard {

    @Id
    @GeneratedValue
    private Long badgeId;

    private Long userId;
    @EqualsAndHashCode.Exclude
    private long badgeTimestamp;
    private BadgeType badgeType;

    public BadgeCard(final Long userId, final BadgeType badgeType) {
        this(null, userId, System.currentTimeMillis(), badgeType);
    }

}

Listing 6-3The BadgeCard Domain/Data Class

```

我们还添加了一个构造函数来设置一些默认值。注意，我们不需要向枚举类型添加任何特定的 JPA 注释。默认情况下，Hibernate 会将这些值映射到枚举的序数值(一个整数)。如果我们记住应该只在末尾追加新的枚举值，这就很好了，但是我们也可以配置映射器来使用字符串值。

为了模拟排行榜位置，我们创建了类`LeaderBoardRow`。参见清单 [6-4](#PC4) 。我们不需要在我们的数据库中保存这个对象，因为它将通过聚合来自我们用户的分数和徽章来动态创建。

```java
package microservices.book.gamification.game.domain;

import lombok.*;
import java.util.List;

@Value
@AllArgsConstructor
public class LeaderBoardRow {

    Long userId;
    Long totalScore;
    @With
    List<String> badges;

    public LeaderBoardRow(final Long userId, final Long totalScore) {
        this.userId = userId;
        this.totalScore = totalScore;
        this.badges = List.of();
    }

}

Listing 6-4The LeaderBoardRow Class

```

添加到`badges`字段的`@With`注释是由 Lombok 提供的，它为我们生成一个方法来克隆一个对象并向副本添加一个新的字段值(在本例中是`withBadges`)。当我们使用不可变的类时，这是一个很好的实践，因为它们没有 setters。当我们创建业务逻辑来合并每个排行榜行的分数和徽章时，我们将使用这种方法。

### 服务

我们将把这个新的游戏化微服务中的业务逻辑一分为二。

*   游戏逻辑，负责处理尝试并生成结果分数和徽章

*   排行榜逻辑，汇总数据并根据分数建立排名

游戏逻辑将驻留在类`GameServiceImpl`中，它实现了`GameService`接口。规范很简单:基于一次尝试，它计算分数和徽章并存储它们。乘法微服务可以通过一个名为`GameController`的控制器访问这个业务逻辑，这个控制器将公开一个 POST 端点来发送尝试。在持久层，我们的业务逻辑将需要一个`ScoreRepository`来保存记分卡和一个`BadgeRepository`来对工卡做同样的事情。图 6-5 显示了构建游戏逻辑功能所需的所有类的 UML 图。

![../images/458480_2_En_6_Chapter/458480_2_En_6_Fig5_HTML.jpg](../images/458480_2_En_6_Chapter/458480_2_En_6_Fig5_HTML.jpg)

图 6-5

UML:游戏逻辑

我们可以定义如清单 [6-5](#PC5) 所示的`GameService`接口。

```java
package microservices.book.gamification.game;

import java.util.List;
import lombok.Value;
import microservices.book.gamification.challenge.ChallengeSolvedDTO;
import microservices.book.gamification.game.domain.BadgeCard;
import microservices.book.gamification.game.domain.BadgeType;
import microservices.book.gamification.game.domain.ScoreCard;

public interface GameService {

    /**
     * Process a new attempt from a given user.
     *
     * @param challenge the challenge

data with user details, factors, etc.
     * @return a {@link GameResult} object containing the new score and badge cards obtained
     */
    GameResult newAttemptForUser(ChallengeSolvedDTO challenge);

    @Value
    class GameResult {
        int score;
        List<BadgeType> badges;
    }
}

Listing 6-5The GameService Interface

```

处理尝试后的输出是一个在接口中定义的`GameResult`对象。它将从该尝试中获得的分数与用户可能获得的任何新徽章组合在一起。我们也可以考虑不返回任何内容，因为这将是显示结果的排行榜逻辑。然而，最好能从我们的方法得到一个响应，这样我们就可以测试它。

`ChallengeSolvedDTO`类定义了倍增和游戏化微服务之间的契约，我们将在两个项目中创建它以保持它们的独立性。现在，让我们关注游戏化代码库。参见清单 [6-6](#PC6) 。

```java
package microservices.book.gamification.challenge;

import lombok.Value;

@Value
public class ChallengeSolvedDTO {

    long attemptId;
    boolean correct;
    int factorA;
    int factorB;
    long userId;
    String userAlias;

}

Listing 6-6The ChallengeSolvedDTO Class

```

既然我们已经定义了域类和服务层的框架，我们就可以使用 TDD 并为我们的业务逻辑创建一些测试用例，使用一个空的接口实现和 DTO 类。

锻炼

用两个测试用例创建`GameServiceTest`:一个正确的尝试和一个错误的尝试。您将在本章的代码源中找到解决方案。

现在，只关注分数的计算，而不是徽章。我们将为该部分创建一个单独的接口和测试。

清单 [6-7](#PC7) 中显示了一个有效的`GameService`接口实现。仅当挑战被正确解决时，它才创建一个`ScoreCard`对象，并存储它。徽章以单独的方式处理，以提高可读性。我们还需要一些存储库方法来保存分数和徽章，并检索以前创建的记录。现在，我们可以假设这些方法有效；我们将在“数据”部分详细解释它们。

```java
package microservices.book.gamification.game;

import java.util.*;
import java.util.stream.Collectors;
import org.springframework.stereotype.Service;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import microservices.book.gamification.challenge.ChallengeSolvedDTO;
import microservices.book.gamification.game.badgeprocessors.BadgeProcessor;
import microservices.book.gamification.game.domain.BadgeCard;
import microservices.book.gamification.game.domain.BadgeType;
import microservices.book.gamification.game.domain.ScoreCard;

@Service
@Slf4j
@RequiredArgsConstructor

class GameServiceImpl implements GameService {

    private final ScoreRepository scoreRepository;
    private final BadgeRepository badgeRepository;
    // Spring injects all the @Component beans in this list
    private final List<BadgeProcessor> badgeProcessors;

    @Override
    public GameResult newAttemptForUser(final ChallengeSolvedDTO challenge) {
        // We give points only if it's correct
        if (challenge.isCorrect()) {
            ScoreCard scoreCard = new ScoreCard(challenge.getUserId(),
                    challenge.getAttemptId());
            scoreRepository.save(scoreCard);
            log.info("User {} scored {} points for attempt id {}",
                    challenge.getUserAlias(), scoreCard.getScore(),
                    challenge.getAttemptId());
            List<BadgeCard> badgeCards = processForBadges(challenge);
            return new GameResult(scoreCard.getScore(),
                    badgeCards.stream().map(BadgeCard::getBadgeType)
                            .collect(Collectors.toList()));

        } else {
            log.info("Attempt id {} is not correct. " +
                            "User {} does not get score.",
                    challenge.getAttemptId(),
                    challenge.getUserAlias());
            return new GameResult(0, List.of());
        }
    }

    /**
     * Checks the total score and the different score cards obtained
     * to give new badges in case their conditions are met.
     */
    private List<BadgeCard> processForBadges(
            final ChallengeSolvedDTO solvedChallenge) {
        Optional<Integer> optTotalScore = scoreRepository.
                getTotalScoreForUser(solvedChallenge.getUserId());
        if (optTotalScore.isEmpty()) return Collections.emptyList();

        int totalScore = optTotalScore.get();

        // Gets the total score and existing badges for that user
        List<ScoreCard> scoreCardList = scoreRepository
                .findByUserIdOrderByScoreTimestampDesc(solvedChallenge.getUserId());
        Set<BadgeType> alreadyGotBadges = badgeRepository
                .findByUserIdOrderByBadgeTimestampDesc(solvedChallenge.getUserId())
                .stream()
                .map(BadgeCard::getBadgeType)
                .collect(Collectors.toSet());

        // Calls the badge processors for badges that the user doesn't have yet
        List<BadgeCard> newBadgeCards = badgeProcessors.stream()
                .filter(bp -> !alreadyGotBadges.contains(bp.badgeType()))
                .map(bp -> bp.processForOptionalBadge(totalScore,
                        scoreCardList, solvedChallenge)
                ).flatMap(Optional::stream) // returns an empty stream if empty
                // maps the optionals if present to new BadgeCards
                .map(badgeType ->

                        new BadgeCard(solvedChallenge.getUserId(), badgeType)
                )
                .collect(Collectors.toList());

        badgeRepository.saveAll(newBadgeCards);

        return newBadgeCards;
    }

}

Listing 6-7Implementing the GameService Interface

in the GameServiceImpl Class

```

从这个实现中我们可以得出结论，`BadgeProcessor`接口接受一些上下文数据和已解决的尝试，并决定是否分配给定类型的徽章。清单 [6-8](#PC8) 显示了该接口的源代码。

```java
package microservices.book.gamification.game.badgeprocessors;

import java.util.List;
import java.util.Optional;
import microservices.book.gamification.challenge.ChallengeSolvedDTO;
import microservices.book.gamification.game.domain.BadgeType;
import microservices.book.gamification.game.domain.ScoreCard;

public interface BadgeProcessor {

    /**
     * Processes some or all of the passed parameters and decides if the user
     * is entitled to a badge.
     *
     * @return a BadgeType if the user is entitled to this badge, otherwise empty
     */
    Optional<BadgeType> processForOptionalBadge(
            int currentScore,
            List<ScoreCard> scoreCardList,
            ChallengeSolvedDTO solved);

    /**
     * @return the BadgeType object that this processor is handling. You can use
     * it to filter processors according to your needs.
     */
    BadgeType badgeType();

}

Listing 6-8The BadgeProcessor Interface

```

由于我们在`GameServiceImpl`中使用带有一系列`BadgeProcessor`对象的构造函数注入，Spring 将找到所有实现这个接口的 beans，并将它们传递给我们。这是一种灵活的方式来扩展我们的游戏，而不干扰其他现有的逻辑。我们只需要添加新的`BadgeProcessor`实现并用`@Component`注释它们，这样它们就可以加载到 Spring 上下文中了。

清单 [6-9](#PC9) 和 [6-10](#PC10) 是我们需要满足功能需求的五个徽章实现中的两个`BronzeBadgeProcessor`和`FirstWonBadgeProcessor`。

```java
package microservices.book.gamification.game.badgeprocessors;

import microservices.book.gamification.challenge.ChallengeSolvedDTO;
import microservices.book.gamification.game.domain.BadgeType;
import microservices.book.gamification.game.domain.ScoreCard;
import org.springframework.stereotype.Component;
import java.util.List;
import java.util.Optional;

@Component
class FirstWonBadgeProcessor implements BadgeProcessor {

    @Override
    public Optional<BadgeType> processForOptionalBadge(
                int currentScore,
                List<ScoreCard> scoreCardList,
                ChallengeSolvedDTO solved) {
        return scoreCardList.size() == 1 ?
                Optional.of(BadgeType.FIRST_WON) : Optional.empty();

    }

    @Override
    public BadgeType badgeType() {
        return BadgeType.FIRST_WON;
    }
}

Listing 6-10FirstWonBadgeProcessor Implementation

```

```java
package microservices.book.gamification.game.badgeprocessors;

import microservices.book.gamification.challenge.ChallengeSolvedDTO;
import microservices.book.gamification.game.domain.BadgeType;
import microservices.book.gamification.game.domain.ScoreCard;
import org.springframework.stereotype.Component;
import java.util.List;
import java.util.Optional;

@Component
class BronzeBadgeProcessor implements BadgeProcessor {

    @Override

    public Optional<BadgeType> processForOptionalBadge(
                int currentScore,
                List<ScoreCard> scoreCardList,
                ChallengeSolvedDTO solved) {
        return currentScore > 50 ?
                Optional.of(BadgeType.BRONZE) :
                Optional.empty();
    }

    @Override
    public BadgeType badgeType() {
        return BadgeType.BRONZE;
    }
}

Listing 6-9BronzeBadgeProcessor Implementation

```

锻炼

实现其他三个 badge 处理器和所有单元测试，以验证它们是否按预期工作。如果需要帮助，可以查阅本章的源代码。

1.  银色徽章。如果分数超过 150 就赢了。

2.  金质徽章。如果分数超过 400 就赢了。

3.  “幸运数字”徽章。如果尝试的任何因素为 42，则获胜。

一旦我们完成了业务逻辑的第一部分，我们就可以进入第二部分:排行榜功能。图 [6-6](#Fig6) 显示了我们将在本章中实现的构建排行榜的三个层的 UML 图。

![../images/458480_2_En_6_Chapter/458480_2_En_6_Fig6_HTML.jpg](../images/458480_2_En_6_Chapter/458480_2_En_6_Fig6_HTML.jpg)

图 6-6

排行榜，UML 图

接口`LeaderBoardService`有一个方法来返回一个排序后的`LeaderBoardRow`对象列表。见清单 [6-11](#PC11) 。

```java
package microservices.book.gamification.game;

import java.util.List;
import microservices.book.gamification.game.domain.LeaderBoardRow;

public interface LeaderBoardService {

    /**
     * @return the current leader board ranked from high to low score
     */
    List<LeaderBoardRow> getCurrentLeaderBoard();

}

Listing 6-11The LeaderBoardService Interface

```

锻炼

创建`LeaderBoardServiceImplTest`来验证该实现应该查询`ScoreCardRepository`来查找具有最高分数的用户，并且应该查询`BadgeCardRepository`来将分数与他们的徽章合并。和以前一样，存储库类还没有出现，但是您可以创建一些虚拟方法，并在测试中模拟它们。

如果我们能够聚合分数并对数据库中的结果行进行排序，那么排行榜服务的实现仍然很简单。我们将在下一节看到如何实现。现在，我们假设我们可以从`ScoreRepository`(`findFirst10`方法)获得分数排名。然后，我们查询数据库来检索包含在排名中的用户的徽章。见清单 [6-12](#PC12) 。

```java
package microservices.book.gamification.game;

import java.util.List;
import java.util.stream.Collectors;
import org.springframework.stereotype.Service;
import lombok.RequiredArgsConstructor;
import microservices.book.gamification.game.domain.LeaderBoardRow;

@Service
@RequiredArgsConstructor
class LeaderBoardServiceImpl implements LeaderBoardService {

    private final ScoreRepository scoreRepository;
    private final BadgeRepository badgeRepository;

    @Override
    public List<LeaderBoardRow> getCurrentLeaderBoard() {

        // Get score only
        List<LeaderBoardRow> scoreOnly = scoreRepository.findFirst10();
        // Combine with badges
        return scoreOnly.stream().map(row -> {
            List<String> badges =
                    badgeRepository.findByUserIdOrderByBadgeTimestampDesc(
                            row.getUserId()).stream()
                            .map(b -> b.getBadgeType().getDescription())
                            .collect(Collectors.toList());
            return row.withBadges(badges);
        }).collect(Collectors.toList());
    }
}

Listing 6-12The LeaderBoardService Implementation

```

注意，我们使用了方法`withBadges`来复制一个具有新值的不可变对象。我们第一次生成排行榜时，所有行都有一个空白的徽章列表。当我们收集徽章时，我们可以用相应徽章列表的副本替换(使用 stream 的`map`)每个对象。

### 数据

在业务逻辑层，我们对`ScoreRepository`和`BadgeRepository`方法做了一些假设。是时候构建这些存储库了。

请记住，我们只是通过扩展 Spring Data 的`CrudRepository`来获得基本的 CRUD 功能，因此我们可以轻松地保存徽章和记分卡。对于其余的查询，我们将同时使用查询方法和 JPQL。

`BadgeRepository`接口定义了一个查询方法来查找给定用户的徽章，按日期排序，最近的放在最上面。参见清单 [6-13](#PC13) 。

```java
package microservices.book.gamification.game;

import microservices.book.gamification.game.domain.BadgeCard;
import microservices.book.gamification.game.domain.BadgeType;
import org.springframework.data.repository.CrudRepository;
import java.util.List;

/**
 * Handles data operations with BadgeCards

 */
public interface BadgeRepository extends CrudRepository<BadgeCard, Long> {

    /**
     * Retrieves all BadgeCards for a given user.
     *
     * @param userId the id of the user to look for BadgeCards
     * @return the list of BadgeCards, ordered by most recent first.
     */
    List<BadgeCard> findByUserIdOrderByBadgeTimestampDesc(Long userId);

}

Listing 6-13The BadgeRepository Interface with a Query Method

```

对于记分卡，我们需要其他查询类型。到目前为止，我们确定了三个需求。

1.  计算一个用户的总分。

2.  获得最高分的用户列表，作为`LeaderBoardRow`对象。

3.  按用户 ID 读取所有记分卡记录。

清单 [6-14](#PC14) 显示了`ScoreRepository`的完整源代码。

```java
package microservices.book.gamification.game;

import java.util.List;
import java.util.Optional;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import microservices.book.gamification.game.domain.LeaderBoardRow;
import microservices.book.gamification.game.domain.ScoreCard;

/**
 * Handles CRUD operations with ScoreCards and other related score queries

 */
public interface ScoreRepository extends CrudRepository<ScoreCard, Long> {

    /**
     * Gets the total score for a given user: the sum of the scores of all
     * their ScoreCards.
     *
     * @param userId the id of the user
     * @return the total score for the user, empty if the user doesn't exist
     */
    @Query("SELECT SUM(s.score) FROM ScoreCard s WHERE s.userId = :userId GROUP BY s.userId")
    Optional<Integer> getTotalScoreForUser(@Param("userId") Long userId);

    /**
     * Retrieves a list of {@link LeaderBoardRow}s representing the Leader Board
     * of users and their total score.
     *
     * @return the leader board, sorted by highest score first.
     */
    @Query("SELECT NEW microservices.book.gamification.game.domain.LeaderBoardRow(s.userId, SUM(s.score)) " +
            "FROM ScoreCard s " +
            "GROUP BY s.userId ORDER BY SUM(s.score) DESC")
    List<LeaderBoardRow> findFirst10();

    /**
     * Retrieves all the ScoreCards for a given user, identified by his user id.
     *
     * @param userId the id of the user
     * @return a list containing all the ScoreCards for the given user,
     * sorted by most recent.
     */
    List<ScoreCard> findByUserIdOrderByScoreTimestampDesc(final Long userId);

}

Listing 6-14The ScoreRepository Interface, Using Query Methods and JPQL Queries

```

不幸的是，Spring Data JPA 的查询方法不支持聚合。好消息是 JPA 查询语言 JPQL 确实支持它们，所以我们可以使用标准语法使我们的代码尽可能与数据库无关。我们可以通过以下查询获得给定用户的总分:

```java
SELECT SUM(s.score) FROM ScoreCard s WHERE s.userId = :userId GROUP BY s.userId

```

像在标准 SQL 中一样，`GROUP BY`子句指示如何对值求和。我们可以用`:param`符号定义参数。然后，我们用`@Param`注释相应的方法参数。我们也可以使用我们在上一章中遵循的方法，使用像`?1`这样的参数位置占位符。

第二个查询有点特殊。在 JPQL 中，我们可以使用 Java 类中可用的构造函数。我们在示例中所做的是基于总分的聚合，并且我们使用我们定义的双参数构造函数来构造`LeaderBoardRow`对象(它设置了一个空白的徽章列表)。请记住，我们必须使用 JPQL 中类的完全限定名，如源代码所示。

### 控制器

在设计我们的游戏化领域时，我们与乘法服务达成了一个*合同*。它会将每个尝试发送到游戏化端的 REST 端点。是时候构建控制器了。见清单 [6-15](#PC16) 。

```java
package microservices.book.gamification.game;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import lombok.RequiredArgsConstructor;
import microservices.book.gamification.challenge.ChallengeSolvedDTO;

@RestController
@RequestMapping("/attempts")
@RequiredArgsConstructor
public class GameController {

    private final GameService gameService;

    @PostMapping
    @ResponseStatus(HttpStatus.OK)
    void postResult(@RequestBody ChallengeSolvedDTO dto) {
        gameService.newAttemptForUser(dto);
    }
}

Listing 6-15The GameController Class

```

在`POST /attempts`上有一个 REST API，它接受一个 JSON 对象，该对象包含关于用户和挑战的数据。在这种情况下，我们不需要返回任何内容，所以我们利用`ResponseStatus`注释来配置 Spring 返回一个`200 OK`状态代码。实际上，这是当控制器的方法返回`void`并且已经被正确处理时的默认行为。无论如何，为了更好的可读性，显式地添加它是有好处的。请记住，例如，如果出现抛出异常之类的错误，Spring Boot 的默认错误处理逻辑将拦截它，并返回一个带有不同状态代码的错误响应。

我们还可以向 DTO 类添加验证，以确保其他服务不会向游戏化微服务发送无效数据，但现在，让我们保持简单。无论如何，我们将在下一章修改这个 API。

锻炼

不要忘记为第一个控制器和下一个控制器添加测试。你可以在本章的源代码中找到这些测试。

我们的第二个控制器用于排行榜功能，并公开了一个返回序列化的`LeaderBoardRow`对象的 JSON 数组的`GET /leaders`方法。这些数据来自服务层，服务层使用徽章和分数存储库来合并用户的分数和徽章。因此，表示层保持简单。参见清单 [6-16](#PC17) 中的代码。

```java
package microservices.book.gamification.game;

import lombok.RequiredArgsConstructor;
import microservices.book.gamification.game.domain.LeaderBoardRow;
import org.springframework.web.bind.annotation.*;
import java.util.List;

/**
 * This class implements a REST API for the Gamification LeaderBoard service.
 */
@RestController
@RequestMapping("/leaders")
@RequiredArgsConstructor
class LeaderBoardController {

    private final LeaderBoardService leaderBoardService;

    @GetMapping
    public List<LeaderBoardRow> getLeaderBoard() {
        return leaderBoardService.getCurrentLeaderBoard();
    }
}

Listing 6-16The LeaderBoardController Class

```

### 配置

我们经历了应用程序的三个层次:业务逻辑、数据和表示。我们还缺少一些我们在乘法微服务中定义的 Spring Boot 配置。

首先，我们给游戏化微服务中的`application.properties`文件添加一些值。参见清单 [6-17](#PC18) 。

```java
server.port=8081
# Gives us access to the H2 database web console
spring.h2.console.enabled=true
# Creates the database in a file
spring.datasource.url=jdbc:h2:file:~/gamification;DB_CLOSE_ON_EXIT=FALSE
# Creates or updates the schema if needed
spring.jpa.hibernate.ddl-auto=update
# For educational purposes we will show the SQL in console
spring.jpa.show-sql=true

Listing 6-17The application.properties File for the Gamification App

```

唯一新增的是`server.port`属性。我们改变它，因为当我们在本地运行它们时，我们不能在我们的第二个应用程序中使用相同的缺省值`8080`。我们还在`datasource` URL 中设置了一个不同的 H2 文件名，为这个微服务创建一个单独的数据库，名为`gamification`。

此外，我们还需要为这个微服务启用 CORS，因为用户界面需要能够访问排行榜 API。如果你不记得 CORS 做了什么，看看第 4 章中的“第一次运行我们的前端”一节。这个文件的内容与我们在乘法中添加的内容相同。参见清单 [6-18](#PC19) 。

```java
package microservices.book.gamification.configuration;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfiguration implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(final CorsRegistry registry) {
        registry.addMapping("/**").allowedOrigins("http://localhost:3000");
    }

}

Listing 6-18Adding CORS Configuration

to the Gamification App

```

鉴于我们还想使用 Hibernate 的 Jackson 模块，我们必须在 Maven 中添加这种依赖性。请记住，我们还需要将模块注入到上下文中，以便由自动配置来选择。参见清单 [6-19](#PC20) 和 [6-20](#PC21) 。

```java
package microservices.book.gamification.configuration;

import com.fasterxml.jackson.databind.Module;
import com.fasterxml.jackson.datatype.hibernate5.Hibernate5Module;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JsonConfiguration {

    @Bean
    public Module hibernateModule() {
        return new Hibernate5Module();

    }

}

Listing 6-20Defining the Bean for JSON’s Hibernate Module to Be Used for Serialization

```

```java
<dependencies>
<!-- ... -->
    <dependency>
        <groupId>com.fasterxml.jackson.datatype</groupId>
        <artifactId>jackson-datatype-hibernate5</artifactId>
    </dependency>
</dependencies>

Listing 6-19Adding the Jackson’s Hibernate

Module to Gamification’s pom.xml File

```

### 乘法微服务的变化

我们完成了游戏化微服务的第一个版本。现在，我们必须通过与新的微服务通信乘法，将两个微服务集成在一起。

之前，我们在服务器端创建了一些 REST APIs。这一次，我们必须构建一个 REST API 客户端。Spring Web 模块提供了一个用于这个目的的工具:`RestTemplate`类。Spring Boot 在顶部提供了额外的一层:T1。当我们使用 Spring Boot Web starter 时，这个构建器是默认注入的，我们可以使用它的方法通过多种配置选项流畅地创建`RestTemplate`对象。如果需要访问服务器，我们可以添加特定的消息转换器、安全凭证、HTTP 拦截器等。在我们的例子中，我们可以使用默认设置，因为两个应用程序都使用 Spring Boot 的预定义配置。也就是说我们的`RestTemplate`发送的序列化 JSON 对象在服务器端(游戏化微服务)可以无问题的反序列化。

为了保持我们的实现模块化，我们在一个单独的类中创建游戏化的 REST 客户端:`GamificationServiceClient`。参见清单 [6-21](#PC22) 。

```java
package microservices.book.multiplication.serviceclients;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import lombok.extern.slf4j.Slf4j;
import microservices.book.multiplication.challenge.ChallengeAttempt;
import microservices.book.multiplication.challenge.ChallengeSolvedDTO;

@Slf4j
@Service
public class GamificationServiceClient {

    private final RestTemplate restTemplate;
    private final String gamificationHostUrl;

    public GamificationServiceClient(final RestTemplateBuilder builder,
                                     @Value("${service.gamification.host}") final String gamificationHostUrl) {
        restTemplate = builder.build();
        this.gamificationHostUrl = gamificationHostUrl;
    }

    public boolean sendAttempt(final ChallengeAttempt attempt) {
        try {
            ChallengeSolvedDTO dto = new ChallengeSolvedDTO(attempt.getId(),
                    attempt.isCorrect(), attempt.getFactorA(),
                    attempt.getFactorB(), attempt.getUser().getId(),
                    attempt.getUser().getAlias());
            ResponseEntity<String> r = restTemplate.postForEntity(
                    gamificationHostUrl + "/attempts", dto,
                    String.class);
            log.info("Gamification service response: {}", r.getStatusCode());
            return r.getStatusCode().is2xxSuccessful();
        } catch (Exception e) {

            log.error("There was a problem sending the attempt.", e);
            return false;
        }
    }
}

Listing 6-21The GamificationServiceClient Class, in the Multiplication App

```

这个新的弹簧`@Service`可以注入到我们现有的弹簧中。它使用构建器用默认值初始化`RestTemplate`(只是调用`build()`)。它还在构造函数中接受游戏化服务的主机 URL，我们希望提取它作为配置参数。

在 Spring Boot，我们可以在`application.properties`文件中创建自己的配置选项，并用`@Value`注释将它们的值注入到组件中。`gamificationHostUrl`参数将被设置为这个新属性的值，我们必须将它添加到乘法的属性文件中。参见清单 [6-22](#PC23) 。

```java
# ... existing properties

# Gamification service URL
service.gamification.host=http://localhost:8081

Listing 6-22Adding the URL of the Gamification Microservice as a Property in Multiplication

```

服务客户端的其余实现很简单。它基于来自域对象`ChallengeAttempt`的数据构建一个(新的)`ChallengeSolvedDTO`。然后，它使用`RestTemplate`中的`postForEntity`方法将数据发送到游戏化中的`/attempts`端点。我们不期望响应体，但是方法的签名需要它，所以我们可以将其设置为`String`。

我们还将完整的逻辑包装在 try/catch 块中。原因是我们不希望一个试图到达游戏化微服务的错误最终打破了我们在乘法微服务中的主要业务逻辑。这一决定将在本章末尾进一步解释。

这个`ChallengeSolvedDTO`类是我们在游戏化方面创建的一个类的副本。参见清单 [6-23](#PC24) 。

```java
package microservices.book.multiplication.challenge;

import lombok.Value;

@Value
public class ChallengeSolvedDTO {

    long attemptId;
    boolean correct;
    int factorA;
    int factorB;
    long userId;
    String userAlias;

}

Listing 6-23The ChallengeSolvedDTO Class Needs to Be Included in the Multiplication Microservice Too

```

现在我们可以在现有的`ChallengeServiceImpl`类中注入这个服务，并在它被处理后使用它来发送尝试。参见清单 [6-24](#PC25) 了解该级所需的修改。

```java
@Slf4j
@RequiredArgsConstructor
@Service
public class ChallengeServiceImpl implements ChallengeService {

    private final UserRepository userRepository;
    private final ChallengeAttemptRepository attemptRepository;
    private final GamificationServiceClient gameClient;

    @Override
    public ChallengeAttempt verifyAttempt(ChallengeAttemptDTO attemptDTO) {
        // ... existing logic

        // Stores the attempt
        ChallengeAttempt storedAttempt = attemptRepository.save(checkedAttempt)

;

        // Sends the attempt to gamification and prints the response
        HttpStatus status = gameClient.sendAttempt(storedAttempt);
        log.info("Gamification service response: {}", status);

        return storedAttempt;
    }

    // ...
}

Listing 6-24Adding Logic to ChallengeServiceImpl

to Send an Attempt to the Gamification Microservice

```

我们的测试也应该更新，以检查每次尝试时调用是否发生。我们可以给`ChallengeServiceTest`增加一个新的模拟职业。

```java
@Mock private GamificationServiceClient gameClient;

```

然后，我们在测试用例中使用 Mockito 的`verify`,以确保这个调用是使用存储在数据库中的相同数据来执行的。

```java
verify(gameClient).sendAttempt(resultAttempt);

```

除了 REST API 客户端之外，我们还想为乘法微服务添加第二项更改:一个控制器，用于根据用户的标识符检索用户别名集合。我们需要这样做，因为我们在`LeaderBoardController`类中实现的排行榜 API 根据用户 id 返回分数、徽章和位置。UI 需要一种方法将每个 ID 映射到一个用户别名，以更友好的方式呈现表格。参见清单 [6-25](#PC28) 中的新`UserController`级。

```java
package microservices.book.multiplication.user;

import java.util.List;
import org.springframework.web.bind.annotation.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping("/users")
public class UserController {

    private final UserRepository userRepository;

    @GetMapping("/{idList}")
    public List<User> getUsersByIdList(@PathVariable final List<Long> idList) {
        return userRepository.findAllByIdIn(idList);
    }
}

Listing 6-25The New UserController Class

```

这一次我们使用一个标识符列表作为路径变量，Spring 将它拆分并作为标准的`List`传递给我们。实际上，这意味着 API 调用可以包含一个或多个用逗号分隔的数字，例如`/users/1,2,3`。

如您所见，我们在控制器中注入了一个存储库，因此我们在这里没有遵循三层架构原则。原因是我们不需要这个特定用例的业务逻辑，所以，在这些情况下，最好保持我们的代码简单。如果我们在未来任何时候需要业务逻辑，我们可以从层之间的松散耦合中受益，并在这两者之间创建服务层。

存储库接口使用新的查询方法在`users`表中执行选择，过滤那些标识符在传递列表中的。参见清单 [6-26](#PC29) 中的源代码。

```java
package microservices.book.multiplication.user;

import java.util.List;
import java.util.Optional;
import org.springframework.data.repository.CrudRepository;

public interface UserRepository extends CrudRepository<User, Long> {

    Optional<User> findByAlias(final String alias);

    List<User> findAllByIdIn(final List<Long> ids);

}

Listing 6-26The New Query Methods in the UserRepository Interface

```

锻炼

更新乘法微服务中的测试，以覆盖对 REST 客户端的新调用，并为`UserController`创建一个新调用。你可以在本章的源代码中找到解决方案。

### 用户界面

后端逻辑已经准备好了，可以转到前端部分了。我们需要两个新的 JavaScript 类:

*   从游戏化微服务中检索排行榜数据的新 API 客户端

*   一个额外的 React 组件来呈现排行榜

我们还将向现有的 API 客户机添加一个新方法，根据用户的 id 检索用户列表。

清单 [6-27](#PC30) 中的`GameApiClient`类定义了一个不同的主机，并使用`fetch` API 来检索 JSON 对象数组。为了清楚起见，我们也将现有的`ApiClient`重命名为`ChallengesApiClient`。然后，我们在这一个中包括一个新的方法来检索用户。参见清单 [6-28](#PC31) 。

```java
class ChallengesApiClient {

    static SERVER_URL = 'http://localhost:8080';
    // ...
    static GET_USERS_BY_IDS = '/users';

    // existing methods...

    static getUsers(userIds: number[]): Promise<Response> {
        return fetch(ChallengesApiClient.SERVER_URL +
            ChallengesApiClient.GET_USERS_BY_IDS +
            '/' + userIds.join(','));
    }

}

export default ChallengesApiClient;

Listing 6-28Renaming the Former Apiclient Class and Including the New Call

```

```java
class GameApiClient {
    static SERVER_URL = 'http://localhost:8081';
    static GET_LEADERBOARD = '/leaders';

    static leaderBoard(): Promise<Response> {
        return fetch(GameApiClient.SERVER_URL +
            GameApiClient.GET_LEADERBOARD);
    }

}

export default GameApiClient;

Listing 6-27The GamiApiClient Class

```

返回的承诺将用于新的`LeaderBoardComponent`，它检索数据并更新其状态的`leaderboard`属性。它的`render()`方法应该将对象数组映射到一个 HTML 表中，每个位置一行。我们将使用 JavaScript 的定时事件(见 [`https://tpd.io/timing-events`](https://tpd.io/timing-events) )通过函数`setInterval`每五秒刷新一次排行榜。

参见清单 [6-29](#PC32) 中`LeaderBoardComponent`的完整源代码。然后，我们将更深入地研究它的逻辑。

```java
import * as React from 'react';
import GameApiClient from '../services/GameApiClient';
import ChallengesApiClient from '../services/ChallengesApiClient';

class LeaderBoardComponent extends React.Component {

    constructor(props) {
        super(props);
        this.state = {
            leaderboard: [],
            serverError: false
        }
    }

    componentDidMount() {
        this.refreshLeaderBoard();
        // sets a timer to refresh the leaderboard every 5 seconds

        setInterval(this.refreshLeaderBoard.bind(this), 5000);
    }

    getLeaderBoardData(): Promise {
        return GameApiClient.leaderBoard().then(
            lbRes => {
                if (lbRes.ok) {
                    return lbRes.json();
                } else {
                    return Promise.reject("Gamification: error response");
                }
            }
        );
    }

    getUserAliasData(userIds: number[]): Promise {
        return ChallengesApiClient.getUsers(userIds).then(

            usRes => {
                if(usRes.ok) {
                    return usRes.json();
                } else {
                    return Promise.reject("Multiplication: error response");
                }
            }
        )
    }

    updateLeaderBoard(lb) {
        this.setState({
            leaderboard: lb,
            // reset the flag
            serverError: false
        });
    }

    refreshLeaderBoard() {
        this.getLeaderBoardData().then(
            lbData => {
                let userIds = lbData.map(row => row.userId);
                this.getUserAliasData(userIds).then(data => {

                    // build a map of id -> alias
                    let userMap = new Map();
                    data.forEach(idAlias => {
                        userMap.set(idAlias.id, idAlias.alias);
                    });
                    // add a property to existing lb data
                    lbData.forEach(row =>
                        row['alias'] = userMap.get(row.userId)
                    );
                    this.updateLeaderBoard(lbData);
                }).catch(reason => {
                    console.log('Error mapping user ids', reason);
                    this.updateLeaderBoard(lbData);
                });
            }
        ).catch(reason => {
            this.setState({ serverError: true });
            console.log('Gamification server error', reason);
        });
    }

    render() {
        if (this.state.serverError) {
            return (
                <div>We're sorry, but we can't display game statistics at this

                    moment.</div>
            );
        }
        return (
            <div>
                <h3>Leaderboard</h3>
                <table>
                    <thead>
                    <tr>
                        <th>User</th>
                        <th>Score</th>
                        <th>Badges</th>
                    </tr>
                    </thead>
                    <tbody>
                    {this.state.leaderboard.map(row => <tr key={row.userId}>
                        <td>{row.alias ? row.alias : row.userId}</td>
                        <td>{row.totalScore}</td>
                        <td>{row.badges.map(
                            b => <span className="badge" key={b}>{b}</span>)}

                        </td>
                    </tr>)}
                    </tbody>
                </table>
            </div>
        );
    }
}

export default LeaderBoardComponent;

Listing 6-29The New LeaderBoardComponent in React

```

主逻辑包含在`refreshLeaderBoard`功能中。首先，它试图从游戏化服务器获取排行榜行。如果不能(`catch`子句)，它会将`serverError`标志设置为 true，所以我们将呈现一条消息而不是表格。如果数据被正常检索，逻辑执行第二次调用，这次是对乘法微服务的调用。如果我们得到适当的响应，我们会将数据中包含的用户标识符映射到其对应的别名，并为排行榜中的每个位置添加一个新字段`alias`。如果第二次调用失败，我们仍然使用没有额外字段的原始数据。

`render()`功能区分错误情况和标准情况。如果有错误，我们会显示一条消息而不是表格。通过这种方式，我们使我们的应用具有弹性，因为即使游戏化微服务失败，主要功能(解决挑战)仍在工作。排行榜数据与用户别名(或 ID，如果无法获取的话)、总分和徽章列表一起显示在各行中。

我们在渲染逻辑中使用了`badge` CSS 类。让我们在`App.css`样式表中创建这个定制样式。见清单 [6-30](#PC33) 。

```java
/* ... existing styles ... */

.badge {
  font-size: x-small;
  border: 2px solid dodgerblue;
  border-radius: 4px;
  padding: 0.2em;
  margin: 0.1em;
}

Listing 6-30Adding the Badge Style to App.css

```

现在，我们应该在我们的根容器`ChallengeComponent`类中包含排行榜组件。参见清单 [6-31](#PC34) 中对源代码的修改。

```java
import LeaderBoardComponent from './LeaderBoardComponent';

class ChallengeComponent extends React.Component {

    // ...existing methods...

    render() {
        return (
            <div className="display-column">
                {/* we add this just before closing the main div */}
                <LeaderBoardComponent />
            </div>

        );
    }
}

export default ChallengeComponent

;

Listing 6-31Adding the LeaderBoardComponent Inside the ChallengeComponent

```

## 玩弄系统

我们实现了新的游戏化微服务，通过 REST API 客户端服务将乘法应用程序连接到它，并构建 UI 以获取排行榜并每五秒钟渲染一次。

是时候玩我们的完整系统了。使用 IDE 或命令行启动后端应用程序和 Node.js 服务器。如果您使用终端，打开三个单独的实例，并在每个实例中运行清单 [6-32](#PC35) 中的一个命令，这样您就可以单独访问所有日志。

```java
/multiplication $ mvnw spring-boot:run
...
/gamification $ mvnw spring-boot:run
...
/challenges-frontend $ npm start
...

Listing 6-32Starting the Apps from the Console

```

如果一切顺利，我们将看到 UI 在浏览器中运行。将会有一个空的排行榜(除非你在编码时已经尝试过一点)。如果我们发送一个正确的尝试，我们应该看到类似于图 [6-7](#Fig7) 的东西。

![../images/458480_2_En_6_Chapter/458480_2_En_6_Fig7_HTML.jpg](../images/458480_2_En_6_Chapter/458480_2_En_6_Fig7_HTML.jpg)

图 6-7

连接到两个微服务的 UI

当我们发送第一次正确尝试时，我们将获得 10 分和“第一次”徽章。游戏有效！您可以继续玩，看看您是否能获得任何金属徽章或幸运数字 1。由于每五秒钟自动渲染一次，您甚至可以在多个浏览器标签中玩游戏，排行榜将在每个标签中刷新。

现在让我们来看看日志。在乘法方面，当我们发送新的尝试时，我们会在日志中看到这一行:

```java
INFO 36283 --- [nio-8080-exec-4] m.b.m.challenge.ChallengeServiceImpl     : Gamification service response: 200 OK

```

游戏化应用程序会输出一行，说明尝试不正确，因此没有新的分数，或者如果你是正确的，会输出以下行:

```java
INFO 36280 --- [nio-8081-exec-9] m.b.gamification.game.GameServiceImpl    : User jane scored 10 points for attempt id 2

```

我们还会看到许多重复的日志行显示查询，因为我们将应用程序配置为显示所有 JPA 语句，并且 UI 会定期调用以检索排行榜和用户别名。

## 容错

在细化我们的需求时，我们确定游戏化特性并不重要，因此我们可以接受系统的这一部分出现一些停机时间。让我们来看看这个新的微服务会发生什么。如果你还在运行应用程序，停止游戏化应用程序。否则，只启动 UI 服务器和乘法。

我们将在屏幕上看到排行榜组件的回退消息，如图 [6-8](#Fig8) 所示。正如我们可以使用开发者工具中的网络选项卡来验证的那样，对游戏化服务的 HTTP 调用(在端口`8081`上)失败了。

![../images/458480_2_En_6_Chapter/458480_2_En_6_Fig8_HTML.jpg](../images/458480_2_En_6_Chapter/458480_2_En_6_Fig8_HTML.jpg)

图 6-8

游戏化微服务宕机

此外，如果我们尝试发送一个尝试，它仍然会工作。该错误会导致一个在`GamificationServiceClient`类中捕获的异常。

```java
ERROR 36666 --- [nio-8080-exec-2] m.b.m.s.GamificationServiceClient : There was a problem sending the attempt.

```

即使有一半的后端宕机，核心功能仍能正常工作。但是请记住，在这种情况下，我们将丢失数据，因此用户将不会获得任何成功尝试的分数。

作为替代实现，我们可以使用重试逻辑。我们可以实现一个循环来不断尝试发布尝试，直到我们从游戏化微服务获得一个`OK`响应，或者直到一定量的时间过去。但是，即使有我们可以用来实现这种模式的库，我们系统的复杂性也增加了。重试的时候乘法微服务也宕机了怎么办？我们是否应该跟踪数据库中尚未发送的尝试？在这种情况下，当游戏化应用程序在随机时刻复活时，我们应该按照发生的顺序发送尝试吗？如您所见，像我们的微服务架构这样的分布式系统带来了新的挑战。

## 未来的挑战

我们建立的系统正在运行，所以我们应该为此感到自豪。即使在游戏化微服务出现故障的情况下，应用程序也能保持响应。请参见图 [6-9](#Fig9) 了解我们系统的更新逻辑视图。

![../images/458480_2_En_6_Chapter/458480_2_En_6_Fig9_HTML.jpg](../images/458480_2_En_6_Chapter/458480_2_En_6_Fig9_HTML.jpg)

图 6-9

逻辑视图

我们的后端逻辑现在分布在这两个 Spring Boot 应用程序中。让我们回顾一下构建分布式系统的意义，重点关注我们的微服务架构和我们面临的新挑战。

### 紧密结合

当我们对我们的域建模时，我们认为它们是松散耦合的，因为我们在域对象之间只使用最少的引用。然而，我们在乘法微服务中引入了游戏化逻辑的意识。后者显式调用游戏化 API 来发送尝试，并负责传递消息。我们使用的命令式风格在 monolith 中还不错，但在微服务架构中可能会成为一个大问题，因为它在微服务之间引入了紧密耦合。

在我们当前的设计中，游戏化微服务由乘法微服务编排，乘法微服务主动触发动作。我们可以不使用这种编排模式，而是使用编排模式，让游戏化微服务决定何时触发其逻辑。我们将在下一章讲述事件驱动架构时，详细说明编排和编排之间的区别。

### 同步接口与最终一致性

正如我们前面所详述的，乘法微服务希望游戏化服务器在发送尝试时可用。如果不是，这个过程的这一部分仍然是不完整的。所有这些都发生在请求的生命周期中。当乘法服务器向 UI 发送响应时，分数和徽章要么被更新，要么出现了错误。我们构建了同步接口:请求保持阻塞状态，直到它们完全完成或者失败。

当您有许多微服务时，您将不可避免地有跨越它们的流程，就像在我们的例子中，即使它们有精心设计的上下文边界。为了描述这一点，让我们创建一个更复杂的场景，作为我们后端的假设性发展。作为第一个补充，我们想给用户发送一封电子邮件，当他们达到 1000 点。在不对领域边界进行判断的情况下，假设我们有一个专用的微服务，它需要在分配新分数后进行更新。我们还添加了一个微服务，收集数据进行报告，需要连接到乘法和游戏化。参见图 [6-10](#Fig10) 了解该假想系统的完整视图。

![../images/458480_2_En_6_Chapter/458480_2_En_6_Fig10_HTML.jpg](../images/458480_2_En_6_Chapter/458480_2_En_6_Fig10_HTML.jpg)

图 6-10

我们系统的假设进化

我们可以继续用 REST API 调用构建同步接口。然后，我们将有一个调用链，如图中的数字序列所示。来自浏览器的请求需要等待，直到所有的请求都完成。链中的服务越多，请求被阻塞的时间就越长。如果一个微服务慢了，整个链就慢了。系统的整体性能至少和链中最差的微服务一样差。

当我们在构建微服务时没有考虑容错时，同步依赖性甚至更差。在我们的示例中，从游戏化微服务到报告微服务的一个简单的失败更新操作可能会使整个流程崩溃。如果我们在同一个阻塞线程中实现重试机制，性能会下降得更多。如果我们让它们太容易失败，我们可能会以许多部分完成的操作而告终。

到目前为止有一个明确的结论:同步接口在微服务之间引入了强烈的依赖性。

作为一个优势，我们知道当用户得到响应时，报告已经在后端更新了。所以，是分数。我们甚至知道我们是否可以发送电子邮件，所以我们可以立即给出反馈。

在 monolith 中，我们不会面临这种挑战，因为所有这些模块都存在于同一个可部署单元中。如果我们只是调用其他方法，我们不会因为网络延迟或错误而遇到问题。此外，如果某个东西发生故障，它将是整个系统，因此我们不需要在设计它的同时考虑细粒度的容错。

所以，如果同步接口不好，重要的问题是:我们需要首先阻塞完整的请求吗？在返回响应之前，我们需要知道所有的事情都完成了吗？为了回答这个问题，让我们修改我们的假设案例，分离微服务之间的后续交互。见图 [6-11](#Fig11) 。

![../images/458480_2_En_6_Chapter/458480_2_En_6_Fig11_HTML.jpg](../images/458480_2_En_6_Chapter/458480_2_En_6_Fig11_HTML.jpg)

图 6-11

异步处理

这种新的设计在新的线程中发起一些请求，解除了主线程的阻塞。例如，我们可以使用 Java 期货。这将导致响应更早地传递给客户端，因此我们解决了前面描述的所有问题。但是，结果是，我们引入了最终的一致性。想象一下，在 API 客户端，有一个顺序线程等待发送尝试的响应。然后，这个客户端的进程将尝试收集分数和报告。在阻塞线程场景中，我们的 API 客户端(例如，UI)肯定知道，在从乘法得到响应后，游戏化中的分数与尝试一致。在这个新的异步环境中，我们无法保证这一点。如果我们的网络延迟很好，客户端可能会得到更新的分数。但可能需要一秒钟才能完成，或者我们的服务关闭了更长时间，只有在重试几次后才会更新。我们无法预测。

因此，在构建微服务架构时，我们面临的最大挑战之一就是实现最终的一致性。我们应该接受游戏化微服务的数据在给定时刻可能与倍增微服务的数据不一致。它只会最终保持一致。最后，通过使我们的系统健壮的适当设计，游戏化微服务将是最新的。同时，我们的 API 客户端不能假设不同 API 调用之间的一致性。这是关键:不仅仅是我们的后端系统；这也与我们的 API 客户有关。如果我们是唯一使用我们的 API 的人，那可能不是一个大问题:我们可以开发我们的 REST 客户端，并最终保持一致性。然而，如果我们提供 API 作为服务，我们也必须教育我们的客户。他们必须知道会发生什么。

因此，我们最初关于是否需要阻塞请求的问题可以被一个更重要的问题所取代:我们的系统最终能保持一致吗？当然，答案取决于我们的功能和技术需求。

例如，在某些情况下，系统的功能描述可能意味着很强的一致性，但是您可以对其进行调整，而不会产生很大的影响。作为一个实际案例，如果我们将电子邮件子流程分离为一个异步步骤，我们可以将提示用户的消息从“您应该已经收到一封带有说明的电子邮件”更改为“您将在几分钟后收到一封带有说明的电子邮件”。如果没有，请联系客户支持。”但是能够做出这样的改变总是依赖于组织接受最终一致性的需求和胃口。

微服务并不总是最好的解决方案(第一部分)

如果您的项目需求与跨域的最终一致性不兼容，那么模块化的单一应用程序可能更适合您。

另一方面，我们不需要处处完全异步。在某些情况下，微服务之间的同步调用是有意义的。这不是问题，也不是把我们的软件架构戏剧化的理由。我们只需要关注这些接口，因为有时这是域之间紧密耦合的征兆。在这种情况下，我们可以考虑将其合并到同一个微服务中。

回顾我们当前的系统状态，我们可以得出结论，它已经为最终的一致性做好了准备。由于我们不依赖响应来刷新排行榜，我们可以在微服务之间切换到异步调用，而不会产生任何影响。

可以想象，有一种比用重试模式调用 REST API 更好的方法来实现微服务之间的异步通信。我们将在下一章讨论它。

### 处理

在 monolith 中，我们可以使用相同的关系数据库来存储用户、尝试、分数和徽章。然后，我们可以从数据库事务中受益。我们将获得在前一章中简要介绍过的 ACID 保证:原子性、一致性、隔离性和持久性。在保存记分卡出错的情况下，我们可以恢复事务中所有以前的命令，这样尝试也不会被存储。该操作被称为*回滚*。因为我们可以避免部分更新，所以我们可以始终确保数据的完整性。

我们不能拥有跨微服务的 ACID 保证，因为我们无法在一个微服务架构中实现真正的事务。它们是独立部署的，所以它们生活在不同的进程中，它们的数据库也应该是解耦的。此外，为了避免相互依赖，我们还得出结论，我们应该接受最终的一致性。

*原子性*，或者确保所有相关数据被存储或者什么都不存储，很难在微服务之间实现。在我们的系统中，首先请求存储尝试，然后乘法微服务调用游戏化微服务做好自己的工作。即使我们保持请求同步，如果我们没有收到响应，我们也不知道分数和徽章是否被存储。那我们该怎么办？我们要回滚事务吗？不管游戏化中发生了什么，我们总是保存尝试吗(就像我们做的那样)？

事实上，在分布式系统中尝试实现事务回滚有一些富有想象力且复杂的方法。

*   *两阶段提交(2PC)* :在这种方法中，我们可以将乘法尝试发送到游戏化，但我们不会将数据存储在任何一端。然后，一旦我们得到指示数据准备好被存储的响应，我们发送第二个请求作为信号来存储游戏化的分数和徽章，并且我们存储乘法的尝试。通过这两个阶段(准备和提交)，我们最大限度地减少了出错的时间。然而，我们没有排除这种可能性，因为第二阶段可能会失败。在我看来，这是一个可怕的想法，因为我们必须坚持同步接口，并且复杂性呈指数增长。

*   *Sagas* :这种设计模式涉及双向沟通。我们可以在两个微服务之间建立一个异步接口，如果游戏化方面出现问题，这个微服务应该能够联系乘法微服务，让它知道。在我们的例子中，乘法将删除刚刚保存的尝试。这样我们*补偿*一笔交易。就复杂性而言，这也带来了高昂的代价。

毫无疑问，最好的解决方案是尽量将必须使用数据库事务的功能流保持在同一个微服务中。如果我们不能分割一个事务，因为它在我们的系统中是关键的，那么看起来这个流程应该属于同一个域。对于其他流，我们可以尝试分割事务边界，并最终实现一致性。

我们还可以应用模式使我们的系统更加健壮，这样我们就可以最小化部分执行操作的风险。任何可以确保微服务间数据传递的设计模式都将有助于实现这一目标。这也将在下一章讨论。

我们的系统不使用分布式事务。它也不需要它们，因为我们不需要尝试和得分之间的即时一致性。但仍然有一个设计缺陷:乘法微服务忽略了游戏化的错误，因此我们可能会在没有相应分数和徽章的情况下成功解决尝试。我们将很快改进这一点，而不需要我们自己实现重试机制。

微服务并不总是最好的解决方案(第二部分)

如果您发现自己到处都在用 2PC 或 sagas 实现分布式事务，那么您应该花一些时间来反思您的需求和您的微服务边界。你可能想要合并其中的一些或者更好的分配功能。如果您不能用更简单的方法来解决这个问题，那么就考虑一个只有一个关系数据库的模块化整体应用程序。

### API 暴露

我们在游戏化微服务中创建了一个 REST 端点，用于乘法微服务。但是用户界面也需要访问游戏化微服务，所以事实上，任何人都可以访问它。如果聪明的用户使用 HTTP 客户端(如 HTTPie)，他们可以向游戏化微服务发送虚假数据。我们的处境会很糟糕，因为这会破坏我们的数据完整性。用户可以得分并获得徽章，而无需存储在乘法端的相应尝试。

解决这个问题有多种方法。我们可以考虑给我们的端点增加一个安全层，并确保内部 API 只对其他后端服务可用。一个更简单的选择是使用反向代理(带有网关模式)来确保我们只公开公共端点。我们将在第 [8](8.html) 章更详细地介绍这个选项。

## 总结和成就

在本章中，我们探讨了转向微服务架构的原因。我们开始详细介绍我们迄今为止所采用的方法，即小型整体架构，并分析了与过渡到微服务相比，继续我们的模块化整体应用之旅的利弊。

我们还研究了一个小型的 monolith 如何帮助你更好地定义你的领域，更快地完成我们产品的第一个版本，以获得用户的早期反馈。将代码组织成模块的良好实践列表应该有助于您在需要时进行拆分。但是我们也看到了有时候一个小的整体并不是最好的主意，特别是如果开发团队从一开始就很大的话。

决定迁移到微服务(或从微服务开始)需要对系统的功能和非功能特性进行深入分析，以确定在可伸缩性、容错性、事务性、最终一致性等方面的需求。该决策对于软件项目的成败至关重要。我希望本章中包含的所有考虑事项，以及实际案例的支持，能够帮助您仔细检查项目中存在的所有因素，并在您采取行动时做出合理的决定和良好的计划。

正如本书所料，我们决定采用微服务架构。在实践方面，我们浏览了新游戏化应用程序的各个层:服务、存储库、控制器和新的 React 组件。我们使用简单的*命令式*方法将乘法与游戏化联系起来，并且我们使用我们的微服务之间的接口来发现我们在微服务架构方面面临的一些新挑战。

到本章结束时，我们还得出结论，我们选择的用于通信两个微服务的同步接口是错误的决定。它引入了紧密耦合，并使我们的架构容易出错。这是下一章的完美基线，在下一章中，我们将介绍事件驱动架构的优势。

**章节成就:**

*   您看到了小型整体方法在启动新项目时如何帮助您。

*   您已经初步接触了微服务架构的优缺点(您将在接下来的章节中继续学习)。

*   您了解了分布式系统中同步和异步处理之间的差异，以及它们与最终一致性的关系。

*   您了解了为什么在微服务架构中采用这些新范式(异步流程、最终一致性)以避免紧密耦合和域污染非常重要。

*   您看到了为什么微服务不是所有情况下的最佳解决方案(例如，如果您需要事务性和即时数据一致性)。

*   您确定了我们在实际案例中面临的第一个挑战，并看到了当前的实施方式并不是实施微服务的正确方式。****