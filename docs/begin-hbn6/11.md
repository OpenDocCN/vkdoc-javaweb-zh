# 11.整合到网络中

我们已经看到了很多关于*如何使用* Hibernate 的内容，包括一系列的示例模型，但是没有一个真正展示了 Hibernate 在“真实世界”中的用法我们所有的运行代码都被嵌入到测试中，这对开发来说并不是一件坏事，但这并不是一个明确如何将 Hibernate 集成到人们可能会使用的应用程序中的好方法。

测试是一个很好的例子，说明你在“深层代码”、后端服务或嵌入式应用程序中会看到什么，它们不会直接向最终用户公开 Hibernate 对象——事实上，大多数现代开发人员会建议直接向用户公开 Hibernate 实体是一个坏主意。 <sup>[1](#Fn1)</sup>

因此，让我们深入一个 web 应用程序，展示 Hibernate 实际上是如何集成的。

将 Hibernate 集成到 web 应用程序中有很多方法，而最佳方法几乎完全取决于部署架构的选择。我们将从非常简单的东西开始，在那里我们控制一切，然后我们将尝试涵盖你在“真实世界”中遇到的更复杂的场景

## 搭建舞台

Java 中的 Web 应用程序最初是围绕“servletss”的思想构建的，servlet 基本上是生成对 HTTP 调用的响应的类。这种模式仍然主导着 web 应用程序的设计，尽管实际的交付方式已经发生了很大的变化。

这个想法是系统将运行一个*容器*，一个被设计用来管理模块化应用程序的应用程序，它使用一个被称为 Java 2 企业版、 <sup>[2](#Fn2)</sup> 的规范，旨在为那些应用程序提供服务以支持特定的功能。例如，像 Tomcat 这样的 web 容器会为 web *模块*提供一个 API，这样就可以用一个集中的控制面板来控制它们，并且像 JDBC 连接这样的资源和其他东西可以在运行时提供给这些模块。

这些模块实现功能的方式最初是通过 servletss 的**，模块将 servlet 映射到特定的 URL。Web 浏览器(或任何其他应用程序)将使用这些 URL 和各种 HTTP 方法，如`GET`和`POST`来运行 servlets 中的代码。**

 **那是一个更简单的世界，虽然那种机制起作用(而且，就其本身而言)，但它并不是最吸引人的开发过程；如果您想查看客户列表，您的 servlet 必须呈现 HTML，这相当冗长且容易出错。

库的出现使它变得简单了一点(例如，Apache ECS， <sup>[3](#Fn3)</sup> 等等)，但是实际上构建一个 web 应用程序有太多的顾虑；您必须了解 web 模块配置，加上编写 servlet 的功能，再加上将渲染结果编写成 HTML…如果您在显微镜下观察这个过程，这并不是很大的负担，但实际上它给大多数开发人员带来了相当大的负担，而附加值相对较小；大多数网站都没有达到值得努力的流量水平。

自然，社区以多种有益的方式做出了回应(嗯，大部分是有益的)。模型-视图-控制器范式变得非常普遍，在 Struts 和 WebWork 之类的库的帮助下，servlets 只是协调数据处理发生后呈现什么视图。出现了像 JavaServer Pages 这样的渲染引擎，以及像 Velocity 和 Thymeleaf 这样的模板引擎，这甚至还没有开始描述思想和方法的大规模扩散；您可以使用 JVM，用 web 应用程序编程的书籍单独构建一个库，新的框架会不断涌现，具有各种各样的优势。 <sup>[4](#Fn4)</sup>

除此之外，配置也变得更加简单。Spring 框架继承了 Java EE 的重量级特性，并彻底改变了它，强调更容易的部署、配置和开发。更重要的是，由于 Java 在很大程度上是由社区驱动的，Spring 为架构所做的事情被纳入到 Java EE 规范中，就像 Hibernate 对 JPA 所做的一样， <sup>[5](#Fn5)</sup> 就像用 Hibernate 影响 JPA 来为数据库建模 Java 类变得更好一样，使用 Spring 和其他库来影响 Java EE 中以 web 为中心的 API，web 应用程序开发变得更加容易。

## 计划

遗憾的是，这本书不是关于 web 应用程序开发的，而且无论如何也没有合理的方法可以让一本书很好地涵盖 Java 中的 web 开发。尽管如此，在 web 应用程序中使用 Hibernate 有一些常见的问题，我们可以解决。

我们将使用 Servlets 开发一个 web 应用程序，其中的某些方面*将无法正常工作*，因为目的是展示一些问题及其解决方案。本质上，我们不打算设计一个用户界面；这不仅不是你的作者的技能范围，而且是次要问题。我们在这里编写的 servlets 将生成 JSON，它适合使用运行在浏览器中的客户端应用程序进行渲染；人们可以用 Angular、React 或任何数量的其他 JavaScript 框架来编写这样的应用程序。

该项目将使用嵌入式 servlet 引擎(Undertow，位于 [`https://undertow.io/`](https://undertow.io/) )进行测试，但也可以部署在任何兼容的 Java EE 容器中——您可以在 Tomcat、WildFly、Open Liberty 或任何其他您喜欢的引擎中随意尝试。同样，该应用程序的某些部分预计不会正常工作，但这是为了说明问题。

再次声明，这不是关于 web 开发的章节，而是关于在 web 开发中使用 Hibernate *的章节。在本章中，我们不会使用最新、最热门的技术——当涉及到 web 时，我们有目的地降低目标，因为获取我们将要学习的经验并将其应用于更高级的 Web 框架是微不足道的，并且通过关注简单性，我们可以避免陷入大量配置或框架术语中。*

## 应用程序

我们将设计最普通的应用程序，博客。

当然，博客是一种“网络日志”，是一种在线日志，这样的应用程序主宰着网络。如今，大多数博客都托管在大型服务器农场上，如 Medium ( [`https://medium.com`](https://medium.com) )和 Substack ( [`https://substack.com`](https://substack.com) )，而大多数个人托管的博客都在软件平台上，如 WordPress ( [`https://wordpress.org/`](https://wordpress.org/) )或使用静态站点生成器，如 Jekyll 或 Hugo。 <sup>[6](#Fn6)</sup>

我们不会为其中任何一项打造竞争对手。然而，我们将受到作者写有评论的帖子的模式的启发。一个有事业心的读者理论上可以增加安全性(一个需求)和功能性用户界面(另一个需求),然后构建一些有价值的东西。

所以让我们开始吧。

### 项目模型

首先，我们需要有我们的项目模型。这将包括我们已经看到的许多依赖项，但`packaging`将是`war`——因为这将生成一个“web 归档”——它还将包括 Undertow 和 Jackson。

Undertow 是 JBoss 中使用的 servlet 引擎；Jackson ( [`https://github.com/FasterXML/jackson`](https://github.com/FasterXML/jackson) )是一个数据处理库，我们将用它来读写 JSON。我们还将需要`jackson-datatype-jsr310`作为依赖项，因为，正如我们很快就会看到的，我们正在使用日期和时间 API 中的一些时间戳类型。 <sup>[7](#Fn7)</sup> 我们还包括我们的`util`库来处理`Session`的获取和管理，而 Lombok 将为我们节省很多样板文件。

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
          http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <parent>
    <groupId>com.autumncode.books.hibernate</groupId>
    <artifactId>hibernate-6-parent</artifactId>
    <version>5.0</version>
  </parent>
  <modelVersion>4.0.0</modelVersion>
  <packaging>jar</packaging>

  <properties>
    <war.name>chapter11</war.name>
    <undertow.version>2.2.8.Final</undertow.version>
  </properties>

  <artifactId>chapter11</artifactId>

  <dependencies>
    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
    </dependency>
    <dependency>
      <groupId>com.autumncode.books.hibernate</groupId>
      <artifactId>util</artifactId>
      <version>${project.parent.version}</version>
    </dependency>
    <dependency>
      <groupId>io.undertow</groupId>
      <artifactId>undertow-core</artifactId>
      <version>${undertow.version}</version>
    </dependency>
    <dependency>
      <groupId>io.undertow</groupId>
      <artifactId>undertow-servlet</artifactId>
      <version>${undertow.version}</version>
    </dependency>
    <dependency>
      <groupId>com.h2database</groupId>
      <artifactId>h2</artifactId>
    </dependency>
    <dependency>

      <groupId>ch.qos.logback</groupId>
      <artifactId>logback-classic</artifactId>
    </dependency>
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
    </dependency>
    <dependency>
      <groupId>com.fasterxml.jackson.datatype</groupId>
      <artifactId>jackson-datatype-jsr310</artifactId>
    </dependency>
  </dependencies>
  <build>
    <finalName>${war.name}</finalName>
  </build>
</project>

Listing 11-1chapter11/pom.xml

```

### 数据模型

我们有三个要处理的实体，都在`chapter11.model`包中:`User`、`Post`和`Comment`。一个`User`可以有许多`Post`和`Comment`条目，一个`Post`有许多`Comment`实体。在每一个中，我们都覆盖了 Lombok 的`toString()`,因为我们想确保不会无意中引用集合。(我们根本不希望 Lombok 输出集合。)

我们不太可能*经常使用* `toString()`，但是它对“目测”结果很有用。如果您在代码中跟随，或者当您开发您自己的模型时，您可能会像您的作者一样，在运行您的测试时使用日志来查看值。

![../images/321250_5_En_11_Chapter/321250_5_En_11_Fig1_HTML.jpg](../images/321250_5_En_11_Chapter/321250_5_En_11_Fig1_HTML.jpg)

图 11-1

博客的实体关系图

首先，我们来看看`User`。我们将`posts`初始化为一个空的`ArrayList`；我们可能不需要这样做，除非我们发现自己在设计一个过程，通过这个过程，我们在用户被持久化之前向用户添加一个`User`和帖子，实际上，这样初始化帖子列表本质上是防御性的。(举例来说，这可以防止我们在保存之前无意中引用了帖子列表中的一个`null`。)

```
package chapter11.model;

import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Entity
@Data
@NoArgsConstructor
public class User {
  @Id

  @GeneratedValue(strategy = GenerationType.AUTO)
  Integer id;

  @Column(unique = true, nullable = false)
  String name;
  boolean active;

  @OneToMany(fetch = FetchType.LAZY)
  @JoinColumn(name = "user_id")
  @OrderBy("createDate")
  List<Post> posts = new ArrayList<>();

  public User(String name, boolean active) {
    this.name = name;
    this.active = active;
  }

  @Override
  public String toString() {
    return "User{" +
      "id=" + id +
      ", name='" + name + '\'' +
      ", active=" + active +
      '}';
  }
}

Listing 11-2chapter11/src/main/java/chapter11/model/User.java

```

这里的`toString()`相当普通，但是我们从 Lombok 的`toString()`中覆盖了它，因为 Lombok 默认包含每个属性。一般来说，这没什么问题，但是如果我们使用 Hibernate 实体——也就是从 Hibernate 加载的对象——那么我们最终会冒着在一个`Session`关闭后需要初始化惰性集合的风险，这意味着访问`posts`可能会导致我们获得一个`org.hibernate.LazyInitializationException`。

要求会话在任何时候都在范围内——或者，好吧，当我们应该完成对`Session`的访问时——是本章的主要关注点之一。

`Post`是我们拥有的三个实体中最有趣的一个，因为它使用了 Hibernate 过滤器定义。我们先来看一下，然后在一些有趣的方面游走。

```
package chapter11.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.*;

import javax.persistence.*;
import javax.persistence.OrderBy;
import java.time.*;
import java.util.ArrayList;
import java.util.List;

@Entity
@Data

@NoArgsConstructor
@FilterDefs({
  @FilterDef(
    name = "byTerm",
    parameters = @ParamDef(name = "term", type = "string")),
  @FilterDef(
    name = "byName",
    parameters = @ParamDef(name = "name", type = "string")
  )
})
@Filters({
  @Filter(name = "byTerm",
    condition = "title like :term"),
  @Filter(name = "byName",
    condition = "user_id = (select u.id from User as u where u.name=:name)"),
})
public class Post {
  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  Integer id;

  @Column(nullable = false)
  String title;

  @Column(nullable = false)
  @Lob

  String content;

  @ManyToOne
  User user;

  @OneToMany(fetch = FetchType.LAZY)
  @JoinColumn(name = "post_id")
  @OrderBy("createDate")
  List<Comment> comments = new ArrayList<>();

  @Temporal(TemporalType.TIMESTAMP)
  @Column(nullable = false)
  LocalDateTime createDate;

  @Override
  public String toString() {
    return "Post{" +
      "id=" + id +
      ", title='" + title + '\'' +
      ", content='" + content + '\'' +
      ", user=" + user +
      ", createDate=" + createDate +
      '}';
  }

}

Listing 11-3chapter11/src/main/java/chapter11/model/Post.java

```

我们实际上有两个过滤器:`byTerm`和`byName`。

第一个是`byTerm`，是一个相当简单的单词搜索过滤器，更多的是作为一个占位符，而不是一个实际的搜索工具；它包括任何标题包含通配符的`Post`，即过滤器名称中的“term”。

`byName`滤镜更有趣一点。它实际上包括任何其`user_id`字段与具有给定名称的`User`相匹配的`Post`——因此，它通过用户名为任何`Post`提供过滤器。之所以这样写是因为它是一个*过滤器*而不是一个*查询*；编写一个 HQL 查询来实现相同的目标可能会更容易，但是当我们开始使用过滤器时，过滤器的原因就足够清楚了。

JPA 有一个标准查询 API，它提供了与 Hibernate 过滤器相似的特性。然而，尽管过滤器可能变得冗长，但它们仍然比标准查询冗长得多，并且它们需要较少的设置工作。

我们的最后一个实体是`Comment`，在看过`Post`和`User`之后，它看起来有点普通和无聊。

```
package chapter11.model;

import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import java.time.LocalDateTime;

@Entity
@Data
@NoArgsConstructor
public class Comment {
  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  Integer id;

  @Column(nullable = false)
  @Lob
  String content;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "post_id")
  Post post;

  @ManyToOne(optional = false, fetch = FetchType.LAZY)
  @JoinColumn(name = "user_id")
  User user;

  @Temporal(TemporalType.TIMESTAMP)

  @Column(nullable = false)
  LocalDateTime createDate;

  @Override
  public String toString() {
    return "Comment{" +
      "id=" + id +
      ", content='" + content + '\'' +
      ", createDate=" + createDate +
      '}';
  }
}

Listing 11-4chapter11/src/main/java/chapter11/model/Comment.java

```

如果没有 Hibernate 配置，我们就不能拥有 Hibernate 应用程序，所以它在这里；注意，除了实际的特定映射之外，它与所有其他的都非常相似。它也位于`src/main/resources`而不是`src/test/resources`中，主要是因为我们希望我们的可部署工件是完整的和可部署的；如果 Hibernate 配置位于`test`树中，它就不是可部署工件的一部分。

```
<?xml version="1.0"?>
<!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
  <session-factory>
    <!--  Database connection settings  -->
    <property name="connection.driver_class">org.h2.Driver</property>
    <property name="connection.url">jdbc:h2:./db11</property>
    <property name="dialect">org.hibernate.dialect.H2Dialect</property>

    <!--  Echo all executed SQL to stdout  -->
    <property name="show_sql">true</property>
    <property name="use_sql_comments">true</property>

    <!--  Drop and re-create the database schema on startup  -->
    <property name="hbm2ddl.auto">create-drop</property>

    <mapping class="chapter11.model.User"/>
    <mapping class="chapter11.model.Post"/>
    <mapping class="chapter11.model.Comment"/>
  </session-factory>
</hibernate-configuration>

Listing 11-5chapter11/src/main/resources/hibernate.cfg.xml

```

### 构建我们的第一个 Servlet 测试

接下来，我们要看看可能是整章中最长的类，我们的`TestBase` servlet。

实际上，有很多方法可以解决为 web 应用程序编写代码的问题。最优选的方法是编写映射到我们的用户故事的服务——像“添加用户”或“添加帖子”这样的功能——然后使用 servlets 调用这些服务。

这个模型实际上工作得非常好，但是它确实设法自然地将您与在分布式应用程序中使用 Hibernate 的一些架构问题隔离开来。当您像这样分离关注点时——“添加用户”在一个完全独立的类中——您有一个自然的事务边界，并且很容易意外地正确和干净地做事情。我们将在后续章节中使用该模型，但我们需要理解为什么我们将做出的一些选择存在，所以现在我们要做一些稍微次优的事情。

但是，结果是，我们的测试不能只关注服务——我们需要建立一个实际的 web 服务器，使用实时的 servlets。这不是一个完全的集成测试， <sup>[8](#Fn8)</sup> 但是它*实际上使用一个真正的 HTTP 客户端(Java 11 中包含的那个)并发出真正的 HTTP 请求；如果您愿意，您可以手动做与测试完全相同的事情。*

 *那么，我们的`TestBase`有很多角色:它需要启动(和停止)逆流，以及注册一系列 servlets。它还需要提供一种简单的方法来发出 HTTP 请求，并构建一种简单的方法来将 JSON 映射到可导航的数据结构中。

我们不需要使它完美，只要对我们的目的足够好就行了。通过各种方式让`TestBase`变得更好并不需要付出太多的努力，但它已经够长了。

`TestBase`中的大部分复杂性存在于`populateServlets()`方法中，它制造了一个`DeploymentInfo`。它加载一个名为`servlets.json`的 JSON 文件，其中包含一个 JSON 字典；每个条目都是一个 servlet，它有关于每个条目的数据，比如 Servlet 的实现类和 URL，以及它可能使用的任何初始化参数。

这里是`TestBase.java`类，我们将在其后立即包含`servlets.json`，这样您就可以看到它的结构。 <sup>[9](#Fn9)</sup>

```
package chapter11.servlets;

import chapter11.model.Comment;
import chapter11.model.Post;
import chapter11.model.User;
import com.autumncode.hibernate.util.SessionUtil;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import io.undertow.Handlers;
import io.undertow.Undertow;
import io.undertow.server.handlers.PathHandler;
import io.undertow.servlet.Servlets;
import io.undertow.servlet.api.DeploymentInfo;
import io.undertow.servlet.api.DeploymentManager;
import org.hibernate.query.Query;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.BeforeMethod;

import javax.servlet.Servlet;
import javax.servlet.ServletException;
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.Map;

public class TestBase {
  Undertow server;
  TypeReference<Map<String, Object>> mapOfMaps =
    new TypeReference<>() {
    };
  protected ObjectMapper mapper = new ObjectMapper()
    .setSerializationInclusion(JsonInclude.Include.NON_NULL)
    .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
  {
    mapper.registerModule(new JavaTimeModule());
  }

  @BeforeClass
  void start() throws ServletException, IOException {
    DeploymentInfo servletBuilder = Servlets.deployment()
      .setClassLoader(TestBase.class.getClassLoader())
      .setContextPath("/myapp")
      .setDeploymentName("test.war");
    populateServlets(servletBuilder);

    DeploymentManager manager = Servlets
      .defaultContainer()
      .addDeployment(servletBuilder);
    manager.deploy();
    PathHandler path = Handlers.path(Handlers.redirect("/myapp"))
      .addPrefixPath("/myapp", manager.start());
    server = Undertow.builder()
      .addHttpListener(8080, "localhost")
      .setHandler(path)
      .build();
    server.start();
  }

  private void populateServlets(DeploymentInfo servletBuilder)
    throws IOException {
    Map<String, Object> servlets = mapper
      .readValue(
        this
          .getClass()
          .getResourceAsStream("/servlets.json"
          ), mapOfMaps);
    servlets.entrySet().forEach(entry -> {
      Map<String, Object> data =
        (Map<String, Object>) entry.getValue();
      try {
        var servlet = Servlets.servlet(
          entry.getKey(),
          (Class<? extends Servlet>) Class.forName(
            data.get("class").toString()
          ));

        if (data.containsKey("initParams")) {
          Map<String, Object> params =
            (Map<String, Object>) data.get("initParams");
          params.entrySet().forEach(param -> {
            servlet.addInitParam(
              param.getKey(),
              param.getValue().toString()
            );
          });
        }
        servlet.addMapping(data.get("mapping").toString());
        servletBuilder.addServlets(servlet);
      } catch (ClassNotFoundException e) {
        e.printStackTrace();
      }
    });
  }

  @AfterClass
  void stop() {
    server.stop();
  }

  @BeforeMethod
  void clearAll() {
    SessionUtil.doWithSession(session -> {
      Query<Comment> commentQuery =
        session.createQuery("from Comment", Comment.class);
      for (var obj : commentQuery.list()) {
        session.delete(obj);
      }

      Query<Post> postQuery =
        session.createQuery("from Post", Post.class);
      for (Post post : postQuery.list()) {
        session.delete(post);
      }

      Query<User> query =
        session.createQuery("from User", User.class);
      for (User user : query.list()) {
        session.delete(user);
      }
    });
  }

  protected HttpResponse<String> issueRequest(String path)
    throws IOException, InterruptedException {
    HttpClient client = HttpClient.newBuilder().build();
    HttpRequest request = HttpRequest.newBuilder()
      .uri(URI.create("http://localhost:8080/myapp/" + path))
      .timeout(Duration.ofSeconds(3))
      .build();
    HttpResponse<String> response =
      client.send(request, HttpResponse.BodyHandlers.ofString());
    return response;
  }
}

Listing 11-6chapter11/src/test/java/chapter11/servlets/TestBase.java

```

这是一个相当大的类，与我们到目前为止所拥有的许多源文件相比，但是它并不特别复杂。大部分都与设置我们的 servlets 有关，但是它也清理了数据库，并且有一个方便的方法来发出 HTTP 请求。

`mapper`引用为我们提供了一种简单的方法来正确测试带有日期的序列化数据。

`start()`方法在每个测试类之前运行，启动 Undertow servlet 引擎，还有`populateServlets()`，它使用一个 JSON 文件构建一个入口点列表，我们接下来会看到。它使用原始的 JSON 结构，这并不理想；通常，我们会构建一个对象模型，并使用 *that* ，但是我们试图选择更少的类。

`stop()`方法在每个测试类测试后运行，并关闭 Undertow 服务器。

`clearAll()`方法清理所有的数据，因为它被标记为`@BeforeMethod`，所以它在每次测试之前运行；从数据的角度来看，每个测试都是从一张白纸开始的。

最后，`issueRequest()`提供了一种简单的方法来构建用于测试的 HTTP 请求。这是荒谬的简单；它只处理请求路径，不进行参数化，并且只处理 HTTP `GET`请求。然而，它*确实*去除了许多直接发出请求的样板文件。

那么，为什么连*都有*呢？毕竟，我们不需要*使用* HTTP 作为传输协议；我们可以拥有执行 servlet 提供的动作的类，并直接调用这些类。服务器或协议不需要*或*。尽管如此，协议障碍是我们试图证明的东西，所以所有的设置都是为了说明在某种“真实世界”情况下的架构边界，如 HTTP 的使用，即使在“真实世界”中没有人会合理地手动进行任何操作。

这里是本章使用的实际的`servlets.json`文件，包括了每个 servlet。(如果您在阅读时手动构建了本章的代码库，那么您会想要参考这个清单，而不是大量使用它，直到您实现了所有的 servlets。)

```
{
  "HelloServlet": {
    "class": "chapter11.servlets.HelloWorld",
    "initParams": {
      "message": "Hello World"
    },
    "mapping": "/hello"
  },
  "BadAddUserServlet": {
    "class": "chapter11.servlets.BadAddUserServlet",
    "mapping": "/badadduser"
  },
  "AddUserServlet": {
    "class": "chapter11.servlets.AddUserServlet",
    "mapping": "/adduser"
  },
  "SimpleGetPostsServlet": {
    "class": "chapter11.servlets.SimpleGetPostsServlet",
    "mapping": "/simplegetposts"
  },

  "AddPostServlet": {
    "class": "chapter11.servlets.AddPostServlet",
    "mapping": "/addpost"
  },
  "GetPostsServlet": {
    "class": "chapter11.servlets.GetPostsServlet",
    "mapping": "/getposts"
  },
  "GetPostServlet": {
    "class": "chapter11.servlets.GetPostServlet",
    "mapping": "/getpost"
  },
  "AddCommentServlet": {
    "class": "chapter11.servlets.AddCommentServlet",
    "mapping": "/addcomment"
  }
}

Listing 11-7chapter11/src/test/resources/servlets.json

```

我们的 servlets 被设计成发出 JSON，具体来说，这听起来是创建一个`ServletBase`、一个抽象的`HttpServlet`实现的理想理由，它提供了一种将`Object`写成 JSON 的便捷方式。

```
package chapter11.servlets;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.*;

abstract class ServletBase extends HttpServlet {
  protected ObjectMapper mapper = new ObjectMapper()
    .setSerializationInclusion(JsonInclude.Include.NON_NULL)
    .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
  {
    mapper.registerModule(new JavaTimeModule());
  }

  /* simple validation of parameters */
  protected Map<String, String> getValidatedParameters(
    HttpServletRequest req,
    String... fields
  ) {
    Map<String, String> map = new HashMap<>();
    List<String> badFields = new ArrayList<>();
    for (String fieldName : fields) {
      String value = req.getParameter(fieldName);
      if (value == null || value.isEmpty()) {
        badFields.add(fieldName);
      } else {
        map.put(fieldName, value);
      }
    }
    if (badFields.size() > 0) {
      throw new RuntimeException(
        "bad fields provided: " + badFields
      );
    }
    return map;
  }

  /* write out a valid response */
  protected void write(
    HttpServletResponse r,
    int code,
    Object entity
  ) throws IOException {
    r.setContentType("application/json");
    r.setStatus(code);
    r.getWriter().write(mapper
      .writerWithDefaultPrettyPrinter()
      .writeValueAsString(entity)
    );
  }

  /* write out an exception */
  protected final void writeError(
    HttpServletResponse resp,
    Throwable throwable
  ) throws IOException {
    write(resp,
      HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
      Map.of("error", throwable.getMessage())
    );
  }
}

Listing 11-8chapter11/src/main/java/chapter11/servlets/ServletBase.java

```

我们使用`setSerializationInclusion(JsonInclude.Include.NON_NULL)`是因为我们希望在序列化数据时忽略包含`null`的字段。这个*重要吗*？嗯，不在这里；毕竟，我们没有真正的用户界面，而且我们拥有的*总计*字段的数量如此之少，以至于包含一些对空数据的引用在任何情况下都无关紧要。尽管如此，这允许一个*潜在的*用户界面检查字段的存在，而不必检查字段是否为空*。这只是防御性编程。*

 *我们还禁用了`WRITE_DATES_AS_TIMESTAMPS`特性，因为我们使用了`LocalDateTime`并且我们真的希望它以人类可读的形式编写。不过，要做到这一点，我们需要在 Jackson 中注册`JavaTimeModule()`，这是用初始化器块完成的。

我们还有一个`getValidatedParameters()`方法，该方法返回字段名及其值的一个`Map<String, String>`——如果一个字段没有被提供(并且是必需的),则抛出一个`RuntimeException`。这是非常原始的做法，有更好的方法。

接下来，我们有`write()`和`writeError()`方法，它们为我们的输出以标准形式格式化输出。

`ServletBase`是*功能正常*但不太*好的*。您可能不想在这个层次上编写 servlets，但是有时理解底层技术在做什么是很重要的。

我们在`servlets.json`中看到的第一个 servlet 是一个“Hello，World”servlet，名为“HelloServlet”，在一个名为`HelloWorld`的类中实现。这是一个简单的 servlet，它验证我们的 Undertow 实例是否工作，并使用我们的`ServletBase`写入输出。

```
package chapter11.servlets;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

public class HelloWorld extends ServletBase {
  @Override
  protected void doGet(
    HttpServletRequest request,
    HttpServletResponse response)
    throws IOException {
    Map<String, String> data=Map.of(
      "response", this.getInitParameter("message")
    );
    write(response, HttpServletResponse.SC_OK, data);
  }

}

Listing 11-9chapter11/src/main/java/chapter11/servlets/HelloWorld.java

```

这里有两件有趣的事情。一个是使用一个“init 参数”来获取响应的值(在`servlets.json`的`<initParams>`节点中提供)，另一个是我们首先构建一个`Map<String, String>`来生成响应；JSON 是一个数据结构，我们不能用 JSON 写一个简单的字符串作为输出。当然，我们可以直接编写输出，但是我们正在尝试实际测试我们的应用程序将使用的管道。

我们现在需要*测试*我们的`HelloWorld` servlet。有了`TestBase`，我们可以创建一个`HelloWorldTest`，看起来像清单 [11-10](#PC10) 中所示的那个。

```
package chapter11.servlets;

import org.testng.annotations.Test;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.net.http.HttpResponse;
import java.util.Map;

import static org.testng.Assert.assertEquals;

public class HelloWorldTest extends TestBase {
  @Test
  public void testHelloWorld()
    throws IOException, InterruptedException {
    HttpResponse<String> response =
      issueRequest("hello");

    Map<String, Object> data =
      mapper.readValue(response.body(), mapOfMaps);

    assertEquals(
      response.statusCode(),
      HttpServletResponse.SC_OK

    );
    assertEquals(
      data.get("response"),
      "Hello World"
    );
  }
}

Listing 11-10chapter11/src/test/java/chapter11/servlets/HelloWorldTest.java

```

我们的`HelloWorldTest`真的非常简单:在通过`TestBase`初始化之后，它发出一个请求(通过晦涩命名的`issueRequest()`方法，保存在`TestBase`中)，返回一个`String`——一个应该包含 JSON 的字符串。

然后，我们通过保存在`TestBase`中的`mapper`实例对其进行解析，并验证响应代码是否为`SC_OK`(即 200，表示请求成功的 HTTP 代码)，以及 JSON map 是否有一个名为`response`的属性，其值为`Hello World`。

我们*可以*创建一个包含`response`字段的对象，并将我们的 JSON 映射到该对象，而不是使用我们在这里演示的“映射的映射”方法。更重要的是，这可能是做这件事的“正确方法”,我们将在下一个例子中看到这样的例子；我们在这里避免了它，因为它只是*另一件需要解释的事情*。我们已经引入了足够多的新概念。如果我们把它们分开一些会更好。

这种发出请求并检查响应的模式将在我们的测试中重复出现。

### 我们的第一个(错误的)Servlet:添加用户

让我们创建一个 servlet 来向系统添加一个新用户。在其中，我们将接受一个用户名，并检查该用户是否已经存在；如果用户不存在，我们将创建用户，然后将用户作为 JSON 返回。

这个过程表面上看起来是正确的。然而，这个代码是错误的。我们很快就会看到原因。

```
package chapter11.servlets;

import chapter11.dto.UserDTO;
import chapter11.model.User;
import com.autumncode.hibernate.util.SessionUtil;
import org.hibernate.Session;
import org.hibernate.query.Query;

import javax.persistence.NoResultException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

public class BadAddUserServlet extends ServletBase {
  @Override
  protected void doGet(
    HttpServletRequest req,
    HttpServletResponse resp
  )
    throws ServletException, IOException {
    try {
      Map<String, String> input =
        getValidatedParameters(req, "userName");

      User user = SessionUtil.returnFromSession(
        session -> createUser(session, input.get("userName"))
      );
      write(resp,
        HttpServletResponse.SC_OK,
        user);
    } catch (Exception e) {
      writeError(resp, e);
    }
  }

  private User createUser(Session session, String userName) {
    User entity;
    try {
      Query<User> query = session.createQuery(
        "from User u where u.name=:name",
        User.class);
      query.setParameter("name", userName);

      entity = query.getSingleResult();
    } catch (NoResultException nre) {
      entity = new User(userName, true);
      session.save(entity);
    }

    return entity;
  }
}

Listing 11-11chapter11/src/main/java/chapter11/servlets/BadAddUserServlet.java

```

我们的 servlet 功能的入口点是`doGet()`，它映射到用于调用 Servlet 的 HTTP 方法。(因此，它响应`GET`请求，出于我们的目的，其他方法将被忽略。)它使用`getValidatedParameters()`来验证参数。

然后，它创建一个`User`引用，并通过调用`createUser()`来调用`SessionUtil.returnFromSession()`。在那之后，除了异常处理之外，实际上没什么可做的了:它将`User`引用写入输出。

然而，用来获取`User`的机制是这个 servlet 失败的地方。

我们的设计是返回映射到周期`userName`的`User`。如果`User`已经存在，它从数据库加载用户并返回*那个*。(从整体来看，这是否明智还存在争议；对于一个“真正的应用程序”，您不会像这样返回一个现有的用户，以防有人发送“添加用户”功能来查找现有的用户名。)

错误很简单:我们使用的 JSON 库 Jackson 将遍历`User`中的每个属性，并在 JSON 中为它创建一个表示。然而，如果用户是由`createUser()`创建的，那么`User`的`posts`引用被设置为一个简单的`ArrayList`——但是如果它是从数据库加载的，那么`posts`引用实际上是一个代理值，映射`User`的尝试将导致 Hibernate 尝试从数据库加载`Post`列表。

然而，映射发生在λ存在的之后的*:`Session`不再活动，因此我们将得到一个`LazyInitializationError`。*

这是我们的测试类，它实际上练习了 Servlet 中的大部分代码。

```
package chapter11.servlets;

import org.testng.annotations.Test;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.net.http.HttpResponse;

import static org.testng.Assert.assertEquals;

public class BadAddUserServletTest extends TestBase{
  String getServletName() {
    return "badadduser";
  }

  @Test
  void emptyUserNameProvided()
    throws IOException, InterruptedException {
    HttpResponse<String> response =
      issueRequest(getServletName()+"?userName=");
    System.out.println(response.body());

    assertEquals(
      response.statusCode(),
      HttpServletResponse.SC_INTERNAL_SERVER_ERROR
    );
  }

  @Test
  void noUserNameProvided()
    throws IOException, InterruptedException {
    HttpResponse<String> response =
      issueRequest(getServletName());
    System.out.println(response.body());

    assertEquals(
      response.statusCode(),
      HttpServletResponse.SC_INTERNAL_SERVER_ERROR
    );
  }

  @Test
  void runAddUser()
    throws IOException, InterruptedException {
    HttpResponse<String> response =
      issueRequest(getServletName()+"?userName=ts");
    System.out.println(response.body());

    assertEquals(
      response.statusCode(),
      HttpServletResponse.SC_OK
    );

    response = issueRequest("badadduser?userName=ts");
    assertEquals(
      response.statusCode(),
      HttpServletResponse.SC_INTERNAL_SERVER_ERROR
    );
  }
}

Listing 11-12chapter11/src/test/java/chapter11/servlets/BadAddUserServletTest.java

```

首先，它有一个`emptyUserNameProvided`——这将触发一个验证错误，就像根本不提供`userName`参数一样，如`noUserNameProvided`测试所示。(它使用`getServletName()`是因为我们想在另一个测试中重用其中的一些方法，除了另一个 servlet。)

然后我们进入`runAddUser`测试，该测试调用我们的 servlet *两次*:一次是首先添加用户，然后取回同一个用户*……除了第二次调用失败并出错，这是因为惰性初始化。我们不测试实际的异常；我们*可以*，因为我们控制着 servlet 的源代码，但是在实践中，人们通常不会向最终用户公开原始的应用程序异常，这不会是一个“可测试的结果”(您可以将这样的异常转换成对用户来说更可展示的东西，并测试*和*内容。)*

### AddUserServlet，已更正

理论上，我们有几种方法可以解决`BadAddUserServlet`的问题。一种是用`@com.fasterxml.jackson.annotation.JsonIgnore`标记`posts`元素，这告诉 Jackson 忽略该属性。然而，可能有些情况下我们确实想要整个用户的历史；将字段标记为“忽略”感觉有点宽泛。

一个更好的解决方案可能是 <sup>[10](#Fn10)</sup> 使用一个叫做“数据传输对象”的东西，这个类的目的纯粹是为了在架构边界之间进行传输。

例如，在这种情况下，我们不关心`posts`——事实上，我们也不想要它们，因为加载一个活跃用户的帖子集可能需要相当长的时间。因此，我们的数据传输对象，或 DTO，将只有来自`User` : `id`、`name`和`active`的我们真正关心的字段。清单 [11-13](#PC13) 展示了它可能的样子。

```
package chapter11.dto;

import lombok.Data;

@Data
public class UserDTO {
  int id;
  String name;
  boolean active;

  public UserDTO() {
  }

  public UserDTO(
    int id,
    String name,
    boolean active
  ) {
    this.id = id;
    this.name = name;
    this.active = active;
  }
}

Listing 11-13chapter11/src/main/java/chapter11/dto/UserDTO.java

```

我们给它一个惟一的名字`UserDTO`，因为当 DTO 和实体在同一个源文件中时，我们可能不得不使用完全限定的类名(即`chapter11.dto.User`)。

那么我们*将如何利用*它呢？好吧，这里有一个工作的`AddUserServlet`，写的结构和`BadAddUserServlet`几乎一模一样，除了用`UserDTO`来回传递数据，而不是用`User`。

```
package chapter11.servlets;

import chapter11.dto.UserDTO;
import chapter11.model.User;
import com.autumncode.hibernate.util.SessionUtil;
import org.hibernate.Session;
import org.hibernate.query.Query;

import javax.persistence.NoResultException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

import java.util.Map;

public class AddUserServlet extends ServletBase {
  @Override
  protected void doGet(
    HttpServletRequest req,
    HttpServletResponse resp
  )
    throws ServletException, IOException {
    try {
      Map<String, String> input =
        getValidatedParameters(req, "userName");

      UserDTO user = SessionUtil.returnFromSession(
        session -> createUser(session, input.get("userName"))
      );
      write(resp,
        HttpServletResponse.SC_OK,
        user);
    } catch (Exception e) {
      writeError(resp, e);
    }
  }

  protected UserDTO createUser(Session session, String userName) {
    User entity;
    try {
      Query<User> query = session.createQuery(
        "from User u where u.name=:name",
        User.class);
      query.setParameter("name", userName);

      entity = query.getSingleResult();
    } catch (NoResultException nre) {
      entity = new User(userName, true);
      session.save(entity);
    }

    UserDTO dto = new UserDTO();
    dto.setId(entity.getId());
    dto.setName(entity.getName());
    dto.setActive(entity.isActive());

    return dto;
  }

}

Listing 11-14chapter11/src/main/java/chapter11/servlets/AddUserServlet.java

```

我们*可以*使用不同类型的查询直接构建 DTO，而不是通过从`User`到`UserDTO`的映射。我们仍然需要能够**构造**一个`User`实体，这意味着我们仍然需要手动映射到一个`UserDTO`实例。在本章的剩余部分，我们不会遵循这种模式，但是这里有一个基于`AddUserServlet`的示例实现，覆盖了`createUser()`来展示这个过程。

```
package chapter11.servlets;

import chapter11.dto.UserDTO;
import chapter11.model.User;
import com.autumncode.hibernate.util.SessionUtil;
import org.hibernate.Session;
import org.hibernate.query.Query;

import javax.persistence.NoResultException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

public class AddUserServletDTO extends AddUserServlet {
  protected UserDTO createUser(Session session, String userName) {
    UserDTO dto;
    try {
      Query<UserDTO> query = session.createQuery(
        "select new chapter11.dto.UserDTO(u.id, u.name,u.active) "
        +"from User u where u.name=:name",
        UserDTO.class);
      query.setParameter("name", userName);

      dto = query.getSingleResult();
    } catch (NoResultException nre) {
      User u = new User(userName, true);
      session.save(u);
      dto = new UserDTO(u.getId(), u.getName(), u.isActive());

    }

    return dto;
  }

}

Listing 11-15chapter11/src/main/java/chapter11/servlets/AddUserServletDTO.java

```

如果您想使用*这个*类而不是`AddUserServlet`，您可以修改`servlets.json`来简单地引用这个类名。

自然要问是否管用。我们将继承来自`BadAddUserServletTest`的几乎所有东西，因为我们想要验证使用不正确的参数仍然会导致错误，但是我们将覆盖`runAddUser`来实际验证它获得了 HTTP 响应代码 200——这意味着成功的请求——而不是预期的错误。清单 [11-16](#PC16) 显示了来源。

```
package chapter11.servlets;

import org.testng.annotations.Test;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.net.http.HttpResponse;
import java.util.Map;

import static org.testng.Assert.assertEquals;

public class AddUserServletTest
  extends BadAddUserServletTest {
  String getServletName() {
    return "adduser";
  }

  @Override
  @Test
  void runAddUser()
    throws IOException, InterruptedException {
    HttpResponse<String> response =
      issueRequest("adduser?userName=jbo");

    Map<String, Object> data =
      mapper.readValue(response.body(), mapOfMaps);

    assertEquals(
      response.statusCode(),
      HttpServletResponse.SC_OK
    );

    response = SimpleGetPostsService.getSimplePosts();

    assertEquals(
      response.statusCode(),
      HttpServletResponse.SC_OK
    );
  }
}

Listing 11-16chapter11/src/test/java/chapter11/servlets/AddUserServletTest.java

```

现在我们可以说我们可以正确地添加用户了，使用我们对“添加用户”过程的定义:不管数据库是否被修改，它都会正确地返回一个`User`表示。

### dto 闪耀的地方

展示的经验法则很简单，它强化了我们在本书第 [3](03.html) 章的早期内容。从 Hibernate 加载的实体实际上是由*代理的*对象，只要它们由`Session`管理，它们的数据就会被填充。一旦实体与`Session`分离，它们的状态就固定了；如果他们的数据没有从数据库中加载，那么他们的数据*就不能从数据库中加载*，直到他们以某种方式再次连接到`Session`。

如果你没有从本章学到其他东西，那就从上一段吸取教训。这一章中有很多非常有趣的代码，尽管其中大部分对“真正的应用程序”来说用处有限，但是前面的段落是主要的要点。其他的都是证明和示范。

那么，这两种方法是在从实体被加载时返回之前完全加载实体**和创建实体的分离版本，这就是我们对`UserDTO`所做的。我们也可以用`User`的副本来完成:**

```
User user=Session.load(userId, User.class);
// we never use clone() in Java, right?
User copy=new User();
copy.setId(user.getId());
copy.setName(user.getName());
return copy;

```

通过创建一个新的*`User`而不是让它成为一个托管对象，这可以像使用`UserDTO`一样容易地避免惰性初始化问题。*

 *如果需要维护的类更少，为什么不使用创建实体的非托管实例的策略呢？没有一个真正好的、可靠的答案，尽管有一些促成因素。对我来说，这主要归结于目的；我希望班级有一个特定的角色。应该使用像`User`这样的实体类将数据映射到数据库或从数据库映射数据；使用它在 servlet 和富客户机之间传输数据是要求它做双重工作，在这种情况下，很容易忘记给定的类扮演什么角色；这个`User`实例是托管的，还是被用来序列化 JSON？

如果我使用一个`UserDTO`，那么这不是一个我必须问的问题；如果我正在序列化为 JSON，那就是一个`UserDTO`，句号。如果我从数据库中读取，它是一个`User`实体，我知道如果我像这样跨越架构边界，我需要来回转换。此外，我可以创建任意多的数据传输类型——如果我想要一个包含用户帖子的 DTO，我可以创建一个`UserPostsDTO`,或者如果我想要包含他们的评论，我可以创建一个`UserCommentsDTO`,并精确地控制数据。 <sup>[11](#Fn11)</sup>

### 完善应用程序

那我们该怎么办？应用程序需求的核心方面可能类似于

1.  创建用户(我们已经展示过了)

2.  创建帖子

3.  给帖子添加评论

4.  按日期获取帖子

5.  按用户获取帖子

6.  通过关键字获取帖子

大多数都很简单，尽管最后三个很有趣，因为它们将使用我们在`Post`实体中设置的过滤器。甚至很有可能将大量功能抽象成流程——毕竟，对于每一个流程，我们都要验证输入(以一种相当简单的方式),然后调用一个方法来生成输出。

实际上，对于读者来说，进行这种重构可能是一项值得做的工作，但是如果不进行重构，我们的清单将会很长，所以我们将直接进入。先来看看我们是怎么创建帖子的。

#### 创建帖子

根据我们的模型，为我们创建一个帖子包括帖子的内容和标题以及有效的用户参考。实现这一点的实际代码相当简单——测试将带来一些非常严重的影响。

例如，考虑获取有效用户引用的过程。我们的`AddUserServlet`有这样做的代码，它不是很长——19 行代码，带有打印的硬包装和到`UserDTO`的冗长转换。

在正常情况下，我们会创建一个服务类来保存我们的功能，所以我们会调用一个`getOrCreateUser()`方法，不管有没有`Session`——例如，我们在第 [3](03.html) 章中已经看到了这种模式。这给了我们容易嵌入的功能，而不必担心会话分界<sup>[12](#Fn12)</sup>——对象离开托管状态的地方。

事实上，服务对象允许我们几乎不用考虑就能维护分界障碍，这是使用它们的一个很好的理由。然而，在这一章中，会议的开始和结束是我们试图研究的核心课程——我们正在研究障碍以及如何考虑它们——因此，为了了解解决方案为什么以及如何工作，我们避免使用明显的解决方案。

所以，首先，让我们开始为我们的测试构建工具，这样我们就可以构建可组合的服务调用来对我们隐藏`issueRequest()`。我们仍然需要`HttpResponse`对象，所以我们可以测试响应的主体和响应代码，但至少我们可以隐藏许多进行服务调用本身的常见方面。

我们将从一个叫做`BaseService`的类开始。我们将把这些设计成静态类，因为它们完全没有状态要管理，虽然这是实际实现的反模式，但该反模式仅限于本章*和*我们的测试结构。我们并没有将它们设计成可以替代实际的服务呼叫。 <sup>[13](#Fn13)</sup>

```
package chapter11.servlets;

import java.io.IOException;
import java.net.URI;
import java.net.URLEncoder;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.Charset;
import java.time.Duration;

public class BaseService {
  static String encode(String value) {
    return URLEncoder.encode(
      value,
      Charset.defaultCharset()
    );
  }

  static HttpResponse<String> issueRequest(String path)
    throws IOException, InterruptedException {
    HttpClient client = HttpClient.newBuilder().build();

    HttpRequest request = HttpRequest.newBuilder()
      .uri(URI.create("http://localhost:8080/myapp/" + path))
      .timeout(Duration.ofSeconds(3))
      .build();

    HttpResponse<String> response =
      client.send(request, HttpResponse.BodyHandlers.ofString());
    return response;
  }
}

Listing 11-17chapter11/src/test/java/chapter11/servlets/BaseService.java

```

正如您所看到的，这个类简单地保存了一个简单的`issueRequest()`以及一个对 HTTP 参数进行编码的方法。通过这样做，我们可以节省*一些*代码，但不是很多——毕竟，我们已经在`TestBase`中有了一个`issueRequest()`的副本，正如我们对“添加用户”端点的测试所示。

让我们看看另一个服务类`AddUserService`。这将扩展`BaseService`，因此它可以访问`encode()`和`issueRequest()`，并通过调用`AddUserServlet`端点返回`HttpResponse`。

```
package chapter11.servlets;

import java.io.IOException;
import java.net.http.HttpResponse;

public class AddUserService extends BaseService {
  static HttpResponse<String> addUser(
    String userName)
    throws IOException, InterruptedException {
    String path = String.format(
      "adduser?userName=%s",
      encode(userName)
    );
    return issueRequest(path);
  }
}

Listing 11-18chapter11/src/test/java/chapter11/servlets/AddUserService.java

```

我们添加一个`Post`的服务非常相似，尽管我们还没有看到添加帖子的端点。

```
package chapter11.servlets;

import java.io.IOException;
import java.net.http.HttpResponse;

public class AddPostService extends BaseService {
  static HttpResponse<String> addPost(
    String title,
    String content,
    String userName
  ) throws IOException, InterruptedException {
    String path = String.format(
      "addpost?title=%s&content=%s&userName=%s",
      encode(title),
      encode(content),
      encode(userName));
    return issueRequest(path);
  }
}

Listing 11-19chapter11/src/test/java/chapter11/servlets/AddPostService.java

```

最后，我们还需要一个服务调用来*获取*个帖子。这是一个执行简单查询的调用——没有任何类型的参数——主要用于早期测试。我们还没有看到它的终结点，但是我们很快就会看到它——不久之后，我们将制作另一个具有更强大功能的“获取帖子”终结点。

```
package chapter11.servlets;

import java.io.IOException;
import java.net.http.HttpResponse;

public class SimpleGetPostsService extends BaseService{
  static HttpResponse<String> getSimplePosts()
    throws IOException, InterruptedException {
    return issueRequest("simplegetposts");
  }
}

Listing 11-20chapter11/src/test/java/chapter11/servlets/SimpleGetPostsService.java

```

让我们来看看我们提到的两个端点——简单地获取帖子和添加帖子——然后我们来看看第一次将所有这些集合在一起的测试。`SimpleGetPostsServlet`是第一个，因为它非常简单。

```
package chapter11.servlets;

import chapter11.dto.PostDTO;
import chapter11.model.Post;
import com.autumncode.hibernate.util.SessionUtil;
import org.hibernate.Session;
import org.hibernate.query.Query;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

public class SimpleGetPostsServlet extends ServletBase {
  @Override

  protected void doGet(
    HttpServletRequest req, HttpServletResponse resp
  ) throws ServletException, IOException {
    List<PostDTO> posts = SessionUtil.returnFromSession(session ->
      getPosts(session));
    write(
      resp,
      HttpServletResponse.SC_OK,
      posts
    );
  }

  private List<PostDTO> getPosts(Session session) {
    Query<Post> postQuery = session
      .createQuery("from Post p", Post.class);
    postQuery.setMaxResults(20);
    return postQuery.list().stream().map(post -> {
      PostDTO dto = new PostDTO();
      dto.setId(post.getId());
      dto.setUser(post.getUser().getName());
      dto.setContent(post.getContent());
      dto.setTitle(post.getTitle());
      dto.setCreatedDate(post.getCreateDate());
      return dto;
    }).collect(Collectors.toList());
  }
}

Listing 11-21chapter11/src/main/java/chapter11/servlets/SimpleGetPostsServlet.java

```

这里唯一需要注意的是将一个`Post`转换成一个`PostDTO`的流操作。当然，我们不能没有来源的`PostDTO`。

```
package chapter11.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;

@Data
public class PostDTO {
  int id;
  String user;
  String title;
  String content;
  List<CommentDTO> comments=List.of();
  LocalDateTime createdDate;
}

Listing 11-22chapter11/src/main/java/chapter11/servlets/PostDTO.java

```

当然，这个类是一个非常简单的`Post`的表示。它将`comments`属性初始化为一个空列表，因为我们希望能够用它来发送回带有评论的帖子…但我们不想被迫这样做。尽管如此，我们也需要包括我们的`CommentDTO`。

```
package chapter11.dto;

import lombok.Data;

import java.time.LocalDateTime;

@Data
public class CommentDTO {
  String user;
  String content;
  LocalDateTime createdDate;

}

Listing 11-23chapter11/src/main/java/chapter11/servlets/CommentDTO.java

```

现在我们终于可以开始我们的`AddPostServlet`了。这个类看起来相当长——将近 70 行——但是它真的非常简单。获取一个`User`的代码本来可以被抽象掉，但是那个代码只有三条语句(尽管这里取了七行 <sup>[14](#Fn14)</sup> )。在我们得到一个`User`——如果`User`不存在就抛出一个隐式异常——之后，我们创建一个`Post`,用`Session.save()`将其保存在数据库中，然后创建一个`PostDTO`来序列化响应。

最后*我们进行了一项测试，将所有这些部件组合在一起。首先，让我们看一下测试类，然后我们将遍历它做什么。*

```
package chapter11.servlets;

import chapter11.dto.PostDTO;
import com.fasterxml.jackson.core.type.TypeReference;
import org.testng.annotations.Test;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.net.http.HttpResponse;
import java.util.List;

import static org.testng.Assert.assertEquals;

public class AddPostServletTest
  extends TestBase {

  TypeReference<List<PostDTO>> listOfPosts =
    new TypeReference<>() {
    };

  void addPost()

    throws IOException, InterruptedException {

    HttpResponse<String> response = AddPostService.addPost(
      "test post",
      "my test post",
      "jbo"
    );
    System.out.println(response.body());

    assertEquals(
      response.statusCode(),
      HttpServletResponse.SC_OK,
      "invalid user"
    );

    PostDTO data =
      mapper.readValue(
        response.body(),
        PostDTO.class
      );

    response = SimpleGetPostsService.getSimplePosts();

    assertEquals(
      response.statusCode(),
      HttpServletResponse.SC_OK
    );

    System.out.println(response.body());

    List<PostDTO> dtos=mapper.readValue(response.body(),
      listOfPosts);
    System.out.println(dtos);
    assertEquals(dtos.size(), 1);
  }

  @Test(
    expectedExceptions = AssertionError.class,
    expectedExceptionsMessageRegExp = "invalid user.*"
  )
  void addPostNoUser() throws IOException, InterruptedException {
    addPost();
  }

  @Test
  void addPostWithValidUser()
    throws IOException, InterruptedException {

    HttpResponse<String> response =
      AddUserService.addUser("jbo");

    assertEquals(
      response.statusCode(),
      HttpServletResponse.SC_OK
    );

    addPost();
  }
}

Listing 11-24chapter11/src/test/java/chapter11/servlets/AddPostServletTest.java

```

这门课有四个“片段”。首先是一个`TypeReference`的声明，这样我们可以告诉我们的`ObjectMapper`在反序列化 JSON 时使用什么类型——我们基本上是在告诉 Jackson 如何创建一个`PostDTO`引用的`List`。我们在我们的`TestBase.java`类中看到了同样的事情，除了我们用了一个`Map<String, Object>`作为一个更一般化的形式。(这里一个等价的通用的——也是无用的——类型引用可能是`TypeReference<List<Map<String, Object>>>`,但是我们显然不希望*是*。我们实际上并没有使用*引用*引用`PostDTO`，但是如果我们想这样做，我们已经准备好了。)

我们看到的下一个方法是一个实用方法，实际上是添加一篇文章。这很简单。它调用我们的`AddPostService.addPost()`方法，然后通过`assertEquals`检查响应代码，如果断言失败，将“无效用户”添加到失败异常消息中。(我们将在我们的第一个测试方法中看到这一点。)

假设断言通过，它将 JSON 映射到一个`PostDTO`——我们不使用*这个，但是如果我们想要验证创建，我们可以。为了节省空间，我们没有进行全面的验证。*

 *然后,`addPost()`方法调用`GetSimplePostsServlet`,因为我们想确保帖子确实被创建了。(否则，`AddPostServlet`可能会返回一个新的`PostDTO`，并且什么都不保留——但仍然通过测试。)我们确保调用返回状态码 200，然后我们将 JSON 映射到一个`PostDTO`对象的列表中——并验证列表中有一个帖子(我们刚刚创建的帖子)。

我们的第一个测试方法是`addPostNoUser()`，它只是委托给了一个`addPost()`方法。顾名思义，当调用`addPost()`时，没有用户被构造，我们期待一个异常。实际的异常类型将是`AssertionError`(因为它是由`assertEquals()`触发的，当我们验证添加帖子的响应状态是 200 时)，我们还验证异常*消息*——因为我们希望通过`addPostNoUser()`测试*，当且仅当*因为没有用户在场而抛出异常时。

第二个测试`addPostWithValidUser`只比`addPostNoUser`稍微多一点:它首先添加用户*，然后调用`addPost()`，并期望没有任何异常。*

 *那么，我们从这一节中学到了什么？我们已经看到了很多——我们正在构建类来处理对我们构建的 servlets 的实际调用，尽管它们仍然很低级。我们还从概念上构建了我们的 dto 的其余部分，我们已经展示了我们可以适当地添加帖子——我们还展示了如何*获取*帖子，尽管这还没有做好。

接下来让我们更好地处理获得帖子的问题。

#### 一个更好的“获取帖子”Servlet

如果你回头看一下`Post`实体，你会注意到我们有两个过滤器定义:`byName`和`byTerm`。是时候我们用这些来创造一个更好的版本了。从结构上来说，这是一样的，但是我们将使用两个可选的请求参数来指定一个“名称”——即文章的作者——或者一个“术语”，即文章标题的简单通配符。

```
package chapter11.servlets;

import chapter11.dto.PostDTO;
import chapter11.model.Post;
import com.autumncode.hibernate.util.SessionUtil;
import org.hibernate.Session;
import org.hibernate.query.Query;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

public class GetPostsServlet extends ServletBase {
  @Override
  protected void doGet(
    HttpServletRequest req, HttpServletResponse resp
  ) throws ServletException, IOException {
    List<PostDTO> posts = SessionUtil.returnFromSession(session ->
      getPosts(
        session,
        req.getParameter("userName"),
        req.getParameter("term"))
    );
    write(
      resp,
      HttpServletResponse.SC_OK,
      posts
    );
  }

  private List<PostDTO> getPosts(
    Session session,
    String userName,
    String term
  ) {
    if (userName != null && !userName.isEmpty()) {
      session
        .enableFilter("byName")
        .setParameter("name", userName);
    }

    if (term != null && !term.isEmpty()) {
      session
        .enableFilter("byTerm")
        .setParameter("term", "%" + term + "%");
    }

    Query<Post> postQuery = session
      .createQuery(
        "from Post p order by p.createDate ",
        Post.class
      );

    return postQuery.list().stream().map(post -> {
      PostDTO dto = new PostDTO();
      dto.setId(post.getId());
      dto.setUser(post.getUser().getName());
      dto.setContent(post.getContent());
      dto.setTitle(post.getTitle());
      dto.setCreatedDate(post.getCreateDate());
      return dto;
    }).collect(Collectors.toList());
  }

}

Listing 11-25chapter11/src/main/java/chapter11/servlets/GetPostsServlet.java

```

`getPosts()`方法几乎是同一方法的`SimpleGetPostsServlet`版本的克隆，加入了一些额外的东西。它接受两个参数，可以是 null 或空的(因此我们不能使用我们的`ServletBase.getValidatedParameters()`调用)，以及`Session`；然后，它根据这些参数的存在启用各种过滤器。

然后它执行一个简单的查询:`from Posts p order by p.createDate`，Hibernate 根据过滤器对于这个`Session`是否有效来应用过滤器。我们不必构建自定义查询或类似的东西。

当然，如果不编写一个测试来展示它，我们就不能拥有这样一个 servlet。我们有一个可能性矩阵要管理，所以我们将再次使用`DataProvider`。

首先，我们需要一个`GetPostsService`来匹配我们在其他测试中使用的服务模型。

```
package chapter11.servlets;

import java.io.IOException;
import java.net.http.HttpResponse;

public class GetPostsService extends BaseService {
  static HttpResponse<String> getPosts(String userName, String term)
    throws IOException, InterruptedException {
    StringBuilder path = new StringBuilder("getposts");
    String separator = "?";
    if (userName != null && !userName.isEmpty()) {
      path
        .append(separator)
        .append("userName=")
        .append(userName);
      separator = "&";
    }

    if (term != null && !term.isEmpty()) {
      path
        .append(separator)
        .append("term=")
        .append(term);
    }
    return issueRequest(path.toString());
  }
}

Listing 11-26chapter11/src/test/java/chapter11/servlets/GetPostsService.java

```

这个类非常简单；它基本上是基于我们的搜索词建立一个查询并发出一个请求。

我们的测试也相当简单:它包含了一个`@BeforeMethod`，用两个用户(“jbo”和“ts”)填充我们的数据库，还为这些用户添加了五个帖子，在他们之间分配。实际内容并不特别重要；我们只是在寻找一个数据集，我们可以预测我们的测试。

然后我们有一个`searchCriteria()`方法作为`@DataProvider`。这里，我们构建了一系列包含四个元素的数组:

1.  “搜索用户”值

2.  “搜索标题”值

3.  给定搜索词的预期记录数

4.  对该行所描述内容的描述

我们实际的测试*方法*非常简单。它从`GetPostsService.getPosts()`获取一个响应，并验证它是否以一个成功的状态码响应，然后将响应的主体转换成一个`List<PostDTO>`(就像我们的`AddPostServletTest`所做的那样)，并验证响应的计数是否与数据提供者所说的相符。

```
package chapter11.servlets;

import chapter11.dto.PostDTO;
import com.fasterxml.jackson.core.type.TypeReference;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.net.http.HttpResponse;
import java.util.List;
import java.util.stream.Collectors;

import static org.testng.Assert.assertEquals;

public class GetPostsServletTest
  extends TestBase {
  TypeReference<List<PostDTO>> listOfPosts =
    new TypeReference<>() {
    };

  @BeforeMethod
  void createUsersAndPosts() throws IOException, InterruptedException {
    List<Integer> errorCodes = List.of(
      AddUserService.addUser("jbo"),
      AddUserService.addUser("ts"),
      AddPostService.addPost("raccoons 1", "raccoons are cool", "jbo"),
      AddPostService.addPost("i like dogs", "see title", "jbo"),
      AddPostService.addPost("never seen no cat", "what are cats", "jbo"),
      AddPostService.addPost("raccoons 2", "raccoons are trash pandas", "ts"),
      AddPostService.addPost("dogs are good", "i named mine scooby", "ts")
    )
      .stream()
      .map(HttpResponse::statusCode)
      .filter(status -> status != 200)
      .collect(Collectors.toList());
    if (errorCodes.size() > 0) {
      throw new RuntimeException(
        "An error was encountered seeding data"
      );
    }
  }

  @DataProvider
  Object[][] searchCriteria() {
    return new Object[][]{
      {null, null, 5, "all posts"},
      {"jbo", null, 3, "jbo posts"},
      {"jbo", "cat", 1, "jbo cat posts"},
      {null, "raccoons", 2, "raccoon posts"},
      {"arl", null, 0, "invalid user posts"},
      {null, "crow", 0, "search term with no results"},
      {"ts", "cat", 0, "ts has no cat posts"}
    };
  }

  @Test(dataProvider = "searchCriteria")
  void getPosts(String userName, String term, int count, String desc)
    throws IOException, InterruptedException {
    HttpResponse<String> response =
      GetPostsService.getPosts(userName, term);

    assertEquals(
      response.statusCode(),
      HttpServletResponse.SC_OK
    );

    List<PostDTO> dtos = mapper.readValue(
      response.body(),
      listOfPosts);

    System.out.println(dtos);
    assertEquals(dtos.size(), count);
  }
}

Listing 11-27chapter11/src/test/java/chapter11/servlets/GetPostsServletTest.java

```

#### 完善“应用”

有两个功能我们还没有写，它们都与特定的文章相关。首先，我们没有提供检索特定帖子的方法，也没有提供向帖子添加评论的方法。

我们已经看到了两种镜像功能的流程。毕竟，我们知道如何得到一个`User`，尽管我们还没有看到将一个`User`作为一个`UserDTO`返回，具体地说；获得一个`PostDTO`就是通过帖子的 id 检索一个`PostDTO`，并适当地填充它的评论集。向帖子添加评论的过程与为用户添加帖子的过程大致相同。

由于这些过程与我们所看到的非常相似，我们将实现 servlets 并进行一个*测试，测试检索给定帖子并检查其评论的机制。*

当然，我们已经有了数据传输对象，所以让我们深入 servlet 来获得一个特定的 post。它将接受一个参数，一个帖子 id，并返回一个完全填充的`PostDTO`(包括评论)。注意，这个名字很像我们的另一个 Servlet:这是`GetPostServlet`，不是`GetPostsServlet`。

```
package chapter11.servlets;

import chapter11.dto.CommentDTO;
import chapter11.dto.PostDTO;
import chapter11.model.Post;
import com.autumncode.hibernate.util.SessionUtil;
import org.hibernate.ObjectNotFoundException;
import org.hibernate.Session;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;
import java.util.stream.Collectors;

public class GetPostServlet extends ServletBase {
  @Override

  protected void doGet(
    HttpServletRequest req,
    HttpServletResponse resp)
    throws ServletException, IOException {
    try {
      Map<String, String> input = getValidatedParameters(req, "id");
      Integer id = Integer.parseInt(input.get("id"));

      PostDTO postDTO = SessionUtil
        .returnFromSession(session -> getPost(session, id));

      write(
        resp,
        HttpServletResponse.SC_OK,
        postDTO
      );
    } catch (Exception e) {
      handleException(resp, e);
    }
  }

  protected void handleException(
    HttpServletResponse resp,
    Exception e
  ) throws IOException {
    if (e.getCause() instanceof ObjectNotFoundException) {
      write(
        resp,
        HttpServletResponse.SC_NOT_FOUND,
        Map.of("error", e.getCause().getMessage())
      );
    } else {
      writeError(resp, e);
    }

  }

  protected PostDTO getPost(Session session, Integer id) {
    Post post = session.load(Post.class, id);
    PostDTO postDTO = new PostDTO();

    postDTO.setId(id);
    postDTO.setTitle(post.getTitle());
    postDTO.setContent(post.getContent());
    postDTO.setCreatedDate(post.getCreateDate());
    postDTO.setUser(post.getUser().getName());

    postDTO.setComments(
      post

        .getComments()
        .stream()
        .map(
          comment -> {
            CommentDTO commentDTO = new CommentDTO();
            commentDTO.setContent(comment.getContent());
            commentDTO.setCreatedDate(comment.getCreateDate());
            commentDTO.setUser(comment.getUser().getName());
            return commentDTO;
          })
        .collect(Collectors.toList())
    );
    return postDTO;
  }
}

Listing 11-28chapter11/src/main/java/chapter11/servlets/GetPostServlet.java

```

注意`getPost()`方法，它相当简单，但是有很多代码。它所做的只是由`id`加载一个`Post`——如果`id`不存在，它将抛出一个异常——并用数据填充一个`PostDTO`，*包括将一组注释转换成一列`CommentDTO`对象的过程。*

虽然在`catch()`块中，`doGet()`方法值得讨论。`handleException()`方法的存在是因为`SessionUtil.returnFromSession()`调用没有像人们希望的那样从 lambda 返回一个`ObjectNotFoundException`;它实际上抛出了一个`RuntimeException`，实际的潜在原因是`RuntimeException`的一部分。

在这种情况下，我们实际上想要返回一个 404——一个 HTTP“未找到”消息——而不是一个“服务器错误”消息，如果用户提交了一个帖子 id，而这个 id**可能是正确的**却不存在。 <sup>[15](#Fn15)</sup>

因此，我们必须做的是在捕获异常时检查异常的原因——如果它是一个`ObjectNotFoundException`,那么`Post`的`Session.load()`失败了，我们希望返回一个 404，而不是 500。

我们要看的下一个 servlet 是`AddCommentServlet`，它是*对* `GetPostServlet`的扩展——因为我们想要重用我们刚刚看到的`getPost()`方法。它加载一个`User`，然后通过`id`加载`Post`，然后创建一个简单的`Comment`并将其添加到`Post's`现有的注释列表中；然后，它从`GetPostServlet`返回`getPost()`的值，以返回填充的`PostDTO`——此时大部分是从缓存加载的，因为我们始终使用同一个`Session`。

这里的关键是注意我们如何管理`Session`；一切都发生在用`SessionUtil.returnFromSession()`初始化的 lambda 的上下文中，所以缓存是活动的，我们可以完全访问每个对象的数据，因为如果调用发生时它还没有被填充——就像`post.getComments().add(comment);`—`Session`可以按需加载它需要的任何东西。更重要的是，由于所有的*都是在单个`Session`中发生的*，即使我们试图再次获取*，我们的数据也会被缓存。*

 *我们可以编写简单明了的代码，并且我们可以利用高速缓存的优势使其快速运行，尽管由于安装和拆卸时间的原因，我们的测试并不是特别快。

这是我们的`AddCommentServlet`。

```
package chapter11.servlets;

import chapter11.dto.CommentDTO;
import chapter11.dto.PostDTO;
import chapter11.model.Comment;
import chapter11.model.Post;
import chapter11.model.User;
import com.autumncode.hibernate.util.SessionUtil;
import org.hibernate.Session;
import org.hibernate.query.Query;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.stream.Collectors;

public class AddCommentServlet extends GetPostServlet {
  @Override
  protected void doGet(
    HttpServletRequest req,
    HttpServletResponse resp)
    throws ServletException, IOException {
    try {
      Map<String, String> input = getValidatedParameters(
        req,
        "id",
        "userName",
        "content"
      );
      Integer id = Integer.parseInt(input.get("id"));

      PostDTO postDTO = SessionUtil
        .returnFromSession(session ->
          addComment(
            session,
            id,
            input.get("userName"),
            input.get("content")
          )

        );

      write
        (resp,
          HttpServletResponse.SC_OK,
          postDTO
        );
    } catch (Exception e) {
      handleException(resp, e);
    }
  }

  PostDTO addComment(
    Session session,
    Integer id,
    String userName,
    String content
  ) {
    Query<User> userQuery = session.createQuery(
      "from User u where u.name=:name",
      User.class
    );
    userQuery.setParameter("name", userName);
    User user = userQuery.getSingleResult();

    Post post = session.load(Post.class, id);

    Comment comment = new Comment();
    comment.setUser(user);
    comment.setPost(post);
    comment.setContent(content);
    comment.setCreateDate(LocalDateTime.now());

    session.save(comment);

    post.getComments().add(comment);

    return getPost(session, id);
  }
}

Listing 11-29chapter11/src/main/java/chapter11/servlets/AddCommentServlet.java

```

当然，我们需要进行测试。这也意味着我们有一些服务代理来使服务调用更容易阅读。因此，我们先来看看`GetPostService`、`AddCommentService`，然后是`AddCommentServletTest`。

谢天谢地，服务时间相当短。

```
package chapter11.servlets;

import java.io.IOException;

import java.net.http.HttpResponse;

public class AddCommentService extends BaseService {
  static HttpResponse<String> addComment(
    Integer id,
    String content,
    String userName
  ) throws IOException, InterruptedException {
    String path = String.format(
      "addcomment?id=%s&content=%s&userName=%s",
      id,
      encode(content),
      encode(userName));
    return issueRequest(path);
  }
}

Listing 11-31chapter11/src/test/java/chapter11/servlets/AddCommentService.java

```

```
package chapter11.servlets;

import java.io.IOException;
import java.net.http.HttpResponse;

public class GetPostService extends BaseService {
  static HttpResponse<String> getPost(Integer id)
    throws IOException, InterruptedException {
    return issueRequest(
      String.format("getpost?id=%d", id)
    );
  }

}

Listing 11-30chapter11/src/test/java/chapter11/servlets/GetPostService.java

```

现在我们开始测试中最有趣的部分(好吧，如果这样的事情很有趣的话):第`AddCommentServletTest`。

有两个测试。设置很简单:`createUsersAndPosts()`方法设置两个用户和一篇文章并保存文章，这样我们就可以使用它的`id`来添加评论。

第一个测试`testAddComment()`加载`Post`并验证它没有注释，因为它不应该有注释！然后添加一个注释，并验证从`AddCommentServlet`返回的`PostDTO`有一个注释；然后，它重复这个过程来验证我们可以按顺序添加多个注释。

最后，它通过`GetPostServlet`再次加载`Post`，以确保结果与来自`AddCommentServlet`的调用相同。

第二个测试稍微简单一点——它获取一个不应该存在的帖子，使用*存在的帖子的`id`作为派生新的`id`的基础。*

```
package chapter11.servlets;

import chapter11.dto.PostDTO;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.net.http.HttpResponse;

import static org.testng.Assert.assertEquals;

public class AddCommentServletTest extends TestBase {
  PostDTO post = null;

  @BeforeMethod

  void createUsersAndPosts()
    throws IOException, InterruptedException {
    AddUserService.addUser("jbo");
    AddUserService.addUser("ts");

    HttpResponse<String> postData =
      AddPostService.addPost("raccoons", "raccoons are neat", "jbo");

    // this is how we get the post's id.
    post = mapper.readValue(postData.body(), PostDTO.class);
  }

  @Test
  void testAddComment() throws IOException, InterruptedException {
    HttpResponse<String> response =
      GetPostService.getPost(post.getId());
    validatePost(response, 0);

    response = AddCommentService.addComment(
      post.getId(),
      "what's the deal with raccoons, really",
      "ts"
    );
    assertEquals(response.statusCode(), 200);
    validatePost(response, 1);

    response = AddCommentService.addComment(
      post.getId(),
      "they're the coolest",
      "jbo"
    );
    assertEquals(response.statusCode(), 200);
    validatePost(response, 2);

    response =
      GetPostService.getPost(post.getId());
    validatePost(response, 2);
  }

  @Test
  void testInvalidGetPost()
    throws IOException, InterruptedException {

    HttpResponse<String> response =
      GetPostService.getPost(post.getId() + 1);

    assertEquals(
      response.statusCode(),
      HttpServletResponse.SC_NOT_FOUND
    );
  }

  void validatePost(
    HttpResponse<String> response,
    int commentSize
  ) throws IOException {
    assertEquals(response.statusCode(), 200);

    PostDTO retrieved = mapper.readValue(response.body(), PostDTO.class);

    assertEquals(retrieved.getComments().size(), commentSize);
    assertEquals(retrieved.getTitle(), "raccoons");
  }
}

Listing 11-32chapter11/src/test/java/chapter11/servlets/AddCommentServletTest.java

```

## 摘要

这是一个巨大的篇章！我们用它来演示如何将 Hibernate 集成到一个或多或少可以工作的管理博客的 web 应用程序中；这不是一个好的应用程序，但是可以作为一个应用程序的基础。

我们学到了很多东西:我们已经了解了如何设置一个嵌入式 servlet 引擎(Undertow ),我们已经了解了会话划分和一种很好地管理它的方法，我们还了解了整个过程的一组相当详尽的测试。

不得不说，这一章中的大部分代码并不*特别是*有用；有了足够的努力和意图，*可以让*变得有用，但是我们在这里真正寻找的是理解一些关于跨架构墙传递数据的问题，例如，从一个实体到 JSON。

我们接下来的章节将集中在将 Hibernate 集成到一个很可能在现实世界中遇到的框架中。

<aside aria-label="Footnotes" class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

我认为我说“直接公开 Hibernate 实体是个坏主意”破坏了整个章节。哎呦。

  [2](#Fn2_source)

Java 2 企业版通常被称为 J2EE，最终成为 Java EE，因为没有人真正理解“2”的原因——是的，有一个——并且最近迁移到“Jakarta EE”名称。

  [3](#Fn3_source)

Apache ECS 已经被弃用很多年了，但是如果你对探索历史非常感兴趣，它仍然在网上的[`https://projects.apache.org/project.html?attic-ecs`](https://projects.apache.org/project.html%253Fattic-ecs)——只是要知道现在有更好的方法。

  [4](#Fn4_source)

如果你想在 JVM 上建立一个 web 应用程序编程书籍的图书馆，请参见[`www.apress.com`](http://www.apress.com)——那里有很多参考资料！

  [5](#Fn5_source)

我打赌你几乎忘记了这是一本冬眠书，是吗？

  [6](#Fn6_source)

当然，这本书是用 AsciiDoctor 编写的——它本身可以生成一个静态站点。

  [7](#Fn7_source)

日期和时间 API 是 JSR-310，来自 [`www.jcp.org/en/jsr/detail?id=310`](http://www.jcp.org/en/jsr/detail%253Fid%253D310) ，在相当多的版本中都是 JVM 标准运行时库的一部分。然而，Jackson 也兼容*旧的*JVM，因此我们需要启用对 JSR-310 类型的支持。

  [8](#Fn8_source)

集成测试将涉及到容器中的正式部署，或者可能是像我们的测试工具一样包含 Undertow 的主要入口点，但是我们不打算在这里这样做。毕竟，我们还在使用嵌入式数据库。

  [9](#Fn9_source)

精明或有经验的 Java EE 程序员会认识到，`servlets.json`基本上是对`web.xml`的替代，Undertow 本身并不使用它。我们本可以在类路径中扫描 servlets 毕竟,`@WebServlet`是一个存在的注释——但那会更复杂。

  [10](#Fn10_source)

在编程中，很难说一个解决方案是*绝对是*更好。我本打算在这个脚注中对我不喜欢的东西进行一些廉价的攻击，但我忍住了，因为我想象着我的编辑因为我不喜欢`THIS HAS BEEN REDACTED, JOSEPH`而对我大吼大叫。

  [11](#Fn11_source)

我们在这一章所做的是平衡这些方法；每个实体只有一个 DTO，默认情况下，DTO 由“空数据”填充。

  [12](#Fn12_source)

“分界”是事物之间的分界线，所以当我们提到 Hibernate 的“会话分界”时，我们指的是事物何时变成托管或非托管。

  [13](#Fn13_source)

老实说:我希望有一种方法可以遵循“好的设计，而不需要在书上再增加几百页。我把自己逼疯了，试图找出做出什么样的妥协，在“有效教学”和“编写我在现实世界中拒绝的代码”之间找到平衡。“如果你想抱怨所有的设计捷径，我完全理解，相信我。但是我想请你考虑如何保持内容的可读性，同时举例说明我们试图讨论的概念；如果你有更好的解决方案，不会增加不可接受的长度，请告诉我，我会在下一版书中使用它。

  [14](#Fn14_source)

同样，这里有一个平衡。我们本来可以创建另一个类来封装 get a`User`，但是这意味着又一个代码清单，以及每一个其他类似的调用，这可能已经让许多读者不知所措了。

  [15](#Fn15_source)

`handleException()`方法实际上是`ServletBase`中的一个很好的候选方法，但是我们试图在遇到它时引入复杂性，而不是一下子引入。

 </aside>********