# 13.页码

## 项目 94:偏移分页何时以及为什么会成为性能损失

偏移分页非常流行，Spring Boot(更准确地说是 Spring Data Commons)通过`Page`和`Slice`API 提供了对它的支持。但是，随着项目的发展和数据的积累，依赖偏移分页可能会导致性能下降，即使在项目开始时这并不是一个问题。

处理偏移量分页意味着您可以忽略在达到期望的偏移量之前丢弃 *n* 条记录所带来的性能损失。更大的 *n* 会导致显著的性能损失。另一个代价是计算记录总数所需的额外的`SELECT`(特别是如果您需要计算每个获取的页面)。虽然键集(seek)分页可能是一种可行的方法(作为一种不同的方法)，但可以优化偏移分页以避免这种额外的`SELECT`，如**项目 95** 和**项目 96** 中所述。因此，如果您熟悉这个主题，并且您所需要的只是一个优化的偏移分页，您可以简单地跳转到**项目 95** 和**项目 96** 。好，现在我们继续...

对于相对较小的数据集，offset 和 keyset 提供了几乎相同的性能。但是，您能保证数据集不会随时间增长吗？或者您能控制增长过程吗？大多数企业从少量数据开始，但当成功加速时，数据量也会快速增加。

### 偏移量和键集索引扫描

索引扫描输入偏移量将遍历索引范围，从开头到指定的偏移量。基本上，偏移量表示在将记录包含在结果中之前必须跳过的记录数，这意味着还必须进行计数。在 offset 中，根据必须获取和跳过的数据量(请记住，表通常会快速“增长”)，这种方法可能会导致性能显著下降。偏移方法将遍历已经显示的记录。见图 [13-1](#Fig1) 。

![../images/487471_1_En_13_Chapter/487471_1_En_13_Fig1_HTML.jpg](../images/487471_1_En_13_Chapter/487471_1_En_13_Fig1_HTML.jpg)

图 13-1

偏移量中的索引扫描与键集分页

另一方面，键集中的索引扫描将只遍历所需的值，从上一个值开始(它跳过这些值，直到上一个值被取出)。在键集中，随着表记录的增加，性能几乎保持不变。

### 偏移分页的利弊

考虑偏移量分页的以下优点和缺点。

缺点:

*   插入可能会造成页面偏差

*   每次，它都从头开始对行进行编号

*   它应用一个过滤器来删除不必要的行

*   如果偏移量大于排序结果中的行数，则不返回任何行

优点:

*   它可以获取任意页面

    反对使用偏移分页的一个重要参考和令人信服的论据是使用索引，LUKE！ <sup>[1](#Fn1)</sup> 网站。我强烈建议您花点时间看看 Markus Winand 的这个精彩演示 <sup>[2](#Fn2)</sup> ，它涵盖了调优分页 SQL 的重要主题，比如在 offset 和 keyset 分页中使用索引和*行值*(PostgreSQL 支持)。

    在开始分页实现之前，建议至少考虑以下两个方面:

*   有时不需要为每个页面触发一个`SELECT COUNT`(插入/删除很少发生)。在这种情况下，最好定期触发`SELECT COUNT`或者只触发一次。

*   最好使用强大的过滤功能，而不是返回大量的页面。想想你最后一次浏览一个网站的几个页面是什么时候，如果你不记得了，这意味着你的客户的行为是一样的。他们更喜欢润色他们的过滤器，而不是浏览大量的页面。因此，提高你的过滤器，直到返回的结果适合几个页面。

### Spring Boot 胶印分页

如果获胜者是偏移分页，那么 Spring Boot 通过`Page` API 提供了对偏移分页的内置支持。考虑图 [13-2](#Fig2) 中`Author`实体对应的`author`表。

![../images/487471_1_En_13_Chapter/487471_1_En_13_Fig2_HTML.jpg](../images/487471_1_En_13_Chapter/487471_1_En_13_Fig2_HTML.jpg)

图 13-2

作者实体表

下面的例子依赖于`Author`实体和`AuthorRepository`存储库来形成一种实现分页的简单方法。首先，至少有五种方法可以获取结果集，如下所示:

如果您需要在接受参数`Pageable`的查询方法中取消分页，那么只需传递参数`Pageable.unpaged()`。

*   在没有显式排序的情况下调用内置的`findAll(Pageable)`(不建议使用**):**

 ***   调用带有排序的内置`findAll(Pageable)`:

```
authorRepository.findAll(PageRequest.of(page, size));

```

*   使用 Spring 数据查询构建器机制在存储库中定义新方法:

```
authorRepository.findAll(PageRequest.of(page, size,
                                  Sort.by(Sort.Direction.ASC, "price")));

```

*   使用 JPQL 和`@Query`，有和没有显式`SELECT COUNT`:

```
Page<Author> findByName(String name, Pageable pageable);
Page<Author> queryFirst10ByName(String name, Pageable pageable);

```

*   使用本地查询和`@Query`，有和没有显式`SELECT COUNT`:

```
@Query(value = "SELECT a FROM Author a WHERE a.genre = ?1",
       countQuery = "SELECT COUNT(*) FROM Author a WHERE a.genre = ?1")
public Page<Author> fetchByGenreExplicitCount(
                    String genre, Pageable pageable);

@Query("SELECT a FROM Author a WHERE a.genre = ?1")
public Page<Author> fetchByGenre(String genre, Pageable pageable);

```

```
@Query(value = "SELECT * FROM author WHERE genre = ?1",
       countQuery = "SELECT COUNT(*) FROM author WHERE genre = ?1",
       nativeQuery = true)
public Page<Author> fetchByGenreNativeExplicitCount(
                            String genre, Pageable pageable);

@Query(value = "SELECT * FROM author WHERE genre = ?1",
       nativeQuery = true)
public Page<Author> fetchByGenreNative(String genre, Pageable pageable);

```

此外，支持`Author`分页所需的传统存储库将扩展`PagingAndSortingRepository`，如下所示:

```
@Repository
public interface AuthorRepository
                extends PagingAndSortingRepository<Author, Long> {
}

```

接下来，服务方法可以按年龄升序获取页面`Author`，如下所示:

```
public Page<Author> fetchNextPage(int page, int size) {

    return authorRepository.findAll(PageRequest.of(page, size,
                                Sort.by(Sort.Direction.ASC, "age")));
}

```

接下来，从控制器调用它，如下所示:

```
@GetMapping("/authors/{page}/{size}")
public Page<Author> fetchAuthors(@PathVariable int page,
                                        @PathVariable int size) {

    return bookstoreService.fetchNextPage(page, size);
}

```

下面是一个可能的请求及其输出(获取包含五个作者和一个带有细节的`pageable`元素的第一个页面):

```
http://localhost:8080/authors/1/5

{
   "content":[
      {
         "id":22,
         "age":24,
         "name":"Kemal Ilias",
         "genre":"History"
      },
      {
         "id":28,
         "age":24,
         "name":"Sandra Ostapenco",
         "genre":"History"
      },
      {
         "id":16,
         "age":24,
         "name":"Joana Leonte",
         "genre":"History"
      },
      {
         "id":46,
         "age":24,
         "name":"Alp Ran",
         "genre":"History"
      },
      {
         "id":12,
         "age":26,
         "name":"Katre Mun",
         "genre":"Anthology"
      }
   ],
   "pageable":{
      "sort":{
         "sorted":true,
         "unsorted":false,
         "empty":false
      },
      "pageNumber":1,
      "pageSize":5,
      "offset":5,
      "paged":true,
      "unpaged":false
   },
   "totalPages":11,
   "totalElements":51,
   "last":false,
   "numberOfElements":5,
   "first":false,
   "sort":{
      "sorted":true,
      "unsorted":false,
      "empty":false
   },
   "number":1,
   "size":5,
   "empty":false
}

```

获取这个结果需要两条 SQL 语句(第二条`SELECT`对记录进行计数，并在每次获取页面时触发):

```
SELECT
  author0_.id AS id1_0_,
  author0_.age AS age2_0_,
  author0_.genre AS genre3_0_,
  author0_.name AS name4_0_
FROM author author0_
ORDER BY author0_.age ASC
LIMIT 5, 5

SELECT
  Count(author0_.id) AS col_0_0_
FROM author author0_

```

有时不需要为每个页面触发一个`SELECT COUNT`,因为新的插入或删除非常罕见；因此，行数在很长时间内保持固定。在这种情况下，只在获取第一页时触发一次`SELECT COUNT`，并依靠`Slice`或`List`而不是`Page`进行分页。或者您可以定期触发`SELECT COUNT`(例如，每 15 分钟、每 10 页等)。).

在分页的情况下，确定性排序顺序是强制性的。因此，不要忘记`ORDER BY`子句。

请注意，如果您将对象添加到控制器中，Spring 可以派生出`Pageable`对象。请求的参数遵循以下约定:

*   `page`请求参数指示要检索的页面(缺省值为 0)

*   `size`请求参数指示要检索的页面的大小(缺省值是 20)

*   `sort`请求参数将排序属性表示为`property, property (,ASC|DESC)`(默认为升序)

下面是一个控制器端点示例:

```
@GetMapping("/authors")
public Page<Author> fetchAuthors(Pageable pageable) {

    return bookstoreService.fetchNextPagePageable(pageable);
}

```

以下是第 1 页的请求，大小为 3，按名称降序排列:

```
http://localhost:8080/authors?page=1&size=3&sort=name,desc

```

或者按姓名降序和流派升序排序:

```
http://localhost:8080/authors?page=1&size=3&sort=name,desc&sort=genre,asc

```

GitHub <sup>[3](#Fn3)</sup> 上有源代码。

在决定哪种分页类型最合适之前，请考虑阅读这一整章。最有可能的是，本文中介绍的方法最容易导致性能损失，所以只将其作为下一步工作的里程碑。接下来的两个项目——**项目 95** 和**项目 96**——讨论偏移分页的优化。

更准确地说，通过`COUNT(*) OVER()`窗口函数和`SELECT COUNT`子查询，尽量避免额外的`SELECT COUNT`。

图 [13-3](#Fig3) 中显示的时间-性能趋势图强调了`COUNT(*) OVER()`往往比使用两个`SELECT`语句或一个`SELECT COUNT`子查询执行得更好。另一方面，一个`SELECT COUNT`子查询似乎并没有比触发两个`SELECT`语句带来更大的好处。这是因为应用程序和数据库运行在同一台机器上。如果您通过网络访问数据库，那么触发两个`SELECT`语句会增加两次网络开销，而`SELECT COUNT`子查询只会增加一次网络开销。在图 [13-3](#Fig3) 中，我们假设`author`表有 100 万条记录，我们尝试获取 100 个实体的页面。更准确地说，我们获取第一页(0)、第 5000 页和第 9999 页。

![../images/487471_1_En_13_Chapter/487471_1_En_13_Fig3_HTML.jpg](../images/487471_1_En_13_Chapter/487471_1_En_13_Fig3_HTML.jpg)

图 13-3

使用偏移分页选择实体

图 [13-3](#Fig3) 中显示的时间性能趋势图是在具有以下特征的 Windows 7 机器上针对 MySQL 获得的:英特尔 i7、2.10GHz 和 6GB RAM。应用程序和 MySQL 运行在同一台机器上。

在 MySQL 中，为了对记录进行计数，还需要使用`SQL_CALC_FOUND_ROWS`查询修饰符和附带的`FOUND_ROWS()`函数。这种方法在本书中被跳过，因为它在 MySQL 8.0.17 中被标记为不推荐使用，并将在未来的 MySQL 版本中被删除。然而，一篇关于`SQL_CALC_FOUND_ROWS`性能的有趣论文可以在这里找到 <sup>[4](#Fn4)</sup> 。

## 第 95 项:如何优化 COUNT(*) OVER 和 Page <entity>的偏移分页</entity>

**第 94 项**强调了偏移分页的两个潜在性能损失:遍历已经显示的记录和每页两个单独的`SELECT`语句(两次数据库往返)。一个`SELECT`获取数据，另一个计算记录总数。此外，让我们尝试只在一次查询(一次数据库往返)中获取通过这两个`SELECT`获得的信息。这样，消除了第二次往返所增加的性能损失。作为一个权衡，获取数据的`SELECT`也需要一些时间来计数。

### COUNT(*) OVER()窗口化聚合

`COUNT(*) OVER()`是`COUNT()`集合函数和`OVER()`子句的组合，它将窗口函数与其他函数区分开来。`OVER`指定聚合函数的窗口子句。

当 RDBMS 支持窗口函数(例如 MySQL 8)时，可以使用`COUNT(*) OVER()`窗口聚合来消除获取记录总数所需的第二次数据库往返。如果你的 RDBMS 不支持窗口函数，考虑使用`SELECT COUNT`子查询的**项目 96** 。

您可以通过本地查询编写一个`COUNT(*) OVER()`查询。`COUNT(*) OVER()`是获取数据的查询的一部分。它的目的是统计记录的总数。此外，每个提取的数据页可以是实体页(但仅当有计划修改它们时)或 DTO 页(对于只读数据)。让我们来看看如何去取一只`Page<` `dto` `>`。

#### 页数为页<*dto*T2】

一个毫无创意的获取`Page<` `dto` `>`的方法如下:

```
public Page<AuthorDto> findAll(Pageable pageable) {
    Page<Author> page = authorRepository.findAll(pageable);
    return new PageImpl<AuthorDto>(AuthorConverter/Mapper.convert/map(
        page.getContent()), pageable, page.getTotalElements());
}

```

一些开发人员声称前面的例子是正确的，这是基于各种或多或少正确的原因。然而，在您做出决定之前，请考虑阅读弗拉德·米哈尔恰的推文 <sup>[5](#Fn5)</sup> ，它反对这种反模式。Vlad 说:“不要提取实体，只使用映射器来创建 dto。这是非常低效的，但我一直看到这种反模式得到推广。”

虽然该方法返回一个`Page<AuthorDto>`，但是当调用`authorRepository.findAll()`时，它仍然将数据提取到持久性上下文中。因为内置的`findAll()`用`@Transactional(readOnly = true)`注释，所以持久化上下文不会保存水合状态。因此，实体将以只读模式加载。

最好避免以将数据转换为 dto 为唯一目的，将数据作为只读实体获取。在这种情况下，DTO 包含实体的所有属性(它是实体的镜像)。大多数时候，我们提取属性的子集(web 应用程序中的常见场景)，这意味着我们只从实体中提取所需的属性到 dto，而丢弃其余的。获取超过需要的数据是一种不好的做法。因此，在这两种情况下，提取实体的唯一目的是使用 dto 映射器，这会导致性能下降。

一个`Page<` `dto` `>`需要一个 DTO；因此，您定义了一个弹簧投影(DTO ),其中包含与应该提取的数据相对应的 getters。在这种情况下，是`Author`实体的`age`和`name`:

```
public interface AuthorDto {
    public String getName();

    public int getAge();

    @JsonIgnore
    public long getTotal();
}

```

检查突出显示的两行代码。需要使用`getTotal()`来映射`COUNT(*) OVER()`的结果。这不是`Author`实体的财产。而且，它用`@JsonIgnore`进行了注释，因为它不会在发送给客户端的 JSON 响应中被序列化。它将在`PageImpl`的构造函数中被用来创建一个`Page<AuthorDto>`。但是，在此之前，这里列出了获取数据的 JPQL 查询和单次数据库往返中的记录总数(也可以使用`WHERE`子句):

```
@Repository
public interface AuthorRepository
            extends PagingAndSortingRepository<Author, Long> {

    @Query(value = "SELECT name, age, COUNT(*) OVER() AS total FROM author", nativeQuery = true)
    List<AuthorDto> fetchAll(Pageable pageable);
}

```

注意，该查询没有显式设置排序和限制结果集所需的`ORDER BY`和`LIMIT`子句。然而，使用传递的`Pageable`，它包含页面、大小和排序信息，可以很好地完成这项工作。这个`Pageable`将根据给定的大小、页面和排序信息，向生成的 SQL 语句添加缺失的`ORDER BY`和`LIMIT`子句。用两个整数替换`Pageable`对象并将`ORDER BY age LIMIT ?1, ?2`添加到查询中不会有问题。

`LIMIT`子句由`MySQL`和`PostgreSQL`识别。SQL Server 支持`SELECT TOP`子句，Oracle 使用`ROWNUM`或`ROWS FETCH NEXT` `n` `ROWS ONLY`。

调用`fetchAll()`将触发以下 SQL 语句:

```
SELECT
  name,
  age,
  COUNT(*) OVER() AS total
FROM author
ORDER BY age ASC
LIMIT ? ?

```

通过`getTotal()`存储`COUNT(*) OVER()`结果。由于`fetchAll()`返回一个`List<AuthorDto>`，它必须被转换成一个`Page<AuthorDto>`。服务方法创建一个`Pageable`并调用`fetchAll()`。`fetchAll()`的结果用于通过下面的`PageImpl`构造函数创建一个`Page<AuthorDto>`:

```
public PageImpl(List<T> content, Pageable pageable, long total)

```

服务方法非常简单:

```
public Page<AuthorDto> fetchNextPage(int page, int size) {

    Pageable pageable = PageRequest.of(page, size,
                Sort.by(Sort.Direction.ASC, "age"));

    List<AuthorDto> authors = authorRepository.fetchAll(pageable);
    Page<AuthorDto> pageOfAuthors = new PageImpl(authors, pageable,
                authors.isEmpty() ? 0 : authors.get(0).getTotal());

    return pageOfAuthors;
}

```

REST 控制器端点可以如下调用`fetchNextPage()`方法:

```
@GetMapping("/authors/{page}/{size}")
public Page<AuthorDto> fetchAuthors(
            @PathVariable int page, @PathVariable int size) {

    return bookstoreService.fetchNextPage(page, size);
}

```

下面是一些可能的 JSON 输出(注意，记录总数是 51):

```
http://localhost:8080/authors/1/3

{
   "content":[
      {
         "age":23,
         "name":"Wuth Troll"
      },
      {
         "age":23,
         "name":"Nagir Turok"
      },
      {
         "age":24,
         "name":"Alp Ran"
      }
   ],
   "pageable":{
      "sort":{
         "sorted":true,
         "unsorted":false,
         "empty":false
      },
      "pageSize":3,
      "pageNumber":1,
      "offset":3,
      "paged":true,
      "unpaged":false
   },
   "totalPages":17,
   "totalElements":51,
   "last":false,
   "numberOfElements":3,
   "first":false,
   "sort":{
      "sorted":true,
      "unsorted":false,
      "empty":false
   },
   "number":1,
   "size":3,
   "empty":false
}

```

GitHub <sup>[6](#Fn6)</sup> 上有源代码。

您可以很容易地只获取数据(没有`pageable`元素)作为`List<AuthorDto>`，如这个应用程序 <sup>[7](#Fn7)</sup> 。

#### 页面为页面<*实体* >

虽然`Page<` `dto` `>`非常适合只读数据的分页，但是`Page<` `entity` `>`更适合将被修改的实体。

提取实体不会映射`COUNT(*) OVER()`结果。实体定义了它的属性集(`id`、`age`、`name`和`genre`，但是它没有一个特殊的属性来表示数据库中记录的总数。要解决这个问题，至少有一种方法可以进一步讨论。

##### 使用专用属性

映射由`COUNT(*) OVER()`返回的记录总数的一种方法是在相应的实体中添加一个专用属性。该属性可以映射到不可*插入的*或不可*更新的*列，如下例所示(`total`属性没有设置器):

```
@Entity
public class Author implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private int age;
    private String name;
    private String genre;

    @Column(insertable = false, updatable = false)
    long total;

    ...

    public long getTotal() {
        return total;
    }
}

```

此外，在`AuthorRepository`中，您可以依赖包含`COUNT(*) OVER()`的原生 SQL，如下所示:

```
@Repository
public interface AuthorRepository
                    extends PagingAndSortingRepository<Author, Long> {

    @Query(value = "SELECT id, name, age, genre, COUNT(*) OVER() AS total
             FROM author", nativeQuery = true)
    List<Author> fetchAll(Pageable pageable);
}

```

调用`fetchAll()`将触发下面的`SELECT`语句(注意，有一个单独的查询用于获取一页数据作为`List<Author>`):

```
SELECT
  id,
  name,
  age,
  genre,
  COUNT(*) OVER() AS total
FROM author
ORDER BY age ASC
LIMIT ?, ?

```

调用`fetchAll()`的服务方法负责准备`Page<Author>`，如下所示:

```
public Page<Author> fetchNextPage(int page, int size) {

    Pageable pageable = PageRequest.of(page, size,
                    Sort.by(Sort.Direction.ASC, "age"));

    List<Author> authors = authorRepository.fetchAll(pageable);
    Page<Author> pageOfAuthors = new PageImpl(authors, pageable,
                    authors.isEmpty() ? 0 : authors.get(0).getTotal());

    return pageOfAuthors;
}

```

源代码可在 GitHub <sup>[8](#Fn8)</sup> 上获得。应用程序公开了一个类型为`http://localhost:8080/authors/{`*page*}/{*size*}的 REST 端点。返回的结果是一个 JSON，如下例所示(在`author`表中有 51 条记录，这由`total`字段公开):

```
http://localhost:8080/authors/1/3

{
   "content":[
      {
         "id":7,
         "age":23,
         "name":"Wuth Troll",
         "genre":"Anthology"
      },
      {
         "id":48,
         "age":23,
         "name":"Nagir Turok",
         "genre":"Anthology"
      },
      {
         "id":46,
         "age":24,
         "name":"Alp Ran",
         "genre":"History"
      }
   ],
   "pageable":{
      "sort":{
         "sorted":true,
         "unsorted":false,
         "empty":false
      },
      "pageSize":3,
      "pageNumber":1,
      "offset":3,
      "paged":true,
      "unpaged":false
   },
   "totalPages":17,
   "totalElements":51,
   "last":false,

   "numberOfElements":3,
   "first":false,
   "sort":{
      "sorted":true,
      "unsorted":false,
      "empty":false
   },
   "number":1,
   "size":3,
   "empty":false
}

```

您可以很容易地只获取数据(没有`pageable`元素)作为`List<Author>`，如这个应用程序 <sup>[9](#Fn9)</sup> 中所示。

## 第 96 项:如何使用 SELECT COUNT 子查询和 Page <entity>优化偏移量分页</entity>

**第 94 项**强调了偏移分页的两个潜在性能损失:遍历已经显示的记录和每页两个单独的`SELECT`语句(两次数据库往返)。一个`SELECT`获取数据，另一个对记录进行计数。让我们试着只在一个查询中触发这两个`SELECT`(一次数据库往返)。这样就消除了第二次往返的性能损失。作为一个权衡，获取数据的`SELECT`也会消耗一些时间来计数。

### 选择计数子查询

如果您的 RDBMS 不支持窗口函数(例如，版本 8 之前的 MySQL ),使用`SELECT COUNT`子查询来消除获取记录总数所需的第二次数据库往返。如果你的 RDBMS 支持窗口函数，考虑第 95 条中的方法。

您可以通过本地查询或 JPQL 编写一个`SELECT COUNT`子查询。作为一个子查询，这个`SELECT COUNT`嵌套在获取数据的`SELECT`中，其目的是计算记录总数。此外，每个提取的数据页可以是一个实体页(但只有在计划修改它们时)或一个 dto 页(对于只读数据)。让我们来看看如何获取一个`Page<` `dto` `>`。

#### 页数为页<*dto*T2】

获取`Page<` `dto` `>`的一个没有创意的方法如下:

```
public Page<AuthorDto> findAll(Pageable pageable) {
    Page<Author> page = authorRepository.findAll(pageable);
    return new PageImpl<AuthorDto>(AuthorConverter/Mapper.convert/map(
        page.getContent()), pageable, page.getTotalElements());
}

```

虽然该方法返回一个`Page<AuthorDto>`，但是当调用`authorRepository.findAll()`时，它仍然将数据提取到持久性上下文中。这将是一种更好的方法，可以避免以只读实体的形式获取数据，然后将其转换为 DTO。此外，在这种情况下，DTO 包含实体的所有属性(它是实体的镜像)。提取属性的一个子集会强加被丢弃的数据，这些数据是毫无目的地获取的。

一个`Page<` `dto` `>`需要一个 DTO；因此，您需要定义一个 Spring projection (DTO ),其中包含与应该获取的数据相对应的 getters。在这种情况下，是`Author`实体的`age`和`name`:

```
public interface AuthorDto {

    public String getName();

    public int getAge();

    @JsonIgnore
    public long getTotal();
}

```

检查突出显示的两行代码。需要使用`getTotal()`来映射`SELECT COUNT`子查询的结果。这不是`Author`实体的财产。而且，它用`@JsonIgnore`进行了注释，因为它不会在发送给客户端的 JSON 响应中被序列化。它将在`PageImpl`的构造函数中被用来创建一个`Page<AuthorDto>`。但是，在此之前，在一次数据库往返中获取数据和记录总数的 JPQL 查询如下所示:

```
@Repository
public interface AuthorRepository
            extends PagingAndSortingRepository<Author, Long> {

    @Query(value = "SELECT a.name as name, a.age as age, "
        + "(SELECT count(a) FROM Author a) AS total FROM Author a")
    List<AuthorDto> fetchAllJpql(Pageable pageable);
}

```

请注意，`fetchAllJpql()`接受了一个类型为`Pageable`的参数(一个包装了关于一页数据的元数据的对象，比如页面大小、总元素数、页码、排序等。).JPQL 没有提供限制查询的机制；因此，明确添加`LIMIT`(或其对应方)是不可能的。这通常通过在`Query`上使用`setMaxResults()`方法来实现。然而，使用`Pageable`可以很好地完成这项工作。传递的`Pageable`将把`ORDER BY`和`LIMIT`子句添加到生成的 SQL 语句中。

调用`fetchAllJpql()`将触发以下 SQL 语句:

```
SELECT
  author0_.name AS col_0_0_,
  author0_.age AS col_1_0_,
  (SELECT COUNT(author1_.id)
   FROM author author1_)
   AS col_2_0_
FROM author author0_
ORDER BY author0_.age ASC
LIMIT ? ?

```

通过以下本机查询可以获得相同的效果:

@ repository public interface author repository 扩展 PagingAndSortingRepository<author long="">{ @ Query(value = " SELECT**t . total**，姓名，作者年龄，“`+` `"(SELECT count(*) AS total FROM author) AS t"` `,` `nativeQuery = true)    List<AuthorDto> fetchAllNative(Pageable pageable);}`</author>

`SELECT COUNT`子查询结果通过`getTotal()`存储。由于`fetchAllJqpl()`返回一个`List<AuthorDto>`，它必须被转换成一个`Page<AuthorDto>`。一个服务方法创建`Pageable`并调用`fetchAllJpql()`。`fetchAllJpql()`的结果用于通过下面的`PageImpl`构造函数创建一个`Page<AuthorDto>`:

```
public PageImpl(List<T> content, Pageable pageable, long total)

```

服务方法非常简单:

```
public Page<AuthorDto> fetchNextPageJpql(int page, int size) {

    Pageable pageable = PageRequest.of(page, size,
                        Sort.by(Sort.Direction.ASC, "age"));

    List<AuthorDto> authors = authorRepository.fetchAllJpql(pageable);
    Page<AuthorDto> pageOfAuthors = new PageImpl(authors, pageable,
        authors.isEmpty() ? 0 : authors.get(0).getTotal());

    return pageOfAuthors;
}

```

REST 控制器端点可以调用`fetchNextPageJpql()`方法，如下所示:

```
@GetMapping("/authors/{page}/{size}")
public Page<AuthorDto> fetchAuthorsJpql(
            @PathVariable int page, @PathVariable int size) {

    return bookstoreService.fetchNextPageJpql(page, size);
}

```

可能的输出是下面的 JSON(注意，记录总数是 51):

```
http://localhost:8080/authors/1/3

{
   "content":[
      {
         "age":23,
         "name":"Tylor Ruth"
      },
      {
         "age":23,
         "name":"Wuth Troll"
      },
      {
         "age":24,
         "name":"Kemal Ilias"
      }
   ],
   "pageable":{
      "sort":{
         "unsorted":false,
         "sorted":true,
         "empty":false
      },
      "pageSize":3,
      "pageNumber":1,
      "offset":3,
      "paged":true,
      "unpaged":false
   },

   "totalPages":17,
   "totalElements":51,
   "last":false,
   "numberOfElements":3,
   "first":false,
   "sort":{
      "unsorted":false,
      "sorted":true,
      "empty":false
   },
   "number":1,
   "size":3,
   "empty":false
}

```

GitHub <sup>[10](#Fn10)</sup> 上有源代码。

您可以很容易地只获取数据(没有`pageable`元素)作为`List<AuthorDto>`，如这个应用程序 <sup>[11](#Fn11)</sup> 。

#### 页面为页面<*实体* >

虽然`Page<` `dto` `>`非常适合对只读数据进行分页，但是`Page<` `entity` `>`更适合将要被修改的实体。

提取实体不会映射`SELECT COUNT`子查询结果。实体定义了一组属性，但是它没有表示数据库中记录总数的特殊属性。要解决这个问题，至少有一种方法，下面讨论。

##### 使用额外的属性

映射由`SELECT COUNT`子查询返回的记录总数的一种方法是向相应的实体添加一个额外的属性。该属性可以映射到不可插入*或可更新*的列，如下例所示(`total`属性没有设置器):**

```
@Entity
public class Author implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private int age;
    private String name;
    private String genre;

    @Column(insertable = false, updatable = false)
    long total;

    ...

    public long getTotal() {
        return total;
    }
}

```

此外，在`AuthorRepository`中，您可以依赖包含`SELECT COUNT`子查询的原生 SQL，如下所示:

```
@Repository
public interface AuthorRepository
            extends PagingAndSortingRepository<Author, Long> {

    @Query(value = "SELECT t.total, id, name, age, genre FROM author, "
        + "(SELECT count(*) AS total FROM author) AS t",
        nativeQuery = true)
    List<Author> fetchAll(Pageable pageable);
}

```

调用`fetchAll()`将触发下面的`SELECT`语句(注意，有一个单独的查询用于获取一页数据作为`List<Author>`):

```
SELECT
  t.total,
  id,
  name,
  age,
  genre
FROM author,
     (SELECT COUNT(*) AS total
     FROM author) AS t
ORDER BY age ASC
LIMIT ?, ?

```

调用`fetchAll()`的服务方法负责准备`Page<Author>`，如下所示:

```
public Page<Author> fetchNextPage(int page, int size) {

    Pageable pageable = PageRequest.of(page, size,
                    Sort.by(Sort.Direction.ASC, "age"));

    List<Author> authors = authorRepository.fetchAll(pageable);
    Page<Author> pageOfAuthors = new PageImpl(authors, pageable,
                    authors.isEmpty() ? 0 : authors.get(0).getTotal());

    return pageOfAuthors;
}

```

源代码可在 GitHub <sup>[12](#Fn12)</sup> 上获得。应用程序公开了一个类型为`http://localhost:8080/authors/{`*page**}/{**size**}*的 REST 端点。返回的结果是一个 JSON，如下例所示(在`author`表中有 51 条记录，这由`total`字段公开):

```
http://localhost:8080/authors/1/3

{
   "content":[
      {
         "id":25,
         "age":23,
         "name":"Tylor Ruth",
         "genre":"Anthology"
      },
      {
         "id":7,
         "age":23,
         "name":"Wuth Troll",
         "genre":"Anthology"
      },
      {
         "id":22,
         "age":24,
         "name":"Kemal Ilias",
         "genre":"History"
      }
   ],
   "pageable":{
      "sort":{
         "sorted":true,
         "unsorted":false,
         "empty":false
      },
      "pageSize":3,
      "pageNumber":1,
      "offset":3,
      "paged":true,
      "unpaged":false
   },
   "totalPages":17,
   "totalElements":51,
   "last":false,
   "numberOfElements":3,
   "first":false,
   "sort":{
      "sorted":true,
      "unsorted":false,
      "empty":false
   },
   "number":1,
   "size":3,
   "empty":false
}

```

您可以很容易地只获取数据(没有`pageable`元素)作为`List<Author>`，如这个应用程序 <sup>[13](#Fn13)</sup> 。

## 项目 97:如何使用联接提取和可分页

考虑双向懒惰`@OneToMany`关联中涉及的两个实体(`Author`和`Book`)。您可以通过(`LEFT` ) `JOIN FETCH` ( **第 39 项**和**第 41 项**)在同一个查询中高效地获取相关书籍的作者。您可以通过组合(`LEFT` ) `JOIN FETCH`和`Pageable`对结果集应用分页。但是尝试实现这种组合会导致异常。例如，考虑以下查询:

```
@Transactional(readOnly = true)
@Query(value = "SELECT a FROM Author a
                JOIN FETCH a.books WHERE a.genre = ?1")
Page<Author> fetchWithBooksByGenre (String genre, Pageable pageable);

```

调用`fetchWithBooksByGenre()`会导致以下异常:

```
org.hibernate.QueryException: query specified join fetching,but the owner of the fetched association was not present in the select list [FromElement {explicit, not a collection join, fetch join, fetch non-lazy properties, classAlias = null, role = com.bookstore.entity.Author.books, tableName = book,tableAlias = books1_, origin = author author0_, columns = {author0_.id, className = com.bookstore.entity.Book}}]

```

这个异常的主要原因是来自 Spring 数据的缺失计数查询。

如果您实际上不需要一个`Page`(例如，您不关心记录的总数等等)，那么只需用`Slice`或`List`替换`Page`。这将消除这一例外。

您可以通过`countQuery`元素添加缺少的`SELECT COUNT`，如下所示:

```
@Transactional
@Query(value = "SELECT a FROM Author a
                LEFT JOIN FETCH a.books WHERE a.genre = ?1",
       countQuery = "SELECT COUNT(a) FROM Author a WHERE a.genre = ?1")
Page<Author> fetchWithBooksByGenre(String genre, Pageable pageable);

```

或者您可以通过一个特别的实体图来添加它，如下所示(关于实体图的更多细节可以在**项目 7** 、**项目 8** 和**项目 9** 中找到):

```
@Transactional
@EntityGraph(attributePaths = {"books"},
             type = EntityGraph.EntityGraphType.FETCH)
@Query(value = "SELECT a FROM Author a WHERE a.genre = ?1")
Page<Author> fetchWithBooksByGenre(String genre, Pageable pageable);

```

这一次，调用这些`fetchWithBooksByGenre()`方法之一会产生以下 SQL 语句:

```
SELECT
  author0_.id AS id1_0_0_,
  books1_.id AS id1_1_1_,
  author0_.age AS age2_0_0_,
  author0_.genre AS genre3_0_0_,
  author0_.name AS name4_0_0_,
  books1_.author_id AS author_i4_1_1_,
  books1_.isbn AS isbn2_1_1_,
  books1_.title AS title3_1_1_,
  books1_.author_id AS author_i4_1_0__,
  books1_.id AS id1_1_0__
FROM author author0_
LEFT OUTER JOIN book books1_
  ON author0_.id = books1_.author_id
WHERE author0_.genre = ?
ORDER BY author0_.name ASC

SELECT
  COUNT(author0_.id) AS col_0_0_
FROM author author0_
WHERE author0_.genre = ?

```

注意，分页发生在内存中(这些 SQL 语句中没有数据库分页)。此外，这将作为类型`HHH000104:`的消息发出

`firstResult/maxResults specified with collection fetch; applying in memory!.`

依赖于内存中的分页会导致性能下降，尤其是当提取的集合很大时。因此，使用这段代码时要格外小心。为了理解和固定`HHH000104`，请考虑**第 98 项**。

另一方面，让我们获取所有相关作者的书籍。例如:

```
@Transactional(readOnly = true)
@Query(value = "SELECT b FROM Book b
                LEFT JOIN FETCH b.author WHERE b.isbn LIKE ?1%",
       countQuery = "SELECT COUNT(b) FROM Book b WHERE b.isbn LIKE ?1%")
Page<Book> fetchWithAuthorsByIsbn(String isbn, Pageable pageable);

@Transactional(readOnly = true)
@EntityGraph(attributePaths = {"author"},
            type = EntityGraph.EntityGraphType.FETCH)
@Query(value = "SELECT b FROM Book b WHERE b.isbn LIKE ?1%")
Page<Book> fetchWithAuthorsByIsbn(String isbn, Pageable pageable);

```

这两个查询都会触发以下查询:

```
SELECT
  book0_.id AS id1_1_0_,
  author1_.id AS id1_0_1_,
  book0_.author_id AS author_i4_1_0_,
  book0_.isbn AS isbn2_1_0_,
  book0_.title AS title3_1_0_,
  author1_.age AS age2_0_1_,
  author1_.genre AS genre3_0_1_,
  author1_.name AS name4_0_1_
FROM book book0_
LEFT OUTER JOIN author author1_
  ON book0_.author_id = author1_.id
WHERE book0_.isbn LIKE ?
ORDER BY book0_.title ASC LIMIT ?

SELECT
  COUNT(book0_.id) AS col_0_0_
FROM book book0_
WHERE book0_.isbn LIKE ?

```

这次分页是由数据库完成的，这比在内存中好得多。

完整的应用程序可在 GitHub <sup>[14](#Fn14)</sup> 上获得。

## 第 98 项:如何修复 HHH000104

在**第 97 项**中，您看到`HHH000104`是一个警告，告诉您内存中正在对结果集进行分页。例如，考虑双向惰性`@OneToMany`关联中的`Author`和`Book`实体以及以下查询:

```
@Transactional
@Query(value = "SELECT a FROM Author a
                LEFT JOIN FETCH a.books WHERE a.genre = ?1",
       countQuery = "SELECT COUNT(a) FROM Author a WHERE a.genre = ?1")
Page<Author> fetchWithBooksByGenre(String genre, Pageable pageable);

```

调用`fetchWithBooksByGenre()`工作正常，除了发出以下警告:`HHH000104: firstResult/maxResults specified with collection fetch; applying in memory!`显然，从性能角度来看，在内存中分页并不好。

一般来说，不可能用 Hibernate ORM/JPA 注释来限制获取的集合的大小。例如，不可能限制`@OneToMany`集合的大小。Hibernate 不能操作集合的子集，因为它必须管理整个集合实体的状态转换。

在这种情况下，Hibernate 不能简单地使用 SQL 级别的分页来截断结果集，因为它容易截断一些`Book`行。这可能导致一个`Author`只有一个`Book`的子集。这就是为什么分页是在内存中完成的，Hibernate 可以控制整个结果集。不幸的是，特别是对于大的结果集，这会导致严重的性能损失。

由于`HHH000104`是作为警告报告的，所以在日志中很有可能会遗漏。从 Hibernate 5.2.13 开始，如果`hibernate.query.fail_on_pagination_over_collection_fetch`属性被启用，`HHH000104`被报告为异常。在 Spring Boot，该属性可以在`application.properties`中启用，如下所示:

`spring.jpa.properties.hibernate.query.fail_on_pagination_over_collection_fetch=true`

这一次，丢失`HHH000104`是不可能的，因此确保您**总是**在您的项目中启用该属性。

进一步，让我们看看如何修复`HHH000104`并在数据库上执行分页。

### 提取受管实体

您可以将结果集作为一个`Page`、`Slice`或`List`来获取。

#### 正在获取页面

首先，让我们关注`Page`并获取给定流派作者的 id:

```
@Transactional(readOnly = true)
@Query(value = "SELECT a.id FROM Author a WHERE a.genre = ?1")
Page<Long> fetchPageOfIdsByGenre(String genre, Pageable pageable);

```

进一步，让我们获取这些作者的书籍(获取的 id):

```
@Transactional(readOnly = true)
@QueryHints(value = @QueryHint(name = HINT_PASS_DISTINCT_THROUGH,
                               value = "false"))
@Query(value = "SELECT DISTINCT a FROM Author a
                LEFT JOIN FETCH a.books WHERE a.id IN ?1")
List<Author> fetchWithBooks(List<Long> authorIds);

```

或者，您可以依赖实体图:

```
@Transactional(readOnly = true)
@EntityGraph(attributePaths = {"books"},
             type = EntityGraph.EntityGraphType.FETCH)
@QueryHints(value = @QueryHint(name = HINT_PASS_DISTINCT_THROUGH,
                               value = "false"))
@Query(value = "SELECT DISTINCT a FROM Author a WHERE a.id IN ?1")
List<Author> fetchWithBooksEntityGraph(List<Long> authorIds);

```

服务方法可以如下调用这两个查询(在调用`fetchWithBooks()`之前，建议您确保`pageOfIds.getContent()`不为空):

```
@Transactional
public Page<Author> fetchAuthorsWithBooksByGenre(int page, int size) {

    Pageable pageable = PageRequest.of(
        page, size, Sort.by(Sort.Direction.ASC, "name"));

    Page<Long> pageOfIds = authorRepository
        .fetchPageOfIdsByGenre("Anthology", pageable);
    List<Author> listOfAuthors = authorRepository
        .fetchWithBooks(pageOfIds.getContent());
    Page<Author> pageOfAuthors = new PageImpl(
        listOfAuthors, pageable, pageOfIds.getTotalElements());

    return pageOfAuthors;
}

```

同样，你可以调用`fetchWithBooksEntityGraph()`。

注意，service-method 用`@Transactional`进行了注释，这意味着将以读写模式获取实体。如果需要只读实体，那么就添加`@Transactional(readOnly=true)`。

触发的 SQL 语句如下(这与实体图的用法相同):

```
SELECT
  author0_.id AS col_0_0_
FROM author author0_
WHERE author0_.genre = ?
ORDER BY author0_.name ASC LIMIT ? ?

SELECT
  COUNT(author0_.id) AS col_0_0_
FROM author author0_
WHERE author0_.genre = ?

SELECT
  author0_.id AS id1_0_0_,
  books1_.id AS id1_1_1_,
  author0_.age AS age2_0_0_,
  author0_.genre AS genre3_0_0_,
  author0_.name AS name4_0_0_,
  books1_.author_id AS author_i4_1_1_,
  books1_.isbn AS isbn2_1_1_,
  books1_.title AS title3_1_1_,
  books1_.author_id AS author_i4_1_0__,
  books1_.id AS id1_1_0__
FROM author author0_
LEFT OUTER JOIN book books1_
  ON author0_.id = books1_.author_id
WHERE author0_.id IN (?, ?, ?, ?)

```

以下是 JSON 输出示例:

```
{
   "content":[
      {
         "id":1,
         "name":"Mark Janel",
         "genre":"Anthology",
         "age":23,
         "books":[
            {
               "id":3,
               "title":"The Beatles Anthology",
               "isbn":"001-MJ"
            },
            {
               "id":8,
               "title":"Anthology From Zero To Expert",
               "isbn":"002-MJ"
            },
            {
               "id":9,
               "title":"Quick Anthology",
               "isbn":"003-MJ"
            }
         ]

      },
      {
         "id":6,
         "name":"Merci Umaal",
         "genre":"Anthology",
         "age":31,
         "books":[
            {
               "id":7,
               "title":"Ultimate Anthology",
               "isbn":"001-MU"
            },
            {
               "id":10,
               "title":"1959 Anthology",
               "isbn":"002-MU"
            }
         ]
      }
   ],
   "pageable":{
      "sort":{
         "sorted":true,
         "unsorted":false,
         "empty":false
      },
      "pageSize":2,
      "pageNumber":0,
      "offset":0,
      "paged":true,
      "unpaged":false
   },
   "totalElements":4,
   "totalPages":2,
   "last":false,
   "numberOfElements":2,
   "first":true,
   "sort":{
      "sorted":true,
      "unsorted":false,
      "empty":false
   },
   "number":0,
   "size":2,
   "empty":false
}

```

此外，您可以优化实现，以避免使用单独的`SELECT COUNT`进行偏移分页。一种快速的方法是使用`COUNT(*) OVER()`进行本地查询，如下所示:

```
@Transactional(readOnly = true)
@Query(value = "SELECT a.id AS id, COUNT(*) OVER() AS total
                FROM Author a WHERE a.genre = ?1",
       nativeQuery = true)
List<Tuple> fetchTupleOfIdsByGenre(String genre, Pageable pageable);

```

服务方法应该处理`List<Tuple>`,以便提取作者的 id 和元素的总数:

```
@Transactional
public Page<Author> fetchPageOfAuthorsWithBooksByGenreTuple(
            int page, int size) {

    Pageable pageable = PageRequest.of(page, size,
        Sort.by(Sort.Direction.ASC, "name"));

    List<Tuple> tuples = authorRepository.fetchTupleOfIdsByGenre(
        "Anthology", pageable);

    List<Long> listOfIds = new ArrayList<>(tuples.size());
    for(Tuple tuple: tuples) {
        listOfIds.add(((BigInteger) tuple.get("id")).longValue());
    }

    List<Author> listOfAuthors
        = authorRepository.fetchWithBooksJoinFetch(listOfIds);
    Page<Author> pageOfAuthors = new PageImpl(listOfAuthors, pageable,
        ((BigInteger) tuples.get(0).get("total")).longValue());

    return pageOfAuthors;
}

```

这一次，去掉了附加的`SELECT COUNT`；因此，您可以将三个`SELECT`语句减少到两个。

#### 获取切片

依靠`Slice`也是一种选择。使用`Slice`而不是`Page`消除了对这个额外的`SELECT COUNT`查询的需要，并返回页面(记录)和一些元数据，但不返回记录总数。当您需要 Slice 提供的元数据但不需要记录总数时，或者当您通过只执行一次的单独的`SELECT COUNT`获取记录总数时，这很有用。当插入/删除从不触发或很少触发时，通常会这样做。在这种情况下，记录的数量在页面导航之间不会改变，所以没有必要为每个页面触发一个`SELECT COUNT`。

这需要三至两条 SQL 语句。下面是基于`Slice`的实现:

```
@Transactional(readOnly = true)
@Query(value = "SELECT a.id FROM Author a WHERE a.genre = ?1")
Slice<Long> fetchSliceOfIdsByGenre(String genre, Pageable pageable);

@Transactional
public Slice<Author> fetchAuthorsWithBooksByGenre(int page, int size) {

    Pageable pageable = PageRequest.of(page, size,
        Sort.by(Sort.Direction.ASC, "name"));

    Slice<Long> pageOfIds = authorRepository
        .fetchSliceOfIdsByGenre("Anthology", pageable);
    List<Author> listOfAuthors = authorRepository
        .fetchWithBooks(pageOfIds.getContent());
    Slice<Author> sliceOfAuthors = new SliceImpl(
        listOfAuthors, pageable, pageOfIds.hasNext());

    return sliceOfAuthors;
}

```

这将只触发两个 SQL `SELECT`语句。您没有关于总行数的信息，但是您知道是否有更多的页面。示例 JSON 如下所示(检查`last`元素):

```
{
   "content":[
      {
         "id":1,
         "name":"Mark Janel",
         "genre":"Anthology",
         "age":23,
         "books":[
            {
               "id":3,
               "title":"The Beatles Anthology",
               "isbn":"001-MJ"
            },
            {
               "id":8,
               "title":"Anthology From Zero To Expert",
               "isbn":"002-MJ"
            },
            {
               "id":9,
               "title":"Quick Anthology",
               "isbn":"003-MJ"
            }
         ]
      },
      {
         "id":6,
         "name":"Merci Umaal",
         "genre":"Anthology",
         "age":31,
         "books":[
            {
               "id":7,
               "title":"Ultimate Anthology",
               "isbn":"001-MU"
            },
            {
               "id":10,
               "title":"1959 Anthology",
               "isbn":"002-MU"
            }
         ]
      }

   ],
   "pageable":{
      "sort":{
         "sorted":true,
         "unsorted":false,
         "empty":false
      },
      "pageSize":2,
      "pageNumber":0,
      "offset":0,
      "paged":true,
      "unpaged":false
   },
   "numberOfElements":2,
   "first":true,
   "last":false,
   "sort":{
      "sorted":true,
      "unsorted":false,
      "empty":false
   },
   "number":0,
   "size":2,
   "empty":false
}

```

#### 获取列表

我们也可以作为一个`List<Author>`来获取数据。当您不需要由`Page`或`Slice`提供的任何元数据时，这很有用:

```
@Transactional(readOnly = true)
@Query(value = "SELECT a.id FROM Author a WHERE a.genre = ?1")
List<Long> fetchListOfIdsByGenre(String genre, Pageable pageable);

```

这一次，您使用`Pageable`只是为了通过 Spring help 添加用于排序和分页的 SQL 子句。特别是在分页时，Spring 会根据方言选择合适的 SQL 子句(例如，对于 MySQL，它会添加`LIMIT`)。移除`Pageable`并使用原生查询也是一种选择。

调用`fetchListOfIdsByGenre()`的服务方法如下:

```
@Transactional
public List<Author> fetchListOfAuthorsWithBooksByGenre(int page, int size) {
    Pageable pageable = PageRequest.of(page, size,
        Sort.by(Sort.Direction.ASC, "name"));

    List<Long> listOfIds = authorRepository.fetchListOfIdsByGenre(
        "Anthology", pageable);
    List<Author> listOfAuthors
        = authorRepository.fetchWithBooksJoinFetch(listOfIds);

    return listOfAuthors;
}

```

这将触发以下两个`SELECT`语句:

```
SELECT
  author0_.id AS col_0_0_
FROM author author0_
WHERE author0_.genre = ?
ORDER BY author0_.name
ASC LIMIT ? ?

SELECT
  author0_.id AS id1_0_0_,
  books1_.id AS id1_1_1_,
  author0_.age AS age2_0_0_,
  author0_.genre AS genre3_0_0_,
  author0_.name AS name4_0_0_,
  books1_.author_id AS author_i4_1_1_,
  books1_.isbn AS isbn2_1_1_,
  books1_.title AS title3_1_1_,
  books1_.author_id AS author_i4_1_0__,
  books1_.id AS id1_1_0__
FROM author author0_
LEFT OUTER JOIN book books1_
  ON author0_.id = books1_.author_id
WHERE author0_.id IN (?, ?)

```

和一个示例结果集的 JSON 表示:

```
[
   {

      "id":3,
      "name":"Quartis Young",
      "genre":"Anthology",
      "age":51,
      "books":[
         {
            "id":5,
            "title":"Anthology Of An Year",
            "isbn":"001-QY"
         }
      ]
   },
   {
      "id":5,
      "name":"Pyla Lou",
      "genre":"Anthology",
      "age":41,
      "books":[
         {
            "id":6,
            "title":"Personal Anthology",
            "isbn":"001-KL"
         }
      ]
   }
]

```

GitHub <sup>[15](#Fn15)</sup> 上有完整的应用程序。

## 第 99 项:如何实现 Slice <t>findAll()</t>

Spring Boot 提供了基于偏移量的内置分页机制，该机制返回一个`Page`或`Slice`。每个 API 代表一个数据页面和一些页面元数据。主要区别在于，`Page`包含记录的总数，而`Slice`只能判断是否还有另一页可用。对于`Page`，Spring Boot 提供了一个`findAll()`方法，它可以接受一个`Pageable`和/或一个`Specification`或`Example`作为参数。为了创建一个包含记录总数的`Page`,这个方法触发了一个`SELECT COUNT`额外的查询，紧接着这个查询用于获取当前页面的数据。这可能导致性能损失，因为每次请求页面时都会触发`SELECT COUNT`查询。为了避免这个额外的查询，Spring Boot 提供了一个更宽松的 API，即`Slice` API。使用`Slice`而不是`Page`消除了对这个额外的`SELECT COUNT`查询的需要，并返回页面(记录)和一些页面元数据，但不返回记录总数。因此，虽然`Slice`不知道记录的总数，但它仍然可以知道在当前页之后是否还有另一页可用，或者这是最后一页。问题是`Slice`对于包含 SQL `WHERE`子句的查询(包括那些使用内置在 Spring 数据中的查询构建器机制的查询)工作良好，但是对于`findAll()`就不行了。这个方法仍然会返回一个`Page`而不是一个`Slice`，所以对于`Slice<T> findAll(...)`会触发`SELECT COUNT`查询。

### 快速实施

获取所有数据的`Slice`的快速解决方案包括定义一个依赖于显式查询(JPQL)和`Pageable`对象的方法。

#### 提取切片<*实体* >

考虑将这个方法命名为`fetchAll()`。您可以将它添加到一个存储库中，如下所示(`AuthorRepository`是对应于`Author`实体的存储库):

```
@Repository
@Transactional(readOnly = true)
public interface AuthorRepository
                extends PagingAndSortingRepository<Author, Long> {

    @Query(value = "SELECT a FROM Author a")
    Slice<Author> fetchAll(Pageable pageable);
}

```

调用`fetchAll()`将触发如下的单个`SELECT`查询:

```
SELECT
  author0_.id AS id1_0_,
  author0_.age AS age2_0_,
  author0_.genre AS genre3_0_,
  author0_.name AS name4_0_
FROM author author0_
ORDER BY author0_.age ASC
LIMIT ? ?

```

调用`fetchAll()`的服务方法可以编写如下:

```
public Slice<Author> fetchNextSlice(int page, int size) {

    return authorRepository.fetchAll(PageRequest.of(page, size,
                Sort.by(Sort.Direction.ASC, "age")));
}

```

考虑类型为`localhost:8080/authors/{` `page` `}/{` `size` `}`的 REST 端点和`author`表中总共 51 条记录。对大小为 3 的第二页的请求可以作为`localhost:8080/authors/1/3`被触发，结果(作为 JSON)如下:

```
{
   "content":[
      {
         "id":7,
         "age":23,
         "name":"Wuth Troll",
         "genre":"Anthology"
      },

      {
         "id":25,
         "age":23,
         "name":"Tylor Ruth",
         "genre":"Anthology"
      },
      {
         "id":16,
         "age":24,
         "name":"Joana Leonte",
         "genre":"History"
      }
   ],
   "pageable":{
      "sort":{
         "sorted":true,
         "unsorted":false,
         "empty":false
      },
      "pageSize":3,
      "pageNumber":1,
      "offset":3,
      "paged":true,
      "unpaged":false
   },
   "numberOfElements":3,
   "first":false,
   "last":false,
   "sort":{
      "sorted":true,
      "unsorted":false,
      "empty":false
   },
   "number":1,
   "size":3,
   "empty":false
}

```

没有关于记录总数的信息。但是，`"last": false`表示这不是最后一页。

#### 正在获取切片<*dto*T2】

考虑以下 Spring Boot 投影(DTO):

```
public interface AuthorDto {

    public String getName();

    public int getAge();
}

```

考虑将这个方法命名为`fetchAllDto()`。您可以将它添加到一个存储库中，如下所示(`AuthorRepository`是对应于`Author`实体的存储库):

```
@Repository
@Transactional(readOnly = true)
public interface AuthorRepository
                extends PagingAndSortingRepository<Author, Long> {

    @Query(value = "SELECT a.name as name, a.age as age FROM Author a")
    Slice<AuthorDto> fetchAllDto(Pageable pageable);
}

```

调用`fetchAllDto()`将触发如下的单个`SELECT`查询:

```
SELECT
  author0_.name AS col_0_0_,
  author0_.age AS col_1_0_
FROM author author0_
ORDER BY author0_.age ASC
LIMIT ? ?

```

调用`fetchAllDto()`的服务方法可以编写如下:

```
public Slice<AuthorDto> fetchNextSlice(int page, int size) {

    return authorRepository.fetchAllDto(PageRequest.of(page, size,
                Sort.by(Sort.Direction.ASC, "age")));
}

```

考虑类型为`localhost:8080/authors/{` `page` `}/{` `size` `}`的 REST 端点和`author`表中总共 51 条记录。对大小为 3 的第二页的请求可以作为`localhost:8080/authors/1/3`被触发，结果(作为 JSON)如下:

```
{
   "content":[
      {
         "age":23,
         "name":"Wuth Troll"
      },
      {
         "age":23,
         "name":"Tylor Ruth"
      },
      {
         "age":24,
         "name":"Joana Leonte"
      }
   ],
   "pageable":{
      "sort":{
         "sorted":true,
         "unsorted":false,
         "empty":false
      },
      "pageSize":3,
      "pageNumber":1,
      "offset":3,
      "paged":true,
      "unpaged":false
   },
   "numberOfElements":3,
   "first":false,
   "last":false,
   "sort":{
      "sorted":true,
      "unsorted":false,
      "empty":false
   },
   "number":1,
   "size":3,
   "empty":false
}

```

GitHub <sup>[16](#Fn16)</sup> 上有源代码。

### Slice <t>findAll(可分页可分页)的实现</t>

将方法名保存为`findAll`意味着您必须创建它的自定义实现。首先，编写一个`abstract`类，并如下定义`findAll()`:

```
@Repository
@Transactional(readOnly = true)
public abstract class SlicePagingRepositoryImplementation<T> {

    @Autowired
    private EntityManager entityManager;

    private final Class<T> entityClass;

    public SlicePagingRepositoryImplementation(Class<T> entityClass) {
        this.entityClass = entityClass;
    }

    public Slice<T> findAll(Pageable pageable) {

        return findAll(pageable, entityClass);
    }
    ...

```

`findAll(Pageable, Class<T>)`是一个负责构建查询的`private`方法。一种简单的方法如下:

```
private Slice<T> findAll(Pageable pageable, Class<T> entityClass) {

    final String sql = "SELECT e FROM " + entityClass.getSimpleName() + " e";
    TypedQuery<T> query = entityManager.createQuery(sql, entityClass);

    return this.readSlice(query, pageable);
}

```

最后，`readSlice()`是一个`private`方法，负责通过`SliceImpl`和给定的`query`创建一个`Slice<T>`:

```
private Slice<T> readSlice(final TypedQuery<T> query,
                                        final Pageable pageable) {

    query.setFirstResult((int) pageable.getOffset());
    query.setMaxResults(pageable.getPageSize() + 1);

    final List<T> content = query.getResultList();

    boolean hasNext = content.size() == (pageable.getPageSize() + 1);
    if (hasNext) {
        content.remove(content.size() - 1);
    }

    return new SliceImpl<>(content, pageable, hasNext);
}

```

完整的实现可在 GitHub <sup>[17](#Fn17)</sup> 上获得。除此之外，还有其他几个实现，如下所示:

*   实现 <sup>[18](#Fn18)</sup> 基于`CriteriaBuilder`而不是硬编码的 SQL

*   实现 <sup>[19](#Fn19)</sup> 让你提供一个`Sort`

*   实现 <sup>[20 个](#Fn20)</sup> ，允许你提供一个`Sort`和`Specification`

*   实现 <sup>[21](#Fn21)</sup> ，允许你提供一个`Sort`、`LockModeType`、`QueryHints`和`Specification`

*   从`SimpleJpaRepository`实现 <sup>[22](#Fn22)</sup> 覆盖`Page<T> readPage(...)`方法

## 项目 100:如何实现键集分页

建议在继续之前阅读第 94 项。

对于大型数据集，偏移分页会带来严重的性能损失，特别是遍历已经显示的记录以达到所需的偏移。在这种情况下，最好依靠键集分页，它在不断增长的数据中保持“恒定”的时间。下面列出了键集分页的优点和缺点。

缺点:

*   无法获取任意页面

*   编写`WHERE`子句并不(总是)容易

优点:

*   搜索上一页的最后一项

*   仅提取以下行

*   无限滚动机制

*   插入不会造成页面偏差

另一个要考虑的缺点是，Spring Boot 不提供对键集分页的内置支持。实际上，依赖偏移量而不是键集分页的主要原因是缺少工具支持。

考虑`Author`实体对应的`author`表，如图 [13-4](#Fig4) 所示。

![../images/487471_1_En_13_Chapter/487471_1_En_13_Fig4_HTML.jpg](../images/487471_1_En_13_Chapter/487471_1_En_13_Fig4_HTML.jpg)

图 13-4

作者实体表

目标是实现键集分页，以实体和 DTO 的形式获取作者。

选择一列作为最近访问的记录/行(如`id`列),并在`WHERE`和`ORDER BY`子句中使用该列。依托`id`列的习惯用法如下(多列排序遵循同样的思路):

```
SELECT ...
  FROM ...
 WHERE id < {last_seen_id}
 ORDER BY id DESC
 LIMIT {how_many_rows_to_fetch}

```

或者，像这样:

```
SELECT ...
  FROM ...
 WHERE ...
   AND id < {last_seen_id}
 ORDER BY id DESC
 LIMIT {how_many_rows_to_fetch}

```

例如，在这种情况下应用第一个习惯用法可能会导致以下本机查询(第一个查询获取实体；第二个获取 DTO):

```
@Repository
@Transactional(readOnly = true)
public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Query(value = "SELECT * FROM author AS a WHERE a.id < ?1
             ORDER BY a.id DESC LIMIT ?2", nativeQuery = true)
    List<Author> fetchAll(long id, int limit);

    @Query(value = "SELECT name, age FROM author AS a WHERE a.id < ?1
             ORDER BY a.id DESC LIMIT ?2", nativeQuery = true)
    List<AuthorDto> fetchAllDto(long id, int limit);
}

```

在分页的情况下，确定的排序顺序是强制性的，所以不要忘记`ORDER BY`子句。

`LIMIT`子句由`MySQL`和`PostgreSQL`识别。SQL Server 支持`SELECT TOP`子句，Oracle 使用`ROWNUM`或`ROWS FETCH NEXT` `n` `ROWS ONLY`。

`AuthorDto`是一个简单的 Spring Boot 投影:

```
public interface AuthorDto {

    public String getName();

    public int getAge();
}

```

此外，服务方法可以调用`fetchAll()`和`fetchAllDto()`，如下所示:

```
public List<Author> fetchNextPage(long id, int limit) {
    return authorRepository.fetchAll(id, limit);
}

public List<AuthorDto> fetchNextPageDto(long id, int limit) {
    return authorRepository.fetchAllDto(id, limit);
}

```

REST 控制器端点如`localhost:8080/authors/{` `id` `}/{` `limit` `}`可以帮助你测试这些服务方法。例如，通过`localhost:8080/authors/5/3`调用`fetchNextPage()`将输出以下内容:

```
[
   {
      "id":4,
      "age":34,
      "name":"Joana Nimar",
      "genre":"History"
   },
   {
      "id":3,
      "age":51,
      "name":"Quartis Young",
      "genre":"Anthology"
   },
   {
      "id":2,
      "age":43,
      "name":"Olivia Goy",
      "genre":"Horror"
   }
]

```

图 [13-5](#Fig5) 所示的时间-性能趋势图显示，键集分页比偏移量分页快得多。考虑有 100 万条记录的`author`表。我们获取第一页(0)、第 5000 页和第 9999 页，共 100 条记录。

![../images/487471_1_En_13_Chapter/487471_1_En_13_Fig5_HTML.jpg](../images/487471_1_En_13_Chapter/487471_1_En_13_Fig5_HTML.jpg)

图 13-5

失调与键集的关系

GitHub <sup>[23](#Fn23)</sup> 上有源代码。

## 第 101 项:如何向键集分页添加下一页按钮

建议在继续之前阅读第**项 100** 。

键集分页不依赖于元素的总数。但是，通过一点小技巧，对客户机的响应可以包含一条信息，表明是否有更多的记录要获取。客户端可以使用该信息来显示下一页按钮。例如，`localhost:8080/authors/5/3`这样的 REST 控制器端点将返回三条记录(ID*4*、 *3* 和 *2* )，但是在`author`表中还有一条记录(ID *1* )。响应的`last`元素表示这不是最后一页:

```
{
   "authors":[
      {
         "id":4,
         "age":34,
         "name":"Joana Nimar",
         "genre":"History"
      },
      {
         "id":3,
         "age":51,
         "name":"Quartis Young",
         "genre":"Anthology"
      },
      {
         "id":2,
         "age":43,
         "name":"Olivia Goy",
         "genre":"Horror"
      }
   ],
   "last":false
}

```

因此，您可以通过`localhost:8080/authors/2/3`获取下一页。这一次，响应将包含一条记录(ID *1* ),并且`last`元素是`true`。这意味着这是最后一页，因此应禁用下一页按钮:

```
{
   "authors":[
      {
         "id":1,
         "age":23,
         "name":"Mark Janel",
         "genre":"Anthology"
      }
   ],
   "last":true
}

```

但是，如何添加`last`元素呢？首先，您定义一个类，该类对获取的数据和额外的元素进行分组(在本例中是`last`，但是可以添加更多的元素):

```
public class AuthorView {

    private final List<Author> authors;
    private final boolean last;

    public AuthorView(List<Author> authors, boolean last) {
        this.authors = authors;
        this.last = last;
    }

    public List<Author> getAuthors() {
        return authors;
    }

    public boolean isLast() {
        return last;
    }
}

```

此外，服务方法获取`limit + 1`记录并如下确定`last`的值:

```
public AuthorView fetchNextPage(long id, int limit) {
    List<Author> authors = authorRepository.fetchAll(id, limit + 1);

    if (authors.size() == (limit + 1)) {
        authors.remove(authors.size() - 1);
        return new AuthorView(authors, false);
    }

    return new AuthorView(authors, true);
}

```

最后，您修改 REST 控制器端点以返回`List<AuthorView>`而不是`List<Author>`:

```
@GetMapping("/authors/{id}/{limit}")
public AuthorView fetchAuthors(
            @PathVariable long id, @PathVariable int limit) {

    return bookstoreService.fetchNextPage(id, limit);
}

```

搞定了。GitHub <sup>[24](#Fn24)</sup> 上有源代码。它还包括 DTO 案件。

## 第 102 项:如何通过 ROW_NUMBER()实现分页

到目前为止，分页主题已经在几篇文章中讨论过了。另一种获取页面数据的方法是使用`ROW_NUMBER()`窗口函数，这是在**项目 119** 中引入的。如果你不熟悉`ROW_NUMBER()`，最好把这一项推迟到你看完**第 119 项**之后。

考虑众所周知的`Author`实体和下面的 DTO:

```
public interface AuthorDto {

    public String getName();
    public int getAge();
}

```

下面的本地查询是一个通过`ROW_NUMBER()`获取页面作者的例子:

```
@Repository
@Transactional(readOnly = true)
public interface AuthorRepository
        extends PagingAndSortingRepository<Author, Long> {

    @Query(value = "SELECT * FROM (SELECT name, age, "
              + "ROW_NUMBER() OVER (ORDER BY age) AS row_num "
              + "FROM author) AS a WHERE row_num BETWEEN ?1 AND ?2",
           nativeQuery = true)
    List<AuthorDto> fetchPage(int start, int end);
}

```

或者，如果您还需要获取总行数，那么使用`total`字段和使用`COUNT(*) OVER()`窗口函数的查询来丰富 d to，如下所示:

```
public interface AuthorDto {

    public String getName();
    public int getAge();
    public long getTotal();
}

@Repository
@Transactional(readOnly = true)
public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Query(value = "SELECT * FROM (SELECT name, age, "
           + "COUNT(*) OVER() AS total, "
           + "ROW_NUMBER() OVER (ORDER BY age) AS row_num FROM author) AS a "
           + "WHERE row_num BETWEEN ?1 AND ?2",
           nativeQuery = true)
    List<AuthorDto> fetchPage(int start, int end);
}

```

完整的应用程序可在 GitHub <sup>[25](#Fn25)</sup> 上获得。

<aside aria-label="Footnotes" class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

[T2`https://use-the-index-luke.com/no-offset`](https://use-the-index-luke.com/no-offset)

  [2](#Fn2_source)

[T2`https://www.slideshare.net/MarkusWinand/p2d2-pagination-done-the-postgresql-way?ref=https://use-the-index-luke.com/no-offset`](https://www.slideshare.net/MarkusWinand/p2d2-pagination-done-the-postgresql-way%253Fref?https://use-the-index-luke.com/no-offset)

  [3](#Fn3_source)

[hibernate pringb 的碳氢化合物设置页离子](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootOffsetPagination)

  [4](#Fn4_source)

[T2`https://www.percona.com/blog/2007/08/28/to-sql_calc_found_rows-or-not-to-sql_calc_found_rows/`](https://www.percona.com/blog/2007/08/28/to-sql_calc_found_rows-or-not-to-sql_calc_found_rows/)

  [5](#Fn5_source)

[T2`https://twitter.com/vlad_mihalcea/status/1207887006883340288`](https://twitter.com/vlad_mihalcea/status/1207887006883340288)

  [6](#Fn6_source)

[hibernate pringb bootpagedtooffs pagination wf](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootPageDtoOffsetPaginationWF)

  [7](#Fn7_source)

[hibernate pringgb 东向字节 paging wf](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootListDtoOffsetPaginationWF)

  [8](#Fn8_source)

[hibernate pringb ootpageentityofset page text racolumwf](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootPageEntityOffsetPaginationExtraColumnWF)

  [9](#Fn9_source)

[hibernate pringb 东列表蒂米什图定页文本 racolumwf](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootListEntityOffsetPaginationExtraColumnWF)

  [10](#Fn10_source)

[hibernate pringb bootpagedtooffset 分页](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootPageDtoOffsetPagination)

  [11](#Fn11_source)

[hibernate pringb otlistdtooffset 分页](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootListDtoOffsetPagination)

  [12](#Fn12_source)

[hibernate pringb bootpageentity yoff set action text racolumn](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootPageEntityOffsetPaginationExtraColumn)

  [13](#Fn13_source)

[hibernate pringb 东列表蒂米什图设置页面文本 racolm](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootListEntityOffsetPaginationExtraColumn)

  [14](#Fn14_source)

[hibernate pringb oojoinfetchage able](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootJoinFetchPageable)

  [15](#Fn15_source)

[hibernate pringb ooth 000104](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootHHH000104)

  [16](#Fn16_source)

[hibernate pringb ootbar 片剂冲裁剂全部](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootSliceAllViaFetchAll)

  [17](#Fn17_source)

[hibernate pringb ootball 植入物骨架](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootSliceAllSimpleSql)

  [18](#Fn18_source)

[hibernate pringb ootbladelrit riabuilder](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootSliceAllCriteriaBuilder)

  [19](#Fn19_source)

[hibernate pringb ootbar 重写重建者 t](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootSliceAllCriteriaBuilderAndSort)

  [20](#Fn20_source)

[hibernate pringb ootbladelrit rebuildersortan ds spec](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootSliceAllCriteriaBuilderSortAndSpecification)

  [21](#Fn21_source)

[hibernate pringb ootbladelritte rebuilders ortan dsspec dzquerryhints](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootSliceAllCriteriaBuilderSortAndSpecificationAndQueryHints)

  [22](#Fn22_source)

[hibernate pringb ootbladelrit 重建 jparerepository](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootSliceAllCriteriaBuilderSimpleJpaRepository)

  [23](#Fn23_source)

[hibernate pringb 前视图页离子](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootKeysetPagination)

  [24](#Fn24_source)

[hibernate pringb bootectpagitat ionnextpage](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootKeysetPaginationNextPage)

  [25](#Fn25_source)

[hibernate pringb bootinactitionrow number](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootPaginationRowNumber)

 </aside>**