# 6.连接和交易

## 第 60 项:如何将连接获取延迟到真正需要的时候

从 Hibernate 5.2.10 开始，数据库连接获取可以推迟到真正需要的时候。

关于 Spring 事务传播的高超指南，请查看**附录 G** 。

在*资源本地*(单个数据源)的情况下，Hibernate 将在事务开始后立即获取 JDBC 事务的数据库连接(例如，在 Spring 中，用`@Transactional`标注的方法在被调用后立即获取数据库连接)。

在*资源本地*中，因为 Hibernate 需要检查 JDBC `Connection`自动提交状态，所以会立即获得一个数据库连接。如果这是`true`，那么 Hibernate 将禁用它。

实际上，在当前事务的第一个 JDBC 语句被触发之前，数据库连接对应用程序是无用的；如果在第一个 JDBC 语句之前有许多或/和耗时的任务，在这段时间内保持数据库连接不使用会导致性能下降，这会产生很大的影响。

为了防止这种性能损失，您可以通知 Hibernate 您禁用了自动提交，因此不需要检查。为此，请遵循以下两个步骤:

*   关闭自动提交。例如，检查类型为`setAutoCommit(boolean commit)`的方法的池连接，并将其设置为`false`，例如`HikariConfiguartion#setAutoCommit(false)`。

*   将特定于 Hibernate 的属性`hibernate.connection.provider_disables_autocommit`设置为`true`

默认情况下，Spring Boot 依赖 HikariCP，您可以通过`spring.datasource.hikari.auto-commit`属性关闭`application.properties`中的自动提交。因此，需要将以下两个设置添加到`application.properties`:

```
spring.datasource.hikari.auto-commit=false
spring.jpa.properties.hibernate.connection.provider_disables_autocommit=true

```

根据经验，对于*资源本地* JPA 事务，配置连接池(例如 HikariCP)来禁用自动提交并将`hibernate.connection.provider_disables_autocommit`设置为`true`总是一个好的做法。所以，在你所有的应用中使用*资源本地*吧！

注意不要将`hibernate.connection.provider_disables_autocommit`设置为`true`，然后忘记禁用自动提交模式！Hibernate 也不会禁用！这意味着每个 SQL 语句都将在自动提交模式下执行，没有工作单元事务可用。

要查看连接获取是如何延迟的，请考虑以下方法，该方法旨在隔离从 HikariCP 连接池中获取连接时的主时隙。考虑阅读这个方法的注释，因为它们解释了正在发生的事情:

```
@Transactional
public void doTimeConsumingTask() throws InterruptedException {

    System.out.println("Waiting for a time-consuming
                        task that doesn't need a database connection ...");

    // we use a sleep of 40 seconds just to capture HikariCP logging status
    // which take place at every 30 seconds - this will reveal if
    // the connection was opened (acquired from the connection pool) or not
    Thread.sleep(40000);

    System.out.println("Done, now query the database ...");
    System.out.println("The database connection should be acquired now ...");

    Author author = authorRepository.findById(1L).get();

    // at this point, the connection should be open
    Thread.sleep(40000);

    author.setAge(44);
}

```

在不延迟连接获取的情况下调用该方法将显示如图 [6-1](#Fig1) 所示的输出(连接被立即获取并保持打开，直到第一个 SQL 被触发)。

![../images/487471_1_En_6_Chapter/487471_1_En_6_Fig1_HTML.jpg](../images/487471_1_En_6_Chapter/487471_1_En_6_Fig1_HTML.jpg)

图 6-1

立即获取连接

在启用连接获取的情况下调用相同的方法将会发现，就在第一个 SQL 被触发之前获取了连接。同时，这个连接可以被另一个线程使用，如图 [6-2](#Fig2) 所示。

![../images/487471_1_En_6_Chapter/487471_1_En_6_Fig2_HTML.jpg](../images/487471_1_En_6_Chapter/487471_1_En_6_Fig2_HTML.jpg)

图 6-2

延迟连接获取

GitHub <sup>[1](#Fn1)</sup> 上有源代码。

## 第 61 项:@Transactional(readOnly=true)的实际工作原理

考虑带有`id age`、`name`和`genre`字段的`Author`实体。

接下来，使用传统的`AuthorRepository`和`BookstoreService`实体，您可以通过`genre`快速加载第一个`Author`，如下所示:

```
@Repository
public interface AuthorRepository extends JpaRepository<Author, Long> {

    Author findFirstByGenre(String genre);
}

@Service
public class BookstoreService {

    public void fetchAuthor() {
        Author author = authorRepository.findFirstByGenre("Anthology");
    }
}

```

但是，这里缺少了什么吗？！是的，没有事务上下文。`findFirstByGenre()`方法必须包装在事务上下文中；所以，你要考虑`@Transactional`。

通过`@Transactional`，您明确划分了数据库事务边界，并确保一个数据库连接将用于整个数据库事务持续时间。所有 SQL 语句都将使用这个隔离连接，并且都将在相同的持久性上下文范围内运行。

一般来说，JPA 不会对读操作强制执行事务(它只是通过抛出一个有意义的异常来对写操作强制执行事务)，但这意味着:

*   您允许自动提交模式控制数据访问的行为(此行为可能会因 JDBC 驱动程序、数据库以及连接池的实现和设置而有所不同)。

*   一般来说，如果自动提交被设置为`true`，那么每个 SQL 语句将必须在单独的物理数据库事务中执行，这可能意味着每个语句有不同的连接(例如，在不支持*每线程连接*的环境中，具有两个`SELECT`语句的方法需要两个物理数据库事务和两个单独的数据库连接)。每个 SQL 语句在执行后都会自动提交。

*   显式设置事务隔离级别可能会导致意外行为。

*   将 auto-commit 设置为`true`只有在您执行一条只读 SQL 语句时才有意义(就像我们上面做的那样)，但是它不会带来任何显著的好处。因此，即使在这种情况下，最好还是依赖显式(声明性)事务。

    根据经验，使用显式(声明性)事务，甚至是只读语句(例如`SELECT`)来定义适当的事务上下文。非事务上下文指的是没有明确事务边界的上下文，**不是**指的是没有物理数据库事务的上下文。所有数据库语句都在物理数据库事务的上下文中执行。通过省略显式事务边界(事务上下文、begin/commit/rollback ),您至少会使应用程序面临以下对性能有影响的缺点:

*   默认情况下，Hibernate 无论如何都会关闭`autocommit`模式(`autocommit=false`)，并打开一个 JDBC 事务。SQL 语句在这个 JDBC 事务内部运行，然后 Hibernate 关闭连接。但是它不关闭事务，事务保持未提交状态(保持挂起状态)，这允许数据库供应商实现或连接池采取行动。(JDBC 规范没有为未决事务强加某种行为。例如，MySQL 在 Oracle 提交事务时回滚事务。)您不应该冒这个风险，因为根据经验，您总是必须通过提交或回滚来确保事务结束。

*   在许多小事务的情况下(在有许多并发请求的应用程序中很常见)，为每个 SQL 语句启动和结束一个物理数据库事务意味着性能开销。

*   在非事务上下文中运行的方法很容易被开发人员为了写数据而修改。(在类/方法级别通过`@Transactional(readOnly=true)`拥有一个事务上下文充当团队成员的标志，表明不应该向该方法添加任何写操作，并且如果该标志被忽略，则阻止写操作。)

*   您无法从底层数据访问层的 Spring 优化中受益(例如，flush mode 被设置为`MANUAL`，因此脏检查被跳过)。

*   您无法从针对只读事务的特定于数据库的优化中受益。

*   您没有遵循默认情况下用`@Transactional(readOnly=true)`注释的只读 Spring 内置查询方法。

*   从 Hibernate 5.2.10 开始，您可以延迟连接获取(**第 60 项**)，这需要禁用`autocommit`。

*   没有对一组只读 SQL 语句的 ACID 支持。

    意识到这些缺点(这个列表并不详尽)应该有助于您明智地在非事务性上下文和用于只读语句的经典数据库 ACID 事务之间做出决定。

好的，那么应该添加`@Transactional`，但是`readOnly`应该设置为`false`(默认)还是`true`？根据该设置，实体以*读写*模式或*只读*模式加载。除了读写模式和只读模式之间的明显区别之外，另一个主要区别发生在 Hibernate 底层。Hibernate 通过所谓的*水合状态*或*加载状态*来完成在持久性上下文中加载实体。*水合*是将取出的数据库结果集物化为一个`Object[]`的过程。实体在持久性上下文中被具体化。接下来会发生什么取决于读取模式:

*   *读写*模式:在这种模式下，实体及其水合状态在持久性上下文中都是可用的。它们在持久性上下文生命周期内(直到持久性上下文关闭)或者直到实体被分离时都是可用的。*水合状态*是脏检查机制、无版本乐观锁定机制和二级高速缓存所需要的。污垢检查机制利用了冲洗时的水合状态(如果您需要复习一下冲洗是如何工作的，请参考**附录 H** )。它只是将当前实体的状态与相应的水合状态进行比较，如果它们不相同，Hibernate 就会触发适当的`UPDATE`语句。无版本乐观锁定机制利用水合状态来构建过滤谓词的`WHERE`子句。二级高速缓存通过分解的水合状态表示高速缓存条目。在读写模式下，实体具有`MANAGED`状态。

*   *只读*模式:在这种模式下，水合状态被从内存中丢弃，只有实体被保存在持久性上下文中(这些是*只读*实体)。显然，这意味着自动脏检查和无版本乐观锁定机制被禁用。在只读模式下，实体具有`READ_ONLY`状态。此外，没有自动冲洗，因为 Spring Boot 将冲洗模式设置为`MANUAL`。

    只有当 Spring 版本是 5.1 或更高版本并且您使用了`@Transactional(readOnly=true)`时，只读模式才会以这种方式运行。或者，如果通过`@QueryHint`、`Session.setDefaultReadOnly(true)`或`org.hibernate.readOnly`设置只读模式，JPA 查询提示如下:

```
// @QueryHint in repository at query-level
@QueryHints(value = {
      @QueryHint(
            name = org.hibernate.jpa.QueryHints.HINT_READONLY, value = "true")
})

// setDefaultReadOnly
Session session = entityManager.unwrap(Session.class);
session.setDefaultReadOnly(true);

// JPA hint
List<Foo> foo = entityManager.createQuery("", Foo.class)
      .setHint(QueryHints.HINT_READONLY, true).getResultList();

```

在 5.1 之前的版本中，Spring 不会将只读模式传播到 Hibernate。因此，水合状态保留在持久上下文的记忆中。Spring 仅设置`FlushType.MANUAL`，因此自动脏检查机制不会采取行动，因为没有自动冲洗时间。在内存中保持水合状态会带来性能损失(垃圾收集器必须收集这些数据)。这是至少升级到 Spring 5.1 的充分理由。

此外，让我们尝试两种读取模式，看看持久性上下文揭示了什么。下面的代码是针对 Spring Boot 2.1.4 运行的，它需要 Spring Framework 5.1.x。为了检查持久性上下文，将使用下面的 helper 方法(该方法将当前持久性上下文作为`org.hibernate.engine.spi.PersistenceContext`的实例返回):

```
private org.hibernate.engine.spi.PersistenceContext
          getPersistenceContext() {

    SharedSessionContractImplementor sharedSession = entityManager.unwrap(
        SharedSessionContractImplementor.class
    );

    return sharedSession.getPersistenceContext();
}

```

使用`PersistenceContext`允许您探索它的 API 并检查持久性上下文内容。例如，让我们显示以下信息:

*   当前阶段(这只是在检查持久性上下文时标记时隙的字符串)

*   通过`toString()`提取的实体

*   如果持久性上下文只包含非只读实体

*   实体状态(`org.hibernate.engine.spi.Status`)

*   实体的水合/负载状态

让我们将这些信息分组到一个帮助器方法中:

```
private void displayInformation(String phase, Author author) {

    System.out.println("Phase:" + phase);
    System.out.println("Entity: " + author);

    org.hibernate.engine.spi.PersistenceContext
        persistenceContext = getPersistenceContext();
    System.out.println("Has only non read entities : "
        + persistenceContext.hasNonReadOnlyEntities());

    EntityEntry entityEntry = persistenceContext.getEntry(author);
    Object[] loadedState = entityEntry.getLoadedState();
    Status status = entityEntry.getStatus();

    System.out.println("Entity entry : " + entityEntry);
    System.out.println("Status: " + status);
    System.out.println("Loaded state: " + Arrays.toString(loadedState));
}

```

此外，将`readOnly`设置为`false`并运行以下服务方法(在以下示例中，我们出于测试目的强制刷新，但手动刷新是一种*代码气味*，应该避免):

```
@Transactional
public void fetchAuthorReadWriteMode() {
    Author author = authorRepository.findFirstByGenre("Anthology");

    displayInformation("After Fetch", author);

    author.setAge(40);

    displayInformation("After Update Entity", author);

    // force flush - triggering manual flush is
    // a code smell and should be avoided
    // in this case, by default, flush will take
    // place before transaction commit
    authorRepository.flush();

    displayInformation("After Flush", author);
}

```

调用`fetchAuthorReadWriteMode()`会触发一个`SELECT`和一个`UPDATE`语句。输出如下所示:

```
-------------------------------------
Phase:After Fetch
Entity: Author{id=1, age=23, name=Mark Janel, genre=Anthology}
-------------------------------------
Has only non read entities : true
Entity entry : EntityEntry[com.bookstore.entity.Author#1](MANAGED)
Status:MANAGED
Loaded state: [23, Anthology, Mark Janel]

-------------------------------------
Phase:After Update Entity
Entity: Author{id=1, age=40, name=Mark Janel, genre=Anthology}
-------------------------------------
Has only non read entities : true
Entity entry : EntityEntry[com.bookstore.entity.Author#1](MANAGED)
Status:MANAGED
Loaded state: [23, Anthology, Mark Janel]
Hibernate: update author set age=?, genre=?, name=? where id=?

-------------------------------------
Phase:After Flush
// this flush was manually forced for the sake of testing
// by default, the flush will take place before transaction commits
Entity: Author{id=1, age=40, name=Mark Janel, genre=Anthology}
-------------------------------------
Has only non read entities : true
Entity entry : EntityEntry[com.bookstore.entity.Author#1](MANAGED)
Status:MANAGED

Loaded state: [40, Anthology, Mark Janel]

```

对该输出的解释很简单。水合/加载状态保存在持久上下文中，脏检查机制在刷新时使用它来更新作者(代表您触发一个`UPDATE`)。提取的实体状态为`MANAGED`。

此外，将`readOnly`设置为`true`并运行以下服务方法:

```
@Transactional(readOnly = true)
public void fetchAuthorReadOnlyMode() {
    ...
}

```

调用`fetchAuthorReadOnlyMode()`会触发一个单独的`SELECT`语句。输出如下所示:

```
-------------------------------------
Phase:After Fetch
Entity: Author{id=1, age=23, name=Mark Janel, genre=Anthology}
-------------------------------------
Has only non read entities : false
Entity entry : EntityEntry[com.bookstore.entity.Author#1](READ_ONLY)
Status:READ_ONLY
Loaded state: null

-------------------------------------
Phase:After Update Entity
Entity: Author{id=1, age=40, name=Mark Janel, genre=Anthology}
-------------------------------------
Has only non read entities : false
Entity entry : EntityEntry[com.bookstore.entity.Author#1](READ_ONLY)
Status:READ_ONLY
Loaded state: null

-------------------------------------
Phase:After Flush
// be default, for readOnly=true, there is no flush
// this flush was manually forced for the sake of testing
Entity: Author{id=1, age=40, name=Mark Janel, genre=Anthology}
-------------------------------------
Has only non read entities : false
Entity entry : EntityEntry[com.bookstore.entity.Author#1](READ_ONLY)
Status:READ_ONLY
Loaded state: null

```

这一次，取出`Author`实体后，水合/加载状态立即被丢弃(是`null`)。提取的实体处于`READ_ONLY`状态，自动刷新被禁用。即使通过显式调用`flush()`强制刷新，也不会使用脏检查机制，因为它被禁用(不会触发`UPDATE`)。

为只读数据设置`readOnly=true`是一个很好的性能优化，因为水合/负载状态被丢弃。这允许 Spring 优化底层的数据访问层操作。然而，如果您不打算修改只读数据，那么通过 DTO (Spring projection)获取这些数据仍然是一个更好的方法。

考虑以下弹簧投影:

```
public interface AuthorDto {

    public String getName();
    public int getAge();
}

```

和下面的查询:

```
@Repository
public interface AuthorRepository extends JpaRepository<Author, Long> {

    AuthorDto findTopByGenre(String genre);
}

```

调用`findTopByGenre()`并检查持久化上下文发现持久化上下文为空:

```
@Transactional
public void fetchAuthorDtoReadWriteMode() {
    AuthorDto authorDto = authorRepository.findTopByGenre("Anthology");

    org.hibernate.engine.spi.PersistenceContext
        persistenceContext = getPersistenceContext();

    System.out.println("No of managed entities : "
        + persistenceContext.getNumberOfManagedEntities());
}

@Transactional(readOnly = true)
public void fetchAuthorDtoReadOnlyMode() {
    AuthorDto authorDto = authorRepository.findTopByGenre("Anthology");

    org.hibernate.engine.spi.PersistenceContext
        persistenceContext = getPersistenceContext();

    System.out.println("No of managed entities : "
        + persistenceContext.getNumberOfManagedEntities());
}

```

两种服务方法返回相同的结果:

```
No of managed entities : 0

```

完整的应用程序可在 GitHub <sup>[2](#Fn2)</sup> 上获得。作为奖励，您可以在这个应用程序中获得一个事务 ID(在 MySQL 中只有读写事务获得一个 ID)。 <sup>[3](#Fn3)</sup>

## 项目 62:为什么 Spring 忽略@Transactional

考虑以下简单的服务:

```
@Service
public class BookstoreService {

    private static final Logger log =
        Logger.getLogger(BookstoreService.class.getName());

    private final AuthorRepository authorRepository;

    public BookstoreService(AuthorRepository authorRepository) {
        this.authorRepository = authorRepository;
    }

    public void mainAuthor() {
        Author author = new Author();
        persistAuthor(author);
        notifyAuthor(author);
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    private long persistAuthor(Author author) {
        authorRepository.save(author);
        return authorRepository.count();
    }

    private void notifyAuthor(Author author) {
        log.info(() -> "Saving author: " + author);
    }
}

```

调用`mainAuthor()`方法将创建一个新的作者，持久化作者(通过`persistAuthor()`)，并通知他们帐户已经创建(通过`notifyAuthor()`)。如您所见，`persistAuthor()`方法用`@Transactional`进行了注释，并且需要一个新的事务(`REQUIRES_NEW`)。因此，当调用`persistAuthor()`时，Spring Boot 应该启动一个新的事务，并在其中运行`save()`和`count()`查询方法。为了检查这个假设，让我们记录这些事务细节(添加`application.properties`):

```
logging.level.ROOT=INFO
logging.level.org.springframework.orm.jpa=DEBUG
logging.level.org.springframework.transaction=DEBUG

# for Hibernate only
logging.level.org.hibernate.engine.transaction.internal.TransactionImpl=DEBUG

```

运行代码会输出以下相关行:

```
Creating new transaction with name [org.springframework.data.jpa.repository.support.SimpleJpaRepository.save]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
Opened new EntityManager [SessionImpl(343534938<open>)] for JPA transaction

insert into author (age, genre, name) values (?, ?, ?)

Initiating transaction commit
Committing JPA transaction on EntityManager [SessionImpl(343534938<open>)]
Closing JPA EntityManager [SessionImpl(343534938<open>)] after transaction

Creating new transaction with name [org.springframework.data.jpa.repository.support.SimpleJpaRepository.count]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly
Opened new EntityManager [SessionImpl(940130302<open>)] for JPA transaction

select count(*) as col_0_0_ from author author0_

Initiating transaction commit
Committing JPA transaction on EntityManager [SessionImpl(940130302<open>)]
Closing JPA EntityManager [SessionImpl(940130302<open>)] after transaction

```

没有将`persistAuthor()`方法作为工作单元运行的事务。`save()`和`count()`方法在不同的事务中运行。为什么`@Transactional`被忽略了？

为什么`@Transactional`被忽略了？主要有两个原因:

*   `@Transactional`被添加到`private`、`protected`或`package-protected`方法中。

*   `@Transactional`被添加到一个方法中，该方法定义在与它被调用的位置相同的类中。

    因此，根据经验，`@Transactional`只对`public`方法有效，并且该方法应该被添加到一个不同于它被调用的类中。

根据这个技巧，`persistAuthor()`方法可以被移动到一个助手服务中，并被标记为`public`:

```
@Service
public class HelperService {

    private final AuthorRepository authorRepository;

    public HelperService(AuthorRepository authorRepository) {
        this.authorRepository = authorRepository;
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public long persistAuthor(Author author) {
        authorRepository.save(author);
        return authorRepository.count();
    }
}

```

从`BookstoreService`开始调用，如下所示:

```
@Service
public class BookstoreService {

    private static final Logger log =
        Logger.getLogger(BookstoreService.class.getName());

    private final HelperService helperService;

    public BookstoreService(HelperService helperService) {
        this.helperService = helperService;
    }

    public void mainAuthor() {
        Author author = new Author();
        helperService.persistAuthor(author);
        notifyAuthor(author);
    }

    private void notifyAuthor(Author author) {
        log.info(() -> "Saving author: " + author);
    }
}

```

这一次，运行代码会输出以下相关行:

```
Creating new transaction with name [com.bookstore.service.HelperService.persistAuthor]: PROPAGATION_REQUIRES_NEW,ISOLATION_DEFAULT
Opened new EntityManager [SessionImpl(1973372401<open>)] for JPA transaction

Participating in existing transaction
insert into author (age, genre, name) values (?, ?, ?)

Participating in existing transaction
select count(*) as col_0_0_ from author author0_

Initiating transaction commit
Committing JPA transaction on EntityManager [SessionImpl(1973372401<open>)]
Closing JPA EntityManager [SessionImpl(1973372401<open>)] after transaction

```

最后，事情按预期进行。`@Transactional`没有被忽略。

完整的应用程序可在 GitHub <sup>[4](#Fn4)</sup> 上获得。

## 第 63 项:如何设置和检查事务超时和到期回滚是否正常工作

Spring 支持几种显式设置事务超时的方法。最流行的方法依赖于`@Transactional`注释的超时元素，如下面简单的服务方法所示:

```
@Transactional(timeout = 10)
public void newAuthor() {

    Author author = new Author();
    author.setAge(23);
    author.setGenre("Anthology");
    author.setName("Mark Janel");
    authorRepository.saveAndFlush(author);

    System.out.println("The end!");
}

```

在此方法中，事务超时设置为 10 秒。显然，这个简单的插入不会花这么长时间来导致事务过期。那么，你怎么知道它有效呢？一个天真的尝试将偷偷放入一个值大于事务超时的`Thread.sleep()`:

```
@Transactional(timeout = 10)
public void newAuthor() {

    Author author = new Author();
    author.setAge(23);
    author.setGenre("Anthology");
    author.setName("Mark Janel");
    authorRepository.saveAndFlush(author);

    Thread.sleep(15000); // 15 seconds

    System.out.println("The end!");
}

```

由于当前线程将事务提交延迟了 15 秒，事务在 10 秒后超时，因此您可能会看到特定于超时的异常和事务回滚。但是，这不会像预期的那样起作用；相反，事务将在 15 秒后提交。

另一种尝试可能依赖于两个并发事务。事务 A 持有排他锁的时间可以长到足以导致事务 B 超时。这是可行的，但是有一个更简单的方法。

只需将一个 SQL 查询偷偷放入使用特定于 RDBMS 的 SQL `SLEEP`函数的事务服务方法中。大多数 RDBMS 都带有一种`SLEEP`函数的味道。比如 MySQL 用的是`SLEEP(n)`，PostgreSQL 用的是`PG_SLEEP(n)`。一个`SLEEP`函数将当前语句暂停一段指定的时间(`SLEEP()`和`PG_SLEEP()`的持续时间以秒为单位)，这将暂停事务。如果它暂停事务的时间超过了事务超时时间，则事务应该过期并回滚。

以下存储库定义了一个基于`SLEEP()`的查询，该查询将当前事务延迟 15 秒，而超时设置为 10 秒:

```
@Repository
public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Query(value = "SELECT SLEEP(15)", nativeQuery = true)
    public void sleepQuery();
}

```

因此，通过在事务中隐藏这个查询，事务应该被延迟指定的时间:

```
@Transactional(timeout = 10)
public void newAuthor() {

    Author author = new Author();
    author.setAge(23);
    author.setGenre("Anthology");
    author.setName("Mark Janel");
    authorRepository.saveAndFlush(author);

    authorRepository.sleepQuery();

    System.out.println("The end!");
}

```

调用`newAuthor()`将运行 10 秒钟，并抛出以下特定于超时的异常:

```
org.springframework.dao.QueryTimeoutException
Caused by: org.hibernate.QueryTimeoutException

```

### 设置事务和查询超时

依靠`@Transactional`的`timeout`元素是在方法级或类级设置事务超时的一种非常方便的方式。您也可以通过`application-properties`中的`spring.transaction.default-timeout`属性显式设置全局超时，如下所示(您可以通过`@Transactional`注释的`timeout`元素覆盖全局设置):

```
spring.transaction.default-timeout=10

```

您可以通过两个提示在查询级别设置超时:

*   通过一个`org.hibernate.timeout` Hibernate 特有的提示，相当于来自`org.hibernate.query.Query`的`setTimeout()`(超时以秒为单位指定):

*   通过`javax.persistence.query.timeout` JPA 提示，相当于来自`org.hibernate.query.Query`的`setTimeout()`(超时以毫秒指定):

```
@QueryHints({
    @QueryHint(name = "org.hibernate.timeout", value = "10")
})
@Query(value = "SELECT SLEEP(15)", nativeQuery = true)
public void sleepQuery();

```

```
@QueryHints({
    @QueryHint(name = "javax.persistence.query.timeout", value = "10000")
})
@Query(value = "SELECT SLEEP(15)", nativeQuery = true)
public void sleepQuery();

```

最后，如果您使用的是`TransactionTemplate`，那么可以通过`TransactionTemplate.setTimeout(int n)`设置超时，单位是秒。

### 检查事务是否已回滚

事务超时后，应该回滚。您可以在数据库级别、通过特定工具或在应用程序日志中检查这一点。首先，启用`application.properties`中的事务日志，如下所示:

```
logging.level.ROOT=INFO
logging.level.org.springframework.orm.jpa=DEBUG
logging.level.org.springframework.transaction=DEBUG

```

现在，过期的事务将记录如下所示的内容:

```
Creating new transaction with name ...
Opened new EntityManager [SessionImpl(1559444773<open>)] for JPA transaction
...
At this point the transaction times out !!!
...
Statement cancelled due to timeout or client request
Initiating transaction rollback
Rolling back JPA transaction on EntityManager [SessionImpl(1559444773<open>)]
Closing JPA EntityManager [SessionImpl(1559444773<open>)] after transaction

```

完整的应用程序可在 GitHub <sup>[5](#Fn5)</sup> 上获得。

## 第 64 项:为什么以及如何在存储库接口中使用@Transactional

在数据访问层处理事务的方式是决定超音速应用程序和勉强工作的应用程序的关键因素之一。

一般来说，数据库的速度由*事务吞吐量*给出，表示为每秒的事务数量。这意味着数据库是为了容纳大量短期事务而不是长期运行的事务而构建的。遵循本文中介绍的技术，通过努力获得短事务来增强数据访问层。

定义查询方法(只读和读写查询方法)的第一步是定义一个特定于域类的存储库接口。该接口必须扩展`Repository`并被类型化为域类和 ID 类型。通常，你会扩展`CrudRepository`、`JpaRepository`或`PagingAndSortingRepository`。此外，在这个定制界面中，您列出了查询方法。

例如，考虑`Author`实体及其简单的存储库接口:

```
@Repository
public interface AuthorRepository extends JpaRepository<Author, Long> {
}

```

有人建议开发人员只在服务(`@Service`)上使用`@Transactional`，避免将其添加到存储库接口中。但是，从性能的角度来看，这是生产中应该遵循的好建议吗？或者，您是否应该更加灵活，考虑在接口库中也使用`@Transactional`?有些声音甚至会鼓励你只在服务类级别添加`@Transactional`，或者更糟，在控制器类级别添加。很明显，这样的建议没有考虑长时间运行事务的缓解和/或针对小型应用程序。当然，遵循这个建议可能会加快开发曲线，并为大多数开发人员级别快速创建一个舒适的开发环境。

让我们看看这些事务是如何工作的，并根据放置`@Transactional`注释的位置来看看所涉及的性能损失。让我们从一个被公式化为问题的神话开始。

### 默认情况下，接口存储库中列出的查询方法在事务上下文中运行吗？

作为快速剩余，*非事务上下文*是指没有显式事务边界的上下文，**不是指没有物理数据库事务的上下文。所有数据库语句都是在物理数据库事务的上下文中触发的。通过省略明确的事务边界，您将应用程序暴露在一系列性能损失中，详见**第 61 条**。简而言之，建议对只读查询也使用显式事务。**

现在，让我们通过将 JPQL `SELECT`写入`AuthorRepository`来尝试回答本节标题中的问题:

```
@Query("SELECT a FROM Author a WHERE a.name = ?1")
public Author fetchByName(String name);

```

现在，服务方法可以调用这个查询方法。注意，服务方法没有声明显式的事务上下文。这样做是为了看看 Spring 是否会为您提供事务上下文(实际上，开发人员忘记添加`@Transactional(readOnly = true`):

```
public void callFetchByNameMethod() {

    Author author = authorRepository.fetchByName("Joana Nimar");
    System.out.println(author);
}

```

通过简单地检查应用程序日志中的事务流( **Item 85** ，我们注意到没有可用的事务上下文，因此 Spring 没有提供默认的事务上下文。此外，它通过如下消息标记这种行为:`Don't need to create transaction for [` `...fetchByName` `]: This method isn't transactional.`

但是，通过 Spring 数据查询构建器机制生成的查询怎么样呢？好吧，考虑一下`AuthorRepository`中的下一个查询方法:

```
public Author findByName(String name);

```

让我们从一个恰当的服务方法来称呼它:

```
public void callFindByNameMethod() {

    Author author = authorRepository.findByName("Joana Nimar");
    System.out.println(author);
}

```

同样，检查应用程序日志会发现没有默认的事务上下文。

最后，让我们添加一个查询方法来修改`AuthorRepository`的数据:

```
@Modifying
@Query("DELETE FROM Author a WHERE a.genre <> ?1")
public int deleteByNeGenre(String genre);

```

和服务方法:

```
public void callDeleteByNeGenreMethod() {

    int result = authorRepository.deleteByNeGenre("Anthology");
    System.out.println(result);
}

```

这一次，您不需要检查应用程序日志。service-method 将抛出一个有意义的异常，如下所示:

```
Caused by: org.springframework.dao.InvalidDataAccessApiUsageException: Executing an update/delete query;
nested exception is javax.persistence.TransactionRequiredException: Executing an update/delete query

Caused by: javax.persistence.TransactionRequiredException: Executing an update/delete query

```

总之，Spring 没有为用户定义的查询方法提供默认的事务上下文。另一方面，内置的查询方法(如`save()`、`findById()`、`delete()`等)。)没有这个问题。它们继承自扩展的内置存储库接口(例如`JpaRepository`)，并带有默认的事务上下文。

让我们快速调用内置`findById()`来看看这方面:

```
public void callFindByIdMethod() {

    Author author = authorRepository.findById(1L).orElseThrow();
    System.out.println(author);
}

```

应用程序日志显示，在这种情况下，Spring 会自动提供一个事务上下文:

```
Creating new transaction with name [...SimpleJpaRepository.findById]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly

Opened new EntityManager [SessionImpl(854671988<open>)] for JPA transaction

begin

Exposing JPA transaction as JDBC [...HibernateJpaDialect$HibernateConnectionHandle@280099a0]

select author0_.id as id1_0_0_, author0_.age as age2_0_0_, author0_.genre as genre3_0_0_, author0_.name as name4_0_0_ from author author0_ where author0_.id=?

Initiating transaction commit
Committing JPA transaction on EntityManager [SessionImpl(854671988<open>)]

committing

Closing JPA EntityManager [SessionImpl(854671988<open>)] after transaction

```

这个例子触发了一个`SELECT`语句。现在，让我们通过`setGenre()`更新选择的作者:

```
public void callFindByIdMethodAndUpdate() {

    Author author = authorRepository.findById(1L).orElseThrow();
    author.setGenre("History");

    authorRepository.save(author);
}

```

这一次，应用程序日志显示，这段代码需要两个单独的物理事务(两次数据库往返)来容纳通过`findById()`触发的`SELECT`，以及通过`save()`触发的`SELECT`和`UPDATE`。在这个方法执行之后，`findById()`使用的持久上下文被关闭。因此，`save()`方法需要另一个持久上下文。为了更新作者，Hibernate 需要合并分离的`author`。基本上，它通过一个 prior `SELECT`将作者加载到这个持久性上下文中。显然，如果并发事务对相关数据执行修改，这两个`SELECT`语句可能会返回不同的结果集，但这可以通过版本化乐观锁定来消除，以防止*丢失更新*。让我们检查一下应用程序日志:

```
Creating new transaction with name [...SimpleJpaRepository.findById]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly

Opened new EntityManager [SessionImpl(1403088342<open>)] for JPA transaction

begin

Exposing JPA transaction as JDBC [...HibernateJpaDialect$HibernateConnectionHandle@51fa09c7]

select author0_.id as id1_0_0_, author0_.age as age2_0_0_, author0_.genre as genre3_0_0_, author0_.name as name4_0_0_ from author author0_ where author0_.id=?

Initiating transaction commit
Committing JPA transaction on EntityManager [SessionImpl(1403088342<open>)]

committing

Closing JPA EntityManager [SessionImpl(1403088342<open>)] after transaction

Creating new transaction with name [...SimpleJpaRepository.save]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT

Opened new EntityManager [SessionImpl(94617220<open>)] for JPA transaction

begin

Exposing JPA transaction as JDBC [...HibernateJpaDialect$HibernateConnectionHandle@4850d66b]

select author0_.id as id1_0_0_, author0_.age as age2_0_0_, author0_.genre as genre3_0_0_, author0_.name as name4_0_0_ from author author0_ where author0_.id=?

Committing JPA transaction on EntityManager [SessionImpl(94617220<open>)]

committing

update author set age=?, genre=?, name=? where id=?

Closing JPA EntityManager [SessionImpl(94617220<open>)] after transaction

```

换句话说，Spring 已经自动为`findById()`和`save()`方法提供了事务上下文，但是它没有为`callFindByIdMethodAndUpdate()`服务方法提供事务上下文。在缺点中，这个服务方法没有利用 ACID 属性作为工作单元，需要两个物理事务和数据库往返，并且触发三个 SQL 语句而不是两个。

大多数时候，您会实现一个包含查询方法调用的服务方法，并假设触发的 SQL 语句将作为具有 ACID 属性的事务中的一个工作单元运行。显然，这个假设并不能验证前面的情况。

在同一个服务方法中调用`fetchByName()`和`deleteByNeGenre()`怎么样，如下所示:

```
public void callFetchByNameAndDeleteByNeGenreMethods() {

    Author author = authorRepository.fetchByName("Joana Nimar");
    authorRepository.deleteByNeGenre(author.getGenre());
}

```

由于`AuthorRepository`没有为查询方法提供事务上下文，`deleteByNeGenre()`将导致一个`javax.persistence.TransactionRequiredException`异常。因此，这一次，代码不会在非事务上下文中静默运行。

### 好，那么我要做的就是在服务方法级别添加@Transactional，对吗？

为了提供明确的事务上下文，您可以在服务方法级别添加`@Transactional`。这样，在这个事务上下文的边界中运行的 SQL 语句将利用 ACID 属性作为工作单元。比如，我们把`@Transactional`加到`callFetchByNameMethod()`上:

```
@Transactional(readOnly = true)
public void callFetchByNameMethod() {

    Author author = authorRepository.fetchByName("Joana Nimar");
    System.out.println(author);
}

```

这一次，应用程序日志确认了事务上下文的存在:

```
Creating new transaction with name [...BookstoreService.callFetchByNameMethod]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly

Opened new EntityManager [SessionImpl(2012237082<open>)] for JPA transaction

begin

Exposing JPA transaction as JDBC [...HibernateJpaDialect$HibernateConnectionHandle@7d3815f7]

select author0_.id as id1_0_, author0_.age as age2_0_, author0_.genre as genre3_0_, author0_.name as name4_0_ from author author0_ where author0_.name=?
Author{id=4, age=34, name=Joana Nimar, genre=History}

Initiating transaction commit

Committing JPA transaction on EntityManager [SessionImpl(2012237082<open>)]

committing

Closing JPA EntityManager [SessionImpl(2012237082<open>)] after transaction

```

酷！现在，您可以通过在事务上下文的保护伞下连接多个逻辑相关的 SQL 语句来定义一个工作单元，并利用 ACID 属性。例如，你可以重写`callFindByIdMethodAndUpdate()`，如下所示:

```
@Transactional
public void callFindByIdMethodAndUpdate() {

    Author author = authorRepository.findById(1L).orElseThrow();
    author.setGenre("History");
}

```

这次是单个事务(单个数据库往返)，两个 SQL 语句(一个`SELECT`和一个`UPDATE`，不需要显式调用`save()`(见**第 107 项**)。

`callFindByIdMethodAndUpdate()`也利用了酸的特性。以下是日志:

```
Creating new transaction with name [...BookstoreService.callFindByIdMethodAndUpdate]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT

Opened new EntityManager [SessionImpl(1115708094<open>)] for JPA transaction

begin

Exposing JPA transaction as JDBC [...HibernateJpaDialect$HibernateConnectionHandle@78ea700f]

Found thread-bound EntityManager [SessionImpl(1115708094<open>)] for JPA transaction

Participating in existing transaction

select author0_.id as id1_0_0_, author0_.age as age2_0_0_, author0_.genre as genre3_0_0_, author0_.name as name4_0_0_ from author author0_ where author0_.id=?

Initiating transaction commit

Committing JPA transaction on EntityManager [SessionImpl(1115708094<open>)]

committing

update author set age=?, genre=?, name=? where id=?

Closing JPA EntityManager [SessionImpl(1115708094<open>)] after transaction

```

最后，让我们在显式事务上下文中调用`callFetchByNameAndDeleteByNeGenreMethods()`方法:

```
@Transactional
public void callFetchByNameAndDeleteByNeGenreMethods() {

    Author author = authorRepository.fetchByName("Joana Nimar");
    authorRepository.deleteByNeGenre(author.getGenre());

    if (new Random().nextBoolean()) {
        throw new RuntimeException("Some DAO exception occurred!");
    }
}

```

现在，请注意，在触发了`SELECT`(通过`fetchByName()`)和`DELETE`(通过`deleteByNeGenre()`)之后，我们模拟了一个随机异常，该异常应该会导致事务回滚。这揭示了事务的原子性。因此，如果发生异常，应用程序日志将显示以下内容:

```
Creating new transaction with name [...BookstoreService.callFetchByNameAndDeleteByNeGenreMethods]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT

Opened new EntityManager [SessionImpl(654609843<open>)] for JPA transaction

begin

Exposing JPA transaction as JDBC [...HibernateJpaDialect$HibernateConnectionHandle@7f94541b]

select author0_.id as id1_0_, author0_.age as age2_0_, author0_.genre as genre3_0_, author0_.name as name4_0_ from author author0_ where author0_.name=?

delete from author where genre<>?

Initiating transaction rollback

Rolling back JPA transaction on EntityManager [SessionImpl(654609843<open>)]

rolling back

Closing JPA EntityManager [SessionImpl(654609843<open>)] after transaction

Caused by: java.lang.RuntimeException: Some DAO exception occurred!

```

好了，看起来在服务方法级别添加`@Transactional`可以解决所有问题。该解决方案具有可用于服务方法的事务上下文，并且利用了 ACID 属性。

### 但是，总的来说，这种方法就足够了吗？

为了回答这个问题，让我们来解决下面的服务方法:

```
@Transactional(readOnly = true)
public void longRunningServiceMethod() {

    System.out.println("Service-method start ...");
    System.out.println("Sleeping before triggering SQL
                      to simulate a long running code ...");
    Thread.sleep(40000);

    Author author = authorRepository.fetchByName("Joana Nimar");
    System.out.println(author);

    System.out.println("Service-method done ...");
}

```

注意，只是为了测试，我们使用了 40 秒的长睡眠。当我们讨论长时间运行的事务和短时间运行的事务时，我们应该用毫秒来讨论它们。例如，图 [6-3](#Fig3) 显示了五个长时间运行的事务。

![../images/487471_1_En_6_Chapter/487471_1_En_6_Fig3_HTML.jpg](../images/487471_1_En_6_Chapter/487471_1_En_6_Fig3_HTML.jpg)

图 6-3

web 事务的时间示例

在服务方法的末尾，您调用`fetchByName()`查询方法。因此，服务方法用`@Transactional(readOnly = true)`进行了注释，以明确定义事务上下文的边界。查看应用程序日志:

```
Creating new transaction with name [...BookstoreService.longRunningServiceMethod]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly

Opened new EntityManager [SessionImpl(1884806106<open>)] for JPA transaction

begin

Exposing JPA transaction as JDBC [...HibernateJpaDialect$HibernateConnectionHandle@63ad5fe7]

Service-method start ...
Sleeping before triggering SQL to simulate a long running code ...

HikariPool-1 - Pool stats (total=10, active=1, idle=9, waiting=0)

select author0_.id as id1_0_, author0_.age as age2_0_, author0_.genre as genre3_0_, author0_.name as name4_0_ from author author0_ where author0_.name=?
Author{id=4, age=34, name=Joana Nimar, genre=History}

Service-method done ...

Initiating transaction commit

Committing JPA transaction on EntityManager [SessionImpl(1884806106<open>)]

committing

Closing JPA EntityManager [SessionImpl(1884806106<open>)] after transaction

HikariPool-1 - Pool stats (total=10, active=0, idle=10, waiting=0)

```

那么，这里发生了什么？在开始运行`longRunningServiceMethod()`方法代码之前，Spring 立即启动事务并获取数据库连接。数据库连接会立即打开，并可以使用了。但是我们不会马上使用它，我们只是让它一直开着！我们在调用`fetchByName()`之前运行一些其他任务(通过`Thread.sleep()`模拟)，这是在第一次与数据库连接交互之前。同时，数据库连接保持打开并链接到事务(查看 HikariCP 日志，`active=1`)。最后，事务被提交，数据库连接被释放回连接池。这个场景代表一个长时间运行的事务，可能会影响可伸缩性，并且不利于 MVCC(多版本并发控制)。这个问题的主要原因是因为我们已经用`@Transactional`注释了服务方法。但是，如果我们删除这个`@Transactional`，那么`fetchByName()`将在事务上下文之外运行！嗯！

### 我知道！让我们在存储库接口中移动@Transactional！

解决方案包括将`@Transactional`移动到存储库接口，如下所示:

```
@Repository
@Transactional(readOnly = true)
public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Query("SELECT a FROM Author a WHERE a.name = ?1")
    public Author fetchByName(String name);
}

```

或者，像这样(当然，这里显示的缺点是，如果我们有更多的只读查询方法，那么我们需要重复`@Transactional(readOnly = true)`注释):

```
@Repository
public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Transactional(readOnly = true)
    @Query("SELECT a FROM Author a WHERE a.name = ?1")
    public Author fetchByName(String name);
}

```

服务方法不包含`@Transactional`:

```
public void longRunningServiceMethod() {

    // remains unchanged
}

```

这一次，应用程序日志揭示了预期的结果:

```
Service-method start ...
Sleeping before triggering SQL to simulate a long running code ...

HikariPool-1 - Pool stats (total=10, active=0, idle=10, waiting=0)

Creating new transaction with name [...SimpleJpaRepository.fetchByName]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly

Opened new EntityManager [SessionImpl(508317658<open>)] for JPA transaction

begin

Exposing JPA transaction as JDBC [...HibernateJpaDialect$HibernateConnectionHandle@3ba1f56e]

select author0_.id as id1_0_, author0_.age as age2_0_, author0_.genre as genre3_0_, author0_.name as name4_0_ from author author0_ where author0_.name=?

Initiating transaction commit

Committing JPA transaction on EntityManager [SessionImpl(508317658<open>)]

committing

Closing JPA EntityManager [SessionImpl(508317658<open>)] after transaction

Author{id=4, age=34, name=Joana Nimar, genre=History}

Service-method done ...

```

因此，这一次，事务只包装通过 query-method 触发的 SQL `SELECT`语句。由于这导致了一个短期交易，很明显这是应该走的路。

### 但是如果我想在服务方法中调用更多的查询方法呢？我掉酸了吗？

前面的场景按预期运行，因为我们在`longRunningServiceMethod()`服务方法中调用了单个查询方法。然而，您很可能需要调用几个查询方法，这些方法产生一组定义逻辑事务的 SQL 语句。例如，在通过名字(`fetchByName()`)获取一个作者之后，您可能想要删除所有与这个作者有不同流派的作者(`deleteByNeGenre()`)。在没有用`@Transactional`注释的服务方法中调用这两个查询方法将会丢失这个工作单元的 ACID 属性。因此，您也需要在服务方法中添加`@Transactional`。

首先，让我们看看塑造存储库接口的最佳方式，`AuthorRepository`。你应该听从**奥利弗·德罗特博姆**的建议:

*   *因此，我们推荐使用* `@Transactional(readOnly = true)` *作为查询方法，您可以轻松地将注释添加到您的存储库接口。确保您将普通的* `@Transactional` *添加到您可能已经在该接口中声明或重新修饰的操作方法中。*

此外，Oliver 被问到:“所以简而言之，我应该在添加/编辑/删除查询中使用`@Transactional`,在所有 DAO 方法的`SELECT`查询中使用`@Transaction(readOnly = true)`?”**奥利弗**回答如下:

*   *正是。最简单的方法是在界面上使用* `@Transactional(readOnly = true)` *(因为它通常包含大部分查找器方法)，并用普通的* `@Transactional`覆盖每个修改查询方法的设置。在 `SimpleJpaRepository`实际上就是这么做的。

所以，我们应该有:

```
@Repository
@Transactional(readOnly = true)
public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Query("SELECT a FROM Author a WHERE a.name = ?1")
    public Author fetchByName(String name);

    @Transactional
    @Modifying
    @Query("DELETE FROM Author a WHERE a.genre <> ?1")
    public int deleteByNeGenre(String genre);
}

```

因此，我们通过用`@Transactional(readOnly = true)`注释存储库接口来确保所有查询方法都在只读事务上下文中运行。此外，对于可以修改数据的查询方法，我们通过添加不带`readOnly`标志的`@Transactional`来切换到允许数据修改的事务上下文。主要是，我们在这里所做的正是 Spring Data 为其内置查询方法所做的。

此外，服务方法用`@Transactional`标注，因为我们将触发一个`SELECT`和一个`UPDATE`:

```
@Transactional
public void longRunningServiceMethod() {

    System.out.println("Service-method start ...");
    System.out.println("Sleeping before triggering SQL
                      to simulate a long running code ...");
    Thread.sleep(40000);

    Author author = authorRepository.fetchByName("Joana Nimar");
    authorRepository.deleteByNeGenre(author.getGenre());

    System.out.println("Service-method done ...");
}

```

现在让我们来看看应用程序日志:

```
Creating new transaction with name [...BookstoreService.longRunningServiceMethod]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT

Opened new EntityManager [SessionImpl(138303640<open>)] for JPA transaction

begin

Exposing JPA transaction as JDBC [...HibernateJpaDialect$HibernateConnectionHandle@7c4a03a]

Service-method start ...
Sleeping before triggering SQL to simulate a long running code ...

HikariPool-1 - Pool stats (total=10, active=1, idle=9, waiting=0)

Found thread-bound EntityManager [SessionImpl(138303640<open>)] for JPA transaction
Participating in existing transaction

select author0_.id as id1_0_, author0_.age as age2_0_, author0_.genre as genre3_0_, author0_.name as name4_0_ from author author0_ where author0_.name=?

Found thread-bound EntityManager [SessionImpl(138303640<open>)] for JPA transaction
Participating in existing transaction

delete from author where genre<>?

Service-method done ...

Initiating transaction commit

Committing JPA transaction on EntityManager [SessionImpl(138303640<open>)]

committing

Closing JPA EntityManager [SessionImpl(138303640<open>)] after transaction

HikariPool-1 - Pool stats (total=10, active=0, idle=10, waiting=0)

```

检查以下突出显示的输出:

```
Found thread-bound EntityManager [SessionImpl(138303640<open>)] for JPA transaction
Participating in existing transaction

```

这一次，每个被调用的查询方法(`fetchByName()`和`deleteByNeGenre()`)都参与到您调用`longRunningServiceMethod()`服务方法时打开的现有事务中。所以，不要混淆，不要认为来自存储库接口的`@Transactional`注释会启动新的事务或者消耗新的数据库连接。Spring 将自动*邀请*被调用的查询方法参与现有的事务。一切都像魔咒一样管用！Spring 依赖于其事务传播机制，详见**附录 G** 。更准确地说，在默认模式下，Spring 应用特定于默认事务传播机制`Propagation.REQUIRED`的事务传播规则。当然，如果您显式地设置了另一个事务传播机制(参见**附录 G** ，那么您必须在相应的上下文中评估您的事务流。

好的，但是现在我们回到了一个长时间运行的事务！在这种情况下，我们应该重构代码并重新设计实现，以获得更短的事务。或者，如果我们使用 Hibernate 5.2.10+，我们可以延迟数据库连接获取。基于**第 60 项**，我们可以通过以下两个设置来延迟连接获取(建议在*资源-本地*(针对单个数据源)中始终使用这些设置):

```
spring.datasource.hikari.auto-commit=false
spring.jpa.properties.hibernate.connection.provider_disables_autocommit=true

```

现在，数据库连接获取被延迟，直到第一条 SQL 语句被执行:

```
Creating new transaction with name [...BookstoreService.longRunningServiceMethod]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT

Opened new EntityManager [SessionImpl(138303640<open>)] for JPA transaction

begin

Exposing JPA transaction as JDBC [...HibernateJpaDialect$HibernateConnectionHandle@7c4a03a]

Service-method start ...
Sleeping before triggering SQL to simulate a long running code ...

HikariPool-1 - Pool stats (total=10, active=0, idle=10, waiting=0)

Found thread-bound EntityManager [SessionImpl(138303640<open>)] for JPA transaction
Participating in existing transaction

select author0_.id as id1_0_, author0_.age as age2_0_, author0_.genre as genre3_0_, author0_.name as name4_0_ from author author0_ where author0_.name=?

Found thread-bound EntityManager [SessionImpl(138303640<open>)] for JPA transaction
Participating in existing transaction

delete from author where genre<>?

Service-method done ...

Initiating transaction commit

Committing JPA transaction on EntityManager [SessionImpl(138303640<open>)]

committing

Closing JPA EntityManager [SessionImpl(138303640<open>)] after transaction

HikariPool-1 - Pool stats (total=10, active=0, idle=10, waiting=0)

```

请注意，在调用第一个 query-method 之前，HikariCP 报告 0 个活动连接。因此，我们耗时的任务(通过`Thread.sleep()`模拟)在没有保持数据库连接打开的情况下执行。然而，在获得连接之后，它将保持打开状态，直到服务方法执行结束(直到事务完成)。这是额外关注服务方法设计以避免任何长时间运行任务的一个强有力的理由。

作为一个经验法则，努力避免那些与繁重的业务逻辑交错的事务，这些业务逻辑不会通过查询方法调用与数据库进行交互。这可能导致长时间运行的事务和复杂的服务方法变得耗时，并且难以理解、调试、重构和审查。几乎总是有更好的解决方案，只是要花时间去发现它们。

涵盖长期运行方法案例的完整代码可以在 GitHub <sup>[6](#Fn6)</sup> 上找到。

### 因此，如果我延迟连接获取，那么我就可以在存储库接口中避免@Transactional？

如果可以，升级到 Hibernate 5.2.10+,执行**第 60 项**的设置，延迟连接获取。然后，在大多数情况下，您只能在服务级别使用`@Transactional`,而不能在存储库接口中使用。但是这意味着您仍然容易忘记将`@Transactional(readOnly=true)`添加到包含只读数据库操作的服务方法中( **Item 61** )。现在，让我们看看两种情况，如果您也将`@Transactional`添加到存储库接口，它们会生成更短的事务。

#### 案例 1

考虑下面的存储库和`BookstoreService`中的两个服务方法:

```
@Repository
public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Query("SELECT a FROM Author a WHERE a.name = ?1")
    public Author fetchByName(String name);
}

@Service
public class BookstoreService {

    public void displayAuthor() {
        Author author = fetchAuthor();
        System.out.println(author);
    }

    @Transactional(readOnly = true)
    public Author fetchAuthor() {
        return authorRepository.fetchByName("Joana Nimar");
    }
}

```

该代码属于**第 62 项**的范围。换句话说，`@Transactional`被添加到一个方法中，该方法定义在调用它的同一个类中，Spring 将忽略它。但是，如果我们遵循最佳实践并在存储库接口中声明`@Transactional(readOnly=true)`,那么一切都会完美地工作:

```
@Repository
@Transactional(readOnly = true)
public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Query("SELECT a FROM Author a WHERE a.name = ?1")
    public Author fetchByName(String name);
}

@Service
public class BookstoreService {

    public void displayAuthor() {
        Author author = fetchAuthor();
        System.out.println(author);
    }

    public Author fetchAuthor() {
        return authorRepository.fetchByName("Joana Nimar");
    }
}

```

或者，您可以使用两种服务，如第 62 项中所示。

#### 案例 2

考虑`BookstoreService`中的以下存储库和服务方法:

```
@Repository
public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Query("SELECT a FROM Author a WHERE a.name = ?1")
    public Author fetchByName(String name);
}

@Service
public class BookstoreService {

    @Transactional(readOnly = true)
    public Royalty computeRoyalties() {

        Author author = authorRepository.fetchByName("Joana Nimar");

        // computing royalties is a slow task
        // that requires interaction with other services
        // (e.g., revenue and financial services)

        return royalties;
    }
}

```

在这种情况下，延迟连接获取不会带来显著的好处。我们马上给`fetchByName()`打电话；因此，数据库连接是立即获得的。在执行了`fetchByName()`查询方法之后，数据库连接保持打开，直到版税计算完毕。

但是，如果我们准备了如下的`AuthorRepository`:

```
@Repository
@Transactional(readOnly = true)
public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Query("SELECT a FROM Author a WHERE a.name = ?1")
    public Author fetchByName(String name);
}

```

那么就不需要用`@Transactional(readOnly = true)`来注释服务方法，事务将只封装`fetchByName()`的执行，而版税在事务之外计算:

```
@Service
public class BookstoreService {

    public Royalty computeRoyalties() {

        Author author = authorRepository.fetchByName("Joana Nimar");

        // computing royalties is a slow task
        // that requires interaction with other services
        // (e.g., revenue and financial services)

        return royalties;
    }
}

```

或者，您可以将`computeRoyalties()`分成两个方法，如下所示:

```
@Repository
public interface AuthorRepository extends JpaRepository<Author, Long> {

    @Query("SELECT a FROM Author a WHERE a.name = ?1")
    public Author fetchByName(String name);
}

@Service
public class BookstoreService {

    public Royalty computeRoyalties() {

        Author author = fetchAuthorByName("Joana Nimar");

        // computing royalties is a slow task
        // that requires interaction with other services
        // (e.g., revenue and financial services)

        return royalties;
    }

    @Transactional(readOnly = true)
    public Author fetchAuthorByName(String name) {

        return authorRepository.fetchByName(name);
    }
}

```

但是现在我们回到案例 1。

### 三个简单而常见的场景

让我们来解决三个简单而常见的容易把事情搞砸的场景。

#### 回滚不与数据库交互的代码引发的异常服务方法

考虑以下服务方法:

```
public void foo() {

    // call a query-method that triggers DML statements (e.g., save())

    // follows tasks that don't interact with the database but
    // are prone to throw RuntimeException
}

```

这个服务方法应该用`@Transactional`注释吗？如果不与数据库交互的突出显示的代码通过`RuntimeException`失败，那么当前事务应该被回滚。第一个想法是将这个服务方法标注为`@Transactional`。这种情况对于使用`@Transactional(rollbackFor = Exception.class)`的*检查的*异常也很常见。

但是，在决定将`@Transactional`添加到服务方法之前，最好三思而行。也许有另一种解决方法。例如，也许您可以在不影响行为的情况下更改任务的顺序:

```
public void foo() {

    // follows tasks that don't interact with the database but
    // are prone to throw RuntimeException

    // call a query-method that triggers DML statements (e.g., save())
}

```

现在不需要用`@Transactional`来注释这个服务方法。如果不与数据库交互的任务抛出一个`RuntimeException`，那么`save()`根本不会被调用，这样就省了一次数据库往返。

此外，如果这些任务很耗时，那么它们不会影响为`save()`方法打开的事务的持续时间。在最坏的情况下，我们不能改变任务的顺序，而且这些任务非常耗时。更糟糕的是，这可能是应用程序中被频繁调用的方法。在这些情况下，service-method 将导致长时间运行的事务。在这种情况下，您必须重新设计您的解决方案，以避免用`@Transactional`注释服务方法(例如，显式捕捉异常并通过显式 DML 语句提供手动回滚，或者将服务方法重构为几个服务方法，以减轻长时间运行的事务)。

#### 级联和@事务

考虑双向懒惰关联中涉及的`Foo`和`Buzz`。持久化一个`Foo`会将持久化操作级联到关联的`Buzz`。以及以下服务方法:

```
public void fooAndBuzz() {

    Foo foo = new Foo();

    Buzz buzz1 = new Buzz();
    Buzz buzz2 = new Buzz();

    foo.addBuzz(buzz1);
    foo.addBuzz(buzz2);

    fooRepository.save(foo);
}

```

我们只调用了一次`save()`，但是它将触发三个`INSERT`语句。那么，我们应该用`@Transactional`来注释这个方法以提供 ACID 属性吗？答案是否定的！我们不应该用`@Transactional`来注释这个服务方法，因为触发持久化与`Foo`关联的`Buzz`实例的`INSERT`语句是通过`CascadeType.ALL` / `PERSIST`级联的结果。所有三个`INSERT`语句都在同一个事务的上下文中执行。如果这些`INSERT`语句中的任何一个失败，事务将自动回滚。

#### 选择➤修改➤保存和交叉存取的长期运行任务

还记得之前的`callFindByIdMethodAndUpdate()`吗？

```
public void callFindByIdMethodAndUpdate() {

    Author author = authorRepository.findById(1L).orElseThrow();
    author.setGenre("History");

    authorRepository.save(author);
}

```

让我们将这个方法抽象如下:

```
public void callSelectModifyAndSave () {

    Foo foo = fooRepository.findBy...(...);
    foo.setFooProperty(...);

    fooRepository.save(foo);
}

```

前面，我们用`@Transactional`注释了这种方法，以划分事务边界。好处之一，我们说会有两个 SQL 语句(`SELECT`和`UPDATE`)而不是三个(`SELECT`、`SELECT`和`UPDATE`)，我们省去了一次数据库往返，不需要显式调用`save()`:

```
@Transactional
public void callSelectModifyAndSave () {

    Foo foo = fooRepository.findBy...(...);
    foo.setFooProperty(...);
}

```

然而，这种方法在下面的情况下有用吗？

```
@Transactional
public void callSelectModifyAndSave() {

    Foo foo = fooRepository.findBy...(...);

    // long-running task using foo data

    foo.setFooProperty(...);
}

```

如果我们在`SELECT`和`UPDATE`之间偷偷放一个长时间运行的任务，那么我们会导致一个长时间运行的事务。例如，我们可能需要选择一本书，使用选择的数据生成该书的 PDF 版本(这是一个长期运行的任务)，并更新该书的可用格式。如果我们选择像上面那样做(这是一种非常常见的情况)，那么我们就有了一个长时间运行的事务，因为该事务也将包含长时间运行的任务。

在这种情况下，最好去掉`@Transactional`，允许两个短事务被一个长时间运行的任务和一个额外的`SELECT`分开:

```
public void callSelectModifyAndSave() {

    Foo foo = fooRepository.findBy...(...);

    // long-running task using foo data

    foo.setFooProperty(...);
    fooRepository.save(foo);
}

```

通常，当像这里这样涉及一个长时间运行的任务时，我们必须考虑所选数据可能会被`SELECT`和`UPDATE`之间的另一个事务( *lost update* )修改。这可能发生在两种情况下——一个长时间运行的事务或两个被长时间运行的任务分隔开的短事务。在这两种情况下，我们都可以依靠版本化的乐观锁定和重试机制( **Item 131** )。由于这个方法没有用`@Transactional`标注，我们可以应用`@Retry`(注意`@Retry`不应该应用于用`@Transactional`标注的方法——细节在**项 131** 中解释):

```
@Retry(times = 10, on = OptimisticLockingFailureException.class)
public void callSelectModifyAndSave() {

    Foo foo = fooRepository.findBy...(...);

    // long-running task using foo data

    foo.setFooProperty(...);
    fooRepository.save(foo);
}

```

搞定了。这比单个长时间运行的事务好得多。

为了获得最佳的基于 ACID 的事务上下文来减轻主要的性能损失，特别是长时间运行的事务，建议遵循以下准则:

**准备您的存储库接口:**

*   用`@Transactional(readOnly=true)`注释存储库接口。

*   对于修改数据/生成 DML 的查询方法(如`INSERT`、`UPDATE`和`DELETE`，用`@Transactional`覆盖`@Transactional(readOnly=true)`。

    **延迟数据库连接获取:**

*   对于 Hibernate 5.2.10+，将数据库连接获取延迟到真正需要的时候(参见**第 60 项**)。

    **评估每个服务方法:**

*   评估每个服务方法，以决定是否应该用`@Transactional`进行注释。

*   如果你决定用`@Transactional`注释一个服务方法，那么添加适当的`@Transactional`。如果只调用只读的查询方法，应该添加`@Transactional(readOnly=true)`，如果调用至少一个可以修改数据的查询方法，应该添加`@Transactional`。

    **测量和监控交易持续时间:**

*   务必在当前事务传播机制(**附录 G** )的上下文中评估事务持续时间和行为，并争取短事务和短/快事务。

*   一旦获得数据库连接，它将保持打开状态，直到事务完成。因此，设计您的解决方案以避免长时间运行的事务。

*   避免在控制器类级别或服务类级别添加`@Transactional`,因为这可能导致长时间运行甚至不需要的事务(这样的类容易打开事务上下文，并为不需要与数据库交互的方法获取数据库连接)。例如，开发人员可能会添加包含不与数据库交互的业务逻辑的`public`方法；在这种情况下，如果您延迟数据库连接获取，那么 Spring Boot 仍然会准备事务上下文，但永远不会为它获取数据库连接。另一方面，如果您不依赖于延迟数据库连接获取，那么 Spring Boot 将准备事务上下文，并将为其获取数据库连接。

仅此而已！

<aside aria-label="Footnotes" class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

[hibernate pringb bootdelayconnect on](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootDelayConnection)

  [2](#Fn2_source)

[hibernate pringb 欧统局会演](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootTransactionalReadOnlyMeaning)

  [3](#Fn3_source)

[hibernate pringb 欧统局](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootTransactionId)

  [4](#Fn4_source)

[hibernate pringb ootponimo nalizado](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootWhyTransactionalIsIgnored)

  [5](#Fn5_source)

[hibernate pringb ottransaction ti meout](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootTransactionTimeout)

  [6](#Fn6_source)

[仓库中的休眠跳 ootTransactional】](https://github.com/AnghelLeonard/Hibernate-SpringBoot/tree/master/HibernateSpringBootTransactionalInRepository)

 </aside>