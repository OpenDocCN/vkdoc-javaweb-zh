## C H A P T E R 2

## Oracle 数据库安全性

正如您可能想象的那样，如果我试图涵盖 Oracle 安全性的整个范围，本章的主题可以写满一整本书，甚至好几本书。相反，我将介绍一些要点，以及程序员可能会涉及到的 Oracle 安全性的一些特定方面。Oracle 基本安全性的一个例子是使用角色并向这些角色授予权限。程序员扩展 Oracle 安全性的一个例子是安全应用程序角色。

本章的基本目标如下:

*   创建两个用户:一个安全管理员用户和一个应用程序安全用户。这些用户将被授予实现应用程序安全性的特权和委派责任。
*   使用 Oracle 角色来控制访问和增强应用程序安全性，并了解由 Oracle 存储过程标识的安全应用程序角色。
*   区分 EMPLOYEES 表中的敏感数据和非敏感数据。

准备钻研数据库管理和设计的许多方面。本章将帮助您了解 Oracle 安全性，并且我们将在本书的其余部分中以这里介绍的概念为基础。有些方面，比如代理连接，只有在上下文中呈现时才会真正清楚。我想确定你真的理解了书中的内容，而不仅仅是接触了一下。

### 寻找测试 Oracle 数据库

我们将立即投入工作。我希望您已经可以访问数据库中的 SYS 帐户。如果没有，希望你是服务器的数据库管理员(DBA)的好朋友，希望你是公认的数据库安全管理员。如果是这样的话，您可以让您的 DBA 朋友来完成必须由 SYS 或 DBA 完成的一小部分工作。

如果您想学习本章中的概念，但不想使用托管服务器，并且您的个人工作站有足够的计算机能力，那么您可以下载并安装 Oracle Database 11g Enterprise Edition server，并在本地执行我在本章中描述的任务。在任何情况下，我都强烈推荐这种方法，因为在将它们投入生产之前，您应该明确地演示和测试我在本章中描述的安全措施，以使您安心。

### 从现有的 Oracle 数据库工作

如果您使用现有的数据库安装，可能会有一些问题需要解决。如果您有一个默认的 Oracle 数据库 11.2 安装，那么您只需考虑安装后采取的步骤，看看您是否撤消了任何内置/默认的安全性。至少，您需要确保密码的复杂性和保密性。但是，如果您的数据库已经存在了一段时间，并且已经从以前的 Oracle 版本升级，那么您可能需要花费一些时间和精力来纠正安全问题。

我建议您采用 Oracle Technology Network 的 Arup Nanda 提供的资源，名为 Project Lockdown。项目锁定是一系列清单、任务和项目，将有效地启用和实施 Oracle 数据库安全性。您可以在 Oracle 技术网络网站上找到该资源，网址为[www . Oracle . com/tech Network/articles/project-lockdown-133916 . pdf](http://www.oracle.com/technetwork/articles/project-lockdown-133916.pdf)。

项目锁定可能需要几个月的时间来完成，这取决于您当前的安全立场有多松懈。然而，最关键的前两个阶段可能会在一周内完成。

### Oracle 用户和模式

一旦 Oracle Database 11g 启动并运行，您将需要考虑用户和用户安全性，甚至在考虑数据之前，因为数据是由用户创建的。即使不属于任何特定人员的应用程序数据库也与 Oracle 数据库中的用户相关联。本地数据库上的每个用户都有一个关联的模式，它基本上是 Oracle 结构(或对象)的一个有组织的存储分配，比如属于用户的表和索引。我们将讨论的用户列表见[表 2-1](#tab_2_1) 。

![image](images/t0201.jpg)

![image](images/t0201a.jpg)

### SQL*Plus、SQL Developer、JDeveloper 或 TOAD

我假设，如果您正在阅读本文，您已经作为一名 Oracle 开发人员做了一些工作。我将进一步假设您有一些用于在 Oracle 数据库上提交命令的工具，例如 SQL*Plus 中的提示符或 TOAD、SQL Developer 或 JDeveloper 中的编辑器。SQL*Plus 是 Oracle 提供的，所以如果您没有其他工具，您仍然可以使用 SQL*Plus。这就是完成本书概述的任务所需的全部内容。

![images](images/square.jpg) **注意**这些工具中有些对多行命令更敏感。它们可能需要在多行命令后面的一行上有一个斜杠字符(/)。

本书源代码中包含的许多 SQL 脚本文件都需要编辑特定的值，以适合您的计算机、公司或家庭环境。这些值列在 SQL 文件的顶部。经过适当的编辑后，大多数 SQL 文件可以作为脚本执行；请确保您是以适当的 Oracle 用户身份连接的。

### 接下来几节的组织

我想让你尽可能容易地理解这些材料。为此，我将三个用户的任务和关注点分成几个部分:`SYS`(数据库管理员)，我们将在这里创建的安全管理员，以及`HR`(人力资源)模式所有者。

在大多数情况下，数据库管理员可以完成所有这些任务，但是我的目的是通过授权来展示安全性。我们将让这些用户中的每一个完成特定于其委派职责的任务。每个用户要执行的命令被合并到每个用户的一个脚本文件中，这样我们就可以依次关注每个用户的任务和关注点，一次一个。

这些用户中的每一个都必须解决许多不同的主题，所有这些主题都与安全性相关。当我们朝着本文的目标努力的时候，这些关心的问题按照它们被需要的顺序被处理。我们将继续构建我在本书中介绍的所有主题。

在我们学习这些材料的过程中，你应该可以接触到代码。如果你正在远离你的计算机阅读这篇文章，我希望已经在文本中提供了足够的代码让你完全理解讨论。然而，这也是我的意图，你执行这个代码，并且这个文本将指导你理解在每一个结合点发生了什么。

当您处理代码时，您会发现执行各种脚本文件中的命令的最佳方式是将文件内容复制到 SQL 命令编辑器(如 TOAD 或 JDeveloper ),并一次执行一个命令。这优于将整个代码作为脚本执行，因为您将在执行时看到每个命令。记住，目标是理解安全编程，而不仅仅是实现安全软件。

### 作为 SYS 用户工作

有一个模式(同名)，并且有许多属于他的帐户的结构。您可以以`SYS`的身份连接(登录)到数据库，但是该用户的一个独特要求是您必须指定您正在使用`SYSDBA`特权。(请注意，在本文中，我将对 Oracle 命令中的保留字以及默认的 Oracle 用户、模式和结构全部使用大写。)

`CONNECT sys AS sysdba;`

此时，您必须输入与`SYS`用户相关的密码。

![images](images/square.jpg) **注意**你可以在名为 *Chapter2/Sys.sql* 的文件中找到以下命令的脚本。

#### 系统权限

`SYSDBA`是独特的系统特权；姑且称之为“超级”系统特权。它提供了几乎无限的管理能力。它可以授予任何用户，但最好只授予`SYS`。作为`SYS`你可以查看谁有`SYSDBA`:

`SELECT * FROM sys.v$pwfile_users;`

在这个查询中，您请求从`V$PWFILE_USERS`视图中`SELECT`(参见)所有列的数据(*)。系统。视图名称前缀表示拥有该视图的模式(用户)。您将看到在这个查询中列出了几个其他的超级系统特权:`SYSOPER`和`SYSASM`。这些也应该只授予`SYS`。

除了超级系统特权之外，还可以授予几十种其他系统特权，以提供诸如创建其他用户和授予他们特权之类的管理能力。我们将在探索 Oracle 安全性的过程中授予特权。

除了系统特权之外，还有模式对象特权。例如，这些允许另一个用户读取你的数据。我们也将授予这些特权。它们对 Oracle 应用程序安全性的影响更具针对性。

#### 角色

角色是授予权限的集合，比超级系统权限更精细、更多样、更有限。与授予`SYSDBA`不同，授予用户访问各种权限的首选方法是授予角色权限，然后授予用户角色。如果这样做，您总是可以替换作业中的不同用户，或者通过简单地将现有角色授予新用户，将作业所需的权限复制给另一个用户。(特权可以直接授予用户，但我们通常会避免这样做。)

例如，我可以创建一个名为`appaccess`的角色，并将读取应用程序表的能力授予该角色。然后，我可以将该角色授予用户。当我有另一个用户需要访问同一个应用程序时，我可以通过授予这个新用户`appaccess`角色来允许。当我删除第一个用户时，其他用户访问应用程序所需的权限不会在这个过程中消失。

如前所述，我需要授予对应用程序数据的访问权限，因为数据表将位于属于应用程序的模式中，并且每个用户都有自己的模式。用户不能读取其他模式中的数据，除非专门授权给他们或一个名为`PUBLIC`的特殊用户。授予`PUBLIC`的任何东西都授予所有用户。参见[表 2-2](#tab_2_2) 了解我们将讨论的 Oracle 角色列表。

![image](images/t0202.jpg)

##### DBA 角色

`DBA`角色以它所支持的工作命名:数据库管理员。它类似于`SYSDBA`超级系统特权。传统上，`DBA`角色被授予那些需要管理数据库的用户。`DBA`角色几乎和`SYSDBA`权限一样强大，但是可以对其进行修改，删除一些权限。

在 Oracle 的最新版本中，不鼓励数据库管理员使用 DBA 角色。相反，我们鼓励他们创建自己的角色，并授予所需的管理权限。因此，我们不会将`DBA`角色授予任何用户。

我们将创建一个安全管理员角色`secadm_role`。我们将在大多数管理操作中使用该角色。它将拥有各种特权，但仅限于本书范围所需的特权。这种方法遵循“最小特权”的概念，这意味着只提供手头任务所需的特权。

Oracle Database Vault 是一款允许您使用`DBA`和其他特权角色，同时限制其访问权限的产品。这是面向国防部和国家安全用户的，在这些用户中，数据库管理员不一定有权访问数据。

##### 创建-会话角色

我们还将创建一个简单的角色`create_session_role`，它只有一个特权:`CREATE SESSION`。用户需要有`CREATE SESSION`权限才能连接到 Oracle 数据库。传统上，这是通过名为`CONNECT`的预定义角色(在安装 Oracle 时存在)来完成的。在 Oracle 数据库的当前版本中，`CONNECT`只有一个特权。但是在这种情况下，与`DBA`角色一样，Oracle 建议管理员创建自己的角色，而不要依赖预定义的角色(如`CONNECT`)。按照`SYS`的方式操作:

`CREATE ROLE create_session_role NOT IDENTIFIED;
GRANT CREATE SESSION TO create_session_role;`

我们将把这个角色授予数据库中的所有用户。向每个用户授予`CREATE SESSION`特权所需的工作量与授予`create_session_role`所需的工作量完全相同。然而，角色作为特权的集中有一个好处。例如，如果我们想快速地将另一个特权授予所有用户，我们可以将它授予`create_session_role`；虽然，我不建议那样。更有可能的情况是，您需要保持数据库运行，但希望阻止所有用户连接到它。这可以通过一个命令来完成，从`create_session_role`中撤销`CREATE_SESSION`。

**未识别**

我希望`CREATE ROLE`语法相当明显。唯一奇怪的特性是`NOT IDENTIFIED`关键字。这仅仅表明，当用户获得这个角色时，我们没有任何密码或编码过程来验证他对它的访问。这种类型的角色必须通过管理命令授予用户(或另一个角色)。通常，被指定为`NOT IDENTIFIED`的角色也是默认角色，当用户连接到 Oracle 数据库时会自动获得这些角色。这是最常见的角色配置。

##### 使用角色

大多数角色被创建为默认角色。当用户连接到 Oracle 数据库时，他将获得所有默认角色，以及与这些角色相关的所有权限。任何常规`NOT IDENTIFIED`角色都可以设置为默认或非默认。

![images](images/square.jpg) **注意**在 Oracle Database 11g 中，当用户首次连接时，不再获取由密码标识的默认角色，用户必须输入密码。稍后会详细介绍。

Oracle 用户可以随时通过执行 SET ROLE 命令获得已授予的角色。对于默认角色和非默认角色都是如此。

当我们将角色设置为一个新角色时，它将成为唯一正在使用的角色，即使其他角色之前也在使用。幸运的是，会话已经被创建了(当新角色被设置时，我们已经被连接了)，所以我们可以忍受丢失`create_session_role`(这将会发生)。我可以想象一个场景，其中我们要求每个角色都被授予`CREATE SESSION`特权，这样当你`SET ROLE`时，你在新角色中仍然有`CREATE SESSION`。

有一种方法可以添加到现有的角色中，并保留现有的角色。通过发出以下命令:

`SET ROLE ALL;`

该命令不能用于设置由密码或程序设定的`IDENTIFIED`角色。然而，在您获得一个受密码保护的角色或安全应用程序角色(我们将在一分钟内讨论这些)之后，您也可以`SET ROLE ALL`并恢复您的默认角色。

我应该提到，角色可以被授予角色，我们将这样做。设置您的角色将替换您以前拥有的角色，但不仅包括您设置的角色，还包括授予该角色的所有角色，以此类推，递归进行。这些级联授权是有限制的，因此不会形成无限循环。

##### 受密码保护的角色

让我用一个关于 Oracle 11g 的说明来开始这个讨论:从这个版本的 Oracle 开始，为了从一个活动连接设置密码保护的角色，您必须提供密码，即使它是一个默认角色。这可能会让你措手不及。以前，如果某个角色受密码保护，但它是默认角色，则用户在连接时默认获得该角色。

我同意甲骨文的这一改变；出于同样的原因，我们在本书中将没有任何密码保护的角色。设置密码保护角色的唯一原因是，该角色被授予用户，但您不希望该用户使用该角色。您通过设置密码来保护角色，并且不要让用户知道。但是，我们不得不问，“为什么我们一开始就给他这个角色？”

更好的方法是只将角色授予需要它的用户。许多人可能作为特定的 Oracle 用户进行连接，其中一些人需要访问角色，而一些人不需要，这可能会使事情变得有些混乱。在这种情况下，我建议您要么让需要角色的人输入角色密码，要么更好地重新访问您的用户和角色并对它们进行分类。

一种可能性是有一个安全的应用程序角色，由一个过程来验证。可以根据用户 id 或某些组成员来授予该角色。则不需要角色密码。您只需要维护一个可接受的用户列表或组成员列表。

我观察到一个公司策略，用密码保护每个应用程序角色。这个想法是，坐在 SQL*Plus 等通用 SQL 客户端上的人将无法访问该角色，因为他们不知道密码。但是在我们希望他们拥有角色的应用程序中，会调用一个过程，通过在数据库表中查找角色密码来设置角色。这种配置可能对临时 Oracle 用户获得应用程序角色造成了一点障碍；然而，这里要观察的简单事实是，被授予该角色的人可以通过应用程序调用的同一个过程或该过程中的同一个代码来访问该角色。在 SQL*Plus 中，用户可以简单地调用过程，获取密码，并设置角色。

也许可以通过确保只使用某个特定的客户端应用程序来防止角色被盲目访问；同样，这是安全应用程序角色的工作。但是这里真正的问题是，一个角色被授予了一个 Oracle 用户，而管理员不希望该用户访问该角色。受密码保护的角色只能提供增强安全性的假象，除非您让特定用户记住并手动输入密码来设置角色。这就是 Oracle 11g 新策略背后的思想。

#### 安全管理员用户

让我们开始定义我们的安全管理员。安全管理员将是一个独立的非个人用户；也就是说，一个帐户和密码可以委派给不同的人，他们轮流进入和退出工作职责。安全管理员将执行通常由`DBA`甚至`SYS`执行的任务，但是我们将把授予安全管理员的权限限制在与应用程序安全相关的方面。

首先，作为`SYS`，我们将一步创建用户`secadm`并授予他`create_session_role`。用一个真实的密码替换该命令中的“密码”:

`GRANT create_session_role TO secadm IDENTIFIED BY password;`

![images](images/square.jpg) **注意**一定要给这个用户一个非常复杂的密码；它会强大到在坏人手里会很危险。该警告也适用于 SYS 和 SYSTEM 帐户。

#### 安全管理员角色

接下来，我们将创建安全管理员角色`secadm_role`。该角色将被授予执行安全管理所需的所有权限。然后，我们可以将这个角色授予任何用户，但是我们将它限制为只有一个用户，`secadm`。

首先，我想设置一些关于如何以及何时使用该角色的要求，所以我不会使用我们在`create_session_role`中看到的`NOT IDENTIFIED`关键字。相反，我将通过一个程序来鉴定(核实)它。你可以在这个命令中看到`sys.p_check_secadm_access`验证程序的名字:

`CREATE ROLE secadm_role IDENTIFIED USING sys.p_check_secadm_access;`

由过程标识的角色称为安全应用程序角色。

##### 安全管理角色验证

正如我提到的，安全管理员需要的所有特权都将被授予`secadm_role`，所以我们正在尽力保护它。关键字`IDENTIFIED USING sys.p_check_secadm_access`表示当用户试图获取`secadm_role`时，他必须从名为`p_check_secadm_access`的过程中获取，该过程存在于`SYS`模式中。

存储过程(procedure)是在 Oracle 数据库上存储和运行(执行)的过程语言/结构化查询语言(PL/SQL)代码的命名块。一般来说，一个过程接受参数并执行工作。它还可以通过其参数返回信息。在 Oracle 中也有存储函数(functions)，除了它们通常取值之外，与过程非常相似；做研究或计算；然后返回一个值作为结果。我们将同时使用过程和函数。

用于验证`secadm_role`、`p_check_secadm_access`的特定过程不带任何参数(传递给过程进行评估的参数或值)，并且不返回任何结果。大多数过程都需要参数，但这不是必须的。

在[清单 2-1](#list_2_1) 中，我们正在创建用于获取安全管理员角色的过程。注意，这个过程的简单目标是要求安全管理员与 Oracle 数据库服务器运行在同一台计算机上(IP 地址 127.0.0.1 也称为本地主机或回送地址)。此要求可能不适合您的系统；如果没有，您仍然可以创建这个过程，但是通过在前面放置两个破折号(减号)来注释掉以`IF`、`THEN`和`END IF`开头的三行。您可以作为`SYS`执行该命令，程序将被创建。

***清单 2-1。** `p_check_secadm_access`安全 App 角色的流程*

`CREATE OR REPLACE PROCEDURE sys.p_check_secadm_access
AUTHID CURRENT_USER
AS
BEGIN
    -- This is a comment
    IF( SYS_CONTEXT( 'USERENV', 'IP_ADDRESS' ) = '127.0.0.1' )
    THEN
        EXECUTE IMMEDIATE 'SET ROLE secadm_role';
    END IF;
END;
/`

我们以后会想回来访问(替换)这个过程，添加我们认为适当的任何附加安全约束。目前，我们的安全管理员必须直接连接到 Oracle 数据库(在服务器上运行 SQL*Plus)。)

作为一名程序员，您将已经理解了`IF` / `THEN` / `END IF`语法，并意识到还有其他 PL/SQL 语法要求，如`BEGIN` / `END`和分号。

查看`BEGIN`标志和最后一个`END`标志之间的代码。在这之间，它用英语说，“如果用户的环境有一个本地主机的*互联网协议* (IP)地址，那么立即将他的角色设置为`secadm_role`”我们使用`SYS_CONTEXT` *上下文*从*用户环境*中获取 IP 地址，并确定该地址是否等于 127.0.0.1 (localhost)。如果测试为真，那么我们立即将当前*会话*的角色设置为`secadm_role`。

**调用者的权利与定义者的权利**

在我们上面定义的过程中，我们说`AUTHID CURRENT_USER`，以便这个过程作为当前用户执行，而不是作为`SYS`(定义这个过程的人。)所以在执行时，这个过程将使用所谓的“调用者的权利”(`CURRENT_USER`)，而不是“定义者的权利”(默认或所有者，在本例中是`SYS`)。如果我们不这样做，当我们执行该过程时，环境和身份将看起来是`SYS`，但是我们希望能够确定特定的当前用户的可接受性(授权)。我们需要使用 invoker 权限执行的另一个原因是，否则我们不允许从过程中设置角色——我们只能为经过*身份验证的*(当前)用户设置角色。

##### 安全管理员角色获取

我们还没有完成对安全管理员的定义。我们需要允许安全管理员执行我们创建的过程。我们通过发出以下命令来做到这一点:

`GRANT EXECUTE ON sys.p_check_secadm_access TO secadm;`

注意，我们不需要将`secadm_role`授予`secadm`；相反，如果用户满足过程的所有要求(`p_check_secadm_access`)，那么`IDENTIFIED USING`过程将把他的角色设置为`secadm_role`。这里有一个类似的限制:要么授予角色，要么授予执行过程的能力，这将设置角色。在这两种情况下，您都通过要求特定授权来限制对角色的访问。但是，通过使用过程来设置角色，您可以对访问设置进一步的限制。

请注意，在这种情况下，我们直接向用户授予特权(执行过程)，而不是像我们之前建议的那样，向角色授予权限，然后向用户授予角色。每个规则都有例外！这个特殊异常的原因是我们用一个过程来保护一个角色。我们不需要用角色来进一步保护过程。

安全管理员，`secadm`用户可以通过执行如下所示的过程来获取`secadm_role`。事实上，每次 secadm 连接到 Oracle 数据库时，他都需要调用那个过程来获得`secadm_role`角色。

`EXEC sys.p_check_secadm_access;`

##### 授予安全管理员角色的系统权限

我们希望安全管理员拥有的大部分权限将由`SYS`授予:

`GRANT
    CREATE USER
    ,ALTER USER
    ,CREATE ROLE
    ,GRANT ANY OBJECT PRIVILEGE
    ,GRANT ANY PRIVILEGE
    ,GRANT ANY ROLE
    ,CREATE ANY PROCEDURE
    ,CREATE ANY TRIGGER
    ,CREATE ANY CONTEXT
    ,CREATE PROFILE
    ,AUDIT SYSTEM
    ,AUDIT ANY
TO secadm_role;`

我们授予`secadm_role`的大部分系统特权允许我们做一些我们作为`SYS`已经在做的事情。我们将允许我们的安全管理员创建和修改用户，创建角色并向用户授予角色。`secadm`将授予角色使用其他模式中的 Oracle 对象(结构)的权限。他将向角色授予某些系统特权。他还将创建过程和触发器，它们类似于过程，但在特定事件发生时执行(我们稍后将对此进行更多讨论。)当我们到达第 10 章时，我们还将创建一个应用程序上下文。安全管理员将创建配置文件，我们将在第 8 章中看到。现在，我们依赖默认的配置文件。

我们还将作为安全管理员设置一些审计。我们将审计各种各样的系统事件，并且我们将审计对表和`HR`模式中其他结构的访问——因此有了`AUDIT ANY`特权。任何时候在对象特权授予中看到`ANY`，都可以理解为“在任何模式中”通常，用户在自己的模式中已经拥有这些特权。

这些并不是我们的安全管理员完成工作所需的所有系统和模式对象权限，但是它们将帮助我们开始工作。稍后我们将以`SYS`的身份回来，给安全管理员更多的特权。

#### 审计线索

最后，作为`SYS`，我们将在审计线索本身上设置一些初始审计。这将阻止流氓数据库管理员做错事，然后通过删除他们的审计记录来清除他们的踪迹:

`AUDIT SELECT, UPDATE, DELETE
    ON sys.aud$
    BY ACCESS;`

当我们指定`BY ACCESS`进行审计时，我们是说我们想要详细的信息。另一个(可能是默认的)选项是`BY SESSION`。这提供了较少的细节，但仍然审计每个事件，而不是像早期版本的 Oracle 那样，只为每个会话提供一个审计记录。

#### 数据字典

我们希望我们的安全管理员能够查看数据字典中的所有数据，数据字典是列出 Oracle 中的结构和系统数据的`SYS`模式中的视图集合。(*视图*是查看数据表的定义方式。)例如，我们可能希望列出所有数据库用户的详细信息:

`SELECT * FROM sys.dba_users;`

在`DBA_USERS`视图中有许多列在`PUBLIC`数据字典视图中是不可用的:`ALL_USERS`(更少的细节)和`USER_USERS`(更多一点的细节，但只针对当前用户)。

默认情况下，大部分数据字典已经被授予`PUBLIC`，每个用户都可以选择。在大多数情况下，这是必要的。但是我们会在第 11 章[、*加强我们的安全*中更严格地处理这个问题。然而，选择数据字典的某些部分需要`SELECT_CATALOG_ROLE`。将该角色授予`secadm_role`:](11.html#ch11)

`GRANT select_catalog_role TO secadm_role;`

请注意，这是授予角色的角色。从现在开始，当我们将角色设置为`secadm_role`时，我们也将拥有`SELECT_CATALOG_ROLE`。

### 担任安全管理员

现在，我们的安全管理员已经被定义了完成工作所需的权限，我们将让他开始工作。继续并连接:

`CONNECT secadm;`

![images](images/square.jpg) **注意**你可以在名为 *Chapter2/SecAdm.sql* 的文件中找到以下命令的脚本。

您应该还记得，在我们创建安全管理员角色`secadm_role`时，我们要求通过一个过程对其进行验证。我们只允许一个账户`secadm`执行该程序。立即执行获取`secadm_role`:

`EXEC sys.p_check_secadm_access;`

注意，当`secadm`连接到 Oracle 时，他不会自动获取`secadm_role`。因为是安全申请(验证)角色，没有直接授予`secadm`，所以不能作为默认角色。每次`secadm`用户连接时，他都必须执行该过程来获得他的安全管理员角色和权限。

这与直接授予用户的角色相反，角色最初是默认角色。可以取消设置默认角色的状态。

#### 从 SQL*Plus 本地连接获取 secadm_role

总会遇到一些问题，如果您使用 SQL*Plus 作为主要客户端，这里有一个问题可能会困扰您几次:当您坐在 Oracle 数据库的命令提示符下时，您可以本地连接到默认实例。通过执行不带任何参数的 SQL*Plus 来实现，如下所示:

`sqlplus`

您可以通过输入用户名和密码以`secadm`用户的身份进行连接。如果您随后试图执行设置`secadm_role`的过程`sys.p_check_secadm_access`，它将不会成功。为什么不成功？我们的地址应该是 localhost 的地址，这应该没问题。嗯，当本地连接时，SQL*Plus 根本不使用网络—它只是直接与数据库对话。通过执行以下命令，您可以看到缺少 IP 地址信息:

`SELECT SYS_CONTEXT( 'USERENV', 'IP_ADDRESS' ) FROM DUAL;`

这对安全性有一些影响。像这样进行本地连接时，您输入的命令不会通过网络适配器，也不可能在网络上泄露给窥探设备。

那么，您可能会问，我们应该如何以`secadm`的身份连接，并在 Oracle 数据库上从 SQL*Plus 运行`sys.p_check_secadm_access`？有一种方法，只需要在命令行上添加用户名和实例名(在本例中是`orcl`)的参数，就像没有本地连接一样。实际上，这个上下文中的`orcl`是一个与实例同名的 TNS 别名。我们将在第 11 章中讨论 TNS 别名[。](11.html#ch11)

`sqlplus secadm@orcl`

此时，您在会话上下文中有了一个 IP 地址，并且可以通过以下过程成功地设置角色:

`SELECT SYS_CONTEXT( 'USERENV', 'IP_ADDRESS' ) FROM DUAL;
EXEC sys.p_check_secadm_access;`

#### 在角色之间切换

当您在`create_session_role`和`secadm_role`之间来回切换时，通过观察您当前的会话角色，您可以看到运行`SET ROLE`的效果。作为`secadm`用户，这样做并在执行每个`SELECT`查询时观察角色列表:

`SELECT * FROM sys.session_roles;
SET ROLE create_session_role;
SELECT * FROM sys.session_roles;
EXECUTE sys.p_check_secadm_access;
SELECT * FROM sys.session_roles;`

当您执行程序，然后从`SESSION_ROLES`中选择时，您将看到三个角色。该过程本身将您的角色设置为`secadm_role`。为了这个角色，我们授予了`SELECT_CATALOG_ROLE`。而 `SELECT _CATALOG_ROLE`已经被授予`HS_ADMIN_SELECT_ROLE`。所有这些都将被列为会话的当前角色。如果您的 Oracle 数据库上安装了其他程序包或不同版本，您可能会看到与这些程序包相关的其他角色。

#### 创建应用安全用户

我们需要更多的用户来开发和展示我们的安全性。第一个用户是我们的应用安全用户，`appsec`。她将拥有使我们的应用程序安全工作的所有结构。

请注意我在 Oracle 安全(我们已委托给安全管理员)和应用安全之间所做的区分。安全管理员被授予了许多系统权限，因此他可以在 Oracle 中创建用户和执行其他任务。另一方面，应用程序安全用户将拥有许多用于应用程序安全流程的过程和结构。应用程序安全用户不会作为任何特定应用程序的一部分进行连接；相反，她将授权应用程序用户访问她的逻辑和数据。

`GRANT create_session_role TO appsec IDENTIFIED BY password;`

![images](images/square.jpg) **注意**一定要给这个用户一个非常复杂的密码；她在数据库中没有重要的特权，但是她拥有一些我们不想暴露的逻辑和数据。

##### 应用安全角色

我们的应用程序安全用户需要创建过程、函数、Java 存储过程、表和视图。创建这些项目时，`appsec`需要`CREATE PROCEDURE`、`CREATE TABLE`和`CREATE VIEW`系统权限。我们将这些特权授予名为`appsec_role`的角色，并将该角色授予`appsec`用户:

`CREATE ROLE appsec_role NOT IDENTIFIED;
GRANT CREATE PROCEDURE TO appsec_role;
GRANT CREATE TABLE TO appsec_role;
GRANT CREATE VIEW TO appsec_role;
GRANT appsec_role TO appsec;`

##### 非默认角色

我们的应用程序安全用户只是偶尔需要这些特权(例如，`CREATE PROCEDURE`)。我们希望她根据需要将自己的角色设置为`appsec_role`，但目前这是一个默认角色。为了将创建为`NOT IDENTIFIED`的角色的行为从默认角色更改为非默认角色，我们需要发出`ALTER USER`命令。在下面的命令中，我们要求 Oracle 将授予`appsec`用户的所有角色都设为`DEFAULT`，除了我们想要排除的角色:

`ALTER USER appsec DEFAULT ROLE ALL EXCEPT appsec_role;`

此后，当`appsec`为了创建新结构而连接时，她将不得不发出`SET ROLE`命令之一。(不要以`secadm`用户的身份执行这些命令——这里，它们仅用于解释。)

`SET ROLE appsec_role;
SET ROLE ALL;`

上面列出的第二个命令将为`appsec`设置当前会话，以启用`ALL`已经被授予的角色，包括默认和非默认角色。

#### 创建应用程序用户

作为连接到 Oracle 运行应用程序的示例用户，我们将创建一个应用程序用户`appusr`。出于我们的目的，`appusr`并不局限于一个人，而是 Oracle 所称的“一个大型应用程序用户”模型用户。在这种模式下，许多人将使用一个应用程序，该应用程序将他们作为一个大的应用程序用户连接到 Oracle。他们不需要个人帐户和密码进行访问。

`GRANT create_session_role TO appusr IDENTIFIED BY password;`

![images](images/square.jpg)注意:请务必为该用户提供一个非常复杂的密码——他们可能会选择数据并更新应用程序数据。我们只希望该活动发生在应用程序内部。我希望你已经习惯了这个关于密码的警告，甚至可以预见到它。

**个人账户**

我们将有机会创建特定于个人的 Oracle 用户帐户；然而，维护这些用户(以及授予、验证和撤销所需的特权)的管理需求是一项巨大的责任。我认为有更好、更简单和更安全的方法来识别和授权数据库中的个人，我们将在第 8 章中讨论这个问题。

#### 创建人力资源视图角色

我们将开始保护对人力资源(`HR`)示例模式中数据的访问。我们将创建一个名为`hrview_role`的角色。通过这个角色，我们将授权访问我们计划构建的各种应用程序所需的数据。一开始，我们只希望在我们的内部网络上的人们能够访问这些数据，而且只能在我们正常的办公时间(早上 7 点到晚上 7 点)访问。

为了完成这些约束，我们将创建角色，并要求通过一个过程对其进行验证。Oracle 称之为安全应用程序角色，因为这是它的功能–它是一个提供应用程序数据访问权限的角色，但它受到一些编码约束的保护。这和我们保护`secadm_role`的方法是一样的。

`CREATE ROLE hrview_role IDENTIFIED USING appsec.p_check_hrview_access;`

##### 通过流程验证人力资源视图角色

正如我们之前对`secadm_role`所做的一样，我们将创建一个过程来保护对`hrview_role`的访问。在程序结束时，如果`CURRENT_USER`满足程序中编码的要求，我们将`SET ROLE`到`hrview_role`。

通过执行清单 2-2 中的[代码作为`secadm`来创建程序。这里，我们在另一个模式中创建了一个过程。注意模式名 appsec。附加在过程名的前面。为此，需要`secadm`拥有`CREATE ANY PROCEDURE`系统特权。](#list_2_2)

***清单 2-2。** `p_check_hrview_access`安全 App 角色的流程*

`CREATE OR REPLACE PROCEDURE appsec.p_check_hrview_access
AUTHID CURRENT_USER
AS
BEGIN
    IF( ( SYS_CONTEXT( 'USERENV', 'IP_ADDRESS' ) LIKE '192.168.%' OR
        SYS_CONTEXT( 'USERENV', 'IP_ADDRESS' ) = '127.0.0.1' )
    AND
        TO_CHAR( SYSDATE, 'HH24' ) BETWEEN 7 AND 18
    )
    THEN
        EXECUTE IMMEDIATE 'SET ROLE hrview_role';
    END IF;
END;
/`

注意，这里我们又有了语句`AUTHID CURRENT_USER`。我们将使用调用者的权限(IR)而不是默认定义者的权限(DR)来执行。在这个过程中，我们在`IF`语句中编码了两个测试。对于那些通过两个测试的会话，我们将角色设置为`hrview_role`。

##### 子网测试

在`p_check_hrview_access`中的第一个测试，如[清单 2-2](#list_2_2) 所示，从用户环境中获取客户端的 IP 地址，并测试它是否以字符串“192.168”开头`LIKE`语法表示地址应该由指定的字符后跟零个或多个字符组成(符号“%”是通配符)。该测试确保客户端存在于我们的内部公司子网上。(“192.168”是非路由子网，可以在防火墙后或测试子网中使用。它通常是用于通过 DSL 或电缆调制解调器连接到互联网的家庭网络的子网。)您的公司子网很可能与此子网不同，因此在创建之前，请修改该过程的代码。在命令提示符下，您可以通过发出以下命令来查找 Windows 工作站的 IP 地址和其他网络信息:

`C:\>ipconfig /all`

工作站 IP 地址的前两个八位字节(由点分隔的三位数或更少位数的集合，或二进制的八位数的集合)可能代表您的公司子网。请联系您的网络支持人员，以确定具体使用什么。

此过程还允许您从 Oracle 数据库服务器本身连接到 Oracle。如果 IP 地址是 127.0.0.1，即本地主机地址(即 Oracle 数据库服务器本身)，则该过程也会成功。

##### 测试正常营业时间

`p_check_hrview_access`中的第二个测试，如[清单 2-2](#list_2_2) 所示，包含语句`TO_CHAR (SYSDATE, 'HH24') BETWEEN 7 AND 18`。让我们花点时间来分析一下。`SYSDATE`是 Oracle 数据库中当前时间和日期的名称。您可以从服务器`SELECT`(请求)`SYSDATE`，并且您可以在 Oracle 中更新数据时将日期值设置为等于`SYSDATE`。在这种情况下，我们请求`SYSDATE`并使用`TO_CHAR`函数将日期的小时(`HH24`)部分格式化为使用 24 小时格式的字符串。在这种格式下，当是 7AM 时，`TO_CHAR`函数会返回 7；晚上 7 点 19 分。所以我们检查时间是`BETWEEN` 7 和 18(在下午 6:59，这个测试仍然为真；但是晚上 7 点，假的。)我们已经确定我们的正常营业时间是早上 7 点到晚上 7 点，所以这些测试是有效的。

![images](images/square.jpg) **注意**这里没有代码可以在晚上 7 点到达时断开用户与 Oracle 的连接。该代码仅阻止在晚上 7 点后建立进一步的连接。

##### 允许应用程序用户获得人力资源视图角色

每个需要访问`HR`数据的用户都必须执行`p_check_hrview_access`程序来设置`hrview_role`。只有`hrview_role`可以访问数据，设置该角色的唯一方法是执行过程。我们将授予我们的应用程序用户`appusr`执行此过程的`EXECUTE`权限。如`secadm`所示，执行以下命令:

`GRANT EXECUTE ON appsec.p_check_hrview_access TO appusr;`

在这个过程中，我们必须将`EXECUTE`授予所有需要访问数据的用户。或者，我们可以向`PUBLIC`授予`EXECUTE`特权，但是只有当数据库的每个用户都需要访问`HR`数据时，我们才会这样做。不要不考虑后果就授予`PUBLIC`特权。

#### 审核对安全管理员程序的更改

我们将通过建立一些额外的审计来结束本章的这一部分。因为我们作为`SECADM`工作，所以我们定义审计的默认结构在`SECADM`模式中。我们将审计模式中过程的任何变化，因为它们是安全相关的。我们需要确保任何变更都经过审核。

`AUDIT ALTER ANY PROCEDURE BY ACCESS;`

当 secconf.sql 脚本作为数据库创建的一部分运行时，这实际上是默认情况下审计的权限之一。

#### 审核访问人力资源数据的失败尝试

我们对访问`HR`数据的第一次审计实际上是对试图执行`p_check_hrview_access`过程的审计，该过程设置了`hrview_role`。我们不想知道这个过程何时成功，但是我们想知道无效访问何时被尝试，所以我们使用关键字`WHENEVER NOT SUCCESSFUL`。

`AUDIT EXECUTE ON appsec.p_check_hrview_access
    BY ACCESS
    WHENEVER NOT SUCCESSFUL;`

### 作为人力资源方案用户工作

对于本书提出的几个方面，我们将使用可以与 Oracle 11g 一起安装的`HR`示例模式。如果您还没有安装这个模式，那么在前面的步骤中配置对`HR`模式结构的审计就会遇到困难。请浏览 Oracle 网站，了解如何在事后安装示例模式。

现在，在安装 Oracle 时，您还有机会为`HR`用户配置一个密码。如果样本模式存在，但是没有配置`HR`用户(或者只是重新配置用户)，您可以发出`ALTER USER`命令(作为`SYS`或`secadm`):

`ALTER USER hr ACCOUNT UNLOCK IDENTIFIED BY password;`

![images](images/square.jpg) **注意**一定要给这个用户一个非常复杂的密码；人力资源部拥有我们试图保护的数据。

以`HR`用户身份连接到 Oracle:

`CONNECT hr;`

`HR`在他自己的模式之外没有系统特权，但是被授予了连接数据库和在他自己的模式中创建许多结构所需的特权:表、视图、索引等等。

![images](images/square.jpg) **注意**你可以在名为 *Chapter2/HR.sql* 的文件中找到以下命令的脚本。

#### HR 示例模式中的敏感数据

在可以与 Oracle 11g 一起安装的`HR`示例模式中，有一个名为`EMPLOYEES`的表。该表有两列，我们称之为“敏感的”:`SALARY`和`COMMISSION_PCT`。我们的目标是在不泄露敏感数据的情况下授予对该表的访问权限。

使用此命令查看`EMPLOYEES`表的内容，如`HR`:

`SELECT * FROM hr.employees;`

让我们假设我们公司的目标是发布一个在线人员目录(电话簿)，并且这个表是主要的源数据。我们可以只导出电话簿中使用的数据的非敏感部分，但是最好是直接授予对该表中主要数据的安全访问权限，而不是复制数据(假设我们的数据库服务器支持额外的负载)。

#### 员工的公共视野

授予对数据表的有限访问权的最基本方法是创建一个视图。视图就像我们放在数据表上的过滤器，可以只显示某些数据，重新组织数据，格式化数据，并提供来自多个表或其他视图的数据。我们将创建一个名为`v_employees_public`的视图，它只包含非敏感的数据列:

`CREATE OR REPLACE VIEW hr.v_employees_public
AS SELECT
    employee_id,
    first_name,
    last_name,
    email,
    phone_number,
    hire_date,
    job_id,
    manager_id,
    department_id
FROM hr.employees;`

测试新视图，确保它只返回我们请求的数据。我们应该注意到`SALARY`和`COMMISSION_PCT`列丢失了:

`SELECT * FROM hr.v_employees_public;`

因为我们已经从这个视图中省略了敏感列(`SALARY`和`COMMISSION_PCT`)，所以我们可以将对这个视图的访问权授予整个公司，而不会暴露敏感数据。我们可以把它授予`PUBLIC`；然而，我们仍然觉得有点保护我们的数据，我们想确保访问是受控的，所以我们将视图的访问权授予我们的安全应用程序角色，`hrview_role`而不是`PUBLIC`。`HR`用户有权授予对自己模式中结构的访问权限:

`GRANT SELECT ON hr.v_employees_public TO hrview_role;`

有了这个授权，我们就可以从视图中获取`hrview_role`到`SELECT`的数据。可以授予视图的其他常见特权有`INSERT`、`UPDATE`和`DELETE`。我们目前不会授予任何特权。`hrview_role`可以通过`v_employees_public`视图看到但不能修改非敏感数据。

#### 员工的敏感观点

既然我们已经配置了非敏感视图，那么如何为`EMPLOYEES`表的所有列创建敏感视图应该是显而易见的。作为`HR`，我们创建一个视图:

`CREATE OR REPLACE VIEW hr.v_employees_sensitive
    AS SELECT *
    FROM hr.employees;`

星号(*)表示所有列，该视图从所有列中选择所有数据。测试该视图是否返回了来自`EMPLOYEES`表的所有数据:

`SELECT * FROM hr.v_employees_sensitive;`

这个视图在应用程序的某些时候可能很有用——例如，当我们想让某些财务分析师计算有多少人挣了一定的薪水，为每年的加薪做准备。我们可能还希望将这个视图用于一个财务应用程序，我们希望授予`UPDATE`对发放加薪的访问权。允许人力资源部门在雇佣和解雇员工时从数据库中选择`INSERT`和`DELETE`员工，这也是非常有用的。

然而，考虑到数据的敏感性(你和我或者我们的经理挣多少钱)，我们根本不打算授予对这个视图的访问权。稍后，我们将通过更加严密保护和加密的渠道提供对这些数据的访问。

我们关于人力资源数据的第一个审计语句在前面的“审计访问人力资源数据的失败尝试”一节中给出下面是我们对`HR`数据的第二份审计声明。有了它，我们打算审计对`EMPLOYEES`表的敏感视图的任何直接访问。稍后，我们将查看审计那些我们认为敏感的字段的选择，无论它们是从什么视图或表中选择的。

`AUDIT SELECT ON hr.v_employees_sensitive BY ACCESS;`

### 测试应用程序用户访问

为了测试我们的安全性，我们需要尝试我们认为不应该工作的事情(因为我们的安全措施)以及我们允许成功的事情。为此，您需要以`appusr`用户的身份连接到 Oracle:

`CONNECT appusr;`

![images](images/square.jpg) **注意**你可以在名为 *Chapter2/AppUsr.sql* 的文件中找到以下命令的脚本。

我们认为，接下来的三个命令将会失败，因为`appusr`用户没有被直接授权访问`HR`模式中的任何内容。他只有默认角色，也没有访问权限。我们应该会看到一条错误消息，指出这些表或视图不存在。

`SELECT * FROM hr.employees;
SELECT * FROM hr.v_employees_sensitive;
SELECT * FROM hr.v_employees_public;`

现在我们将执行检查我们有效性的过程，然后将 role 设置为`hrview_role`。如果我们在公司的子网上(或者在 Oracle 数据库服务器上),并且时间在早上 7 点到晚上 7 点之间，那么这应该会成功:

`EXEC appsec.p_check_hrview_access;`

然后，我们将测试对`HR`模式中的`EMPLOYEES`结构的访问。我们不期望前两个命令起作用；我们应该再次看到一条错误消息，指出这些结构不存在。`hrview_role`不允许访问敏感数据；

`SELECT * FROM hr.employees;
SELECT * FROM hr.v_employees_sensitive;`

在最后一个命令中，我们应该看到来自`EMPLOYEES`表的数据；然而，我们注意到数据中缺少了两列:`SALARY`和`COMMISSION_PCT`。

`SELECT * FROM hr.v_employees_public;`

### 敏感视图的审计跟踪日志

让我们找到该访问的审计日志条目。`HR`用户无权读取审计日志(如果他尝试，他将被审计)，但是如果你以`secadm`身份连接并执行以下命令，你将看到由`HR`查询`v_employees_public`生成的审计日志:

`EXEC sys.p_check_secadm_access;

SELECT OBJECT_NAME, STATEMENT_TYPE, RETURNCODE FROM DBA_COMMON_AUDIT_TRAIL
        WHERE DB_USER='HR'
        ORDER BY EXTENDED_TIMESTAMP DESC;`

当我们仍然以`secadm`的身份在这里时，我们应该尝试访问敏感视图，并查看这个失败尝试的审计日志条目(`secadm`无法读取敏感视图)。您还将看到由`secadm`执行的审计跟踪`SELECT`语句的日志。

`SELECT OBJECT_NAME, STATEMENT_TYPE, RETURNCODE FROM DBA_COMMON_AUDIT_TRAIL
        WHERE DB_USER='SECADM'
        ORDER BY EXTENDED_TIMESTAMP DESC;`

0 的`RETURNCODE`表示成功，而非零的`RETURNCODE`表示失败。

### 关于同义词

同义词就像 Oracle 中结构的额外名称，主要用于表和视图。同义词最有说服力的论据是使用公共同义词。如果我们为一个视图创建一个公共同义词，那么从该视图中选择的任何人都不需要在视图名前面加上模式名。`HR`用户可以执行以下操作来创建公共同义词。(不要这样做—此示例仅供讨论。)

`CREATE PUBLIC SYNONYM v_employees_public FOR hr.v_employees_public;`

这不会改变视图或数据的安全性或可访问性。但是，它允许角色`hrview_role`选择不带 hr. schema 名称前缀的数据，如下所示:

`SELECT * FROM v_employees_public;`

也可以为同义词指定一个不同于它所代表的结构名称的名称，如下所示:

`CREATE PUBLIC SYNONYM employees FOR hr.v_employees_public;`

也许这可以简化名称——如果我们希望用户在命令提示符下输入他们的所有查询，这可能会有所帮助。(不要这样做—此示例仅供讨论。)您可以想象，在设置数据库管理员之后出现的继任数据库管理员可能会有些困惑。员工可能会抱怨他们不能从`EMPLOYEES`中选择，继任管理员可能会回答说没有人可以，因为他不知道员工说的是同义词，而不是表或视图。同样，如果视图`hr.v_employees_public`被丢弃(删除)，同义词将被破坏。

单个用户可能会创建一个专用同义词供自己使用(仅供特定用户/模式使用)。她可能会这样做，这样她就可以用她最喜欢的术语“同龄人”来称呼`HR.EMPLOYEES`然而，当她试图与她的同事共享任何数据库查询或代码时，他们会对她的私人同义词感到沮丧。使用她的私有同义词的查询对其他人不起作用。

我也观察过将同义词合并到安全策略中的尝试，隐藏具有相同名称的公共或私有同义词的原始表。相信这样的诡计是愚蠢的。

使用同义词的最好理由可能是让程序员编写代码稍微容易一些，因为他们不必记住用那些讨厌的模式名作为表和视图名的前缀。然而，我观察到当一个表或视图从开发环境(Oracle *实例*)迁移到生产环境，但是公共同义词被留下时，应用程序会失败。我知道这不应该发生，但它发生了。那么数据就在生产环境中，但是应用程序失败了，因为它缺少同义词或者只是缺少代码中的模式名。这很难排除故障。

我建议您尽量不要使用同义词，只让开发人员用模式名前缀来表示他们所在的表和视图。我不指望每个人都听从我的建议，但请至少考虑一下。

同义词的另一个论点是引用另一个数据库实例上的结构。在这种情况下，同义词还可以包括数据库链接。我并不反对使用同义词，因为如果数据库链接名称发生变化，指定和更新起来肯定会更容易。我提醒您，无论数据出现在哪里，您都需要保护它，即使是跨数据库链接。还应该对非生产环境中生产数据的可见性和使用进行限制；更是如此，反之亦然。

### 章节回顾

现在，您有了一个安全管理员用户，他不是 DBA，但是可以处理所需的大多数 Oracle 安全任务。此外，您还有一个应用安全用户，他将处理 Oracle 应用安全所需的事务。

您已经锁定了我们的 Oracle 数据库，添加了一些基本的审计，并了解了数据字典视图。我们讨论了角色:预定义角色、默认角色、非默认角色和安全应用程序角色。在我们对应用程序安全性的第一次尝试中，我们构建了几个安全的应用程序角色和保护它们的过程。

在应用程序数据模式`HR`中，我们区分了敏感数据和非敏感数据，并只创建了非敏感数据的公共视图。我们还创建了敏感和非敏感数据的视图，但是我们还不允许任何人查看。然后我们查看审计跟踪日志中与我们的敏感视图`EMPLOYEES`相关的条目。