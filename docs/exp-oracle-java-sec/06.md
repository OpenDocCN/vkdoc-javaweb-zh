## C H A P T E R 6

## 秘密密码加密

我所说的秘密密码加密(password encryption)也被称为共享秘密密码加密和基于密码的加密(PBE)。基本上，这个想法是两方都知道一个密码短语(或密码——我会交替使用这两个词),并且他们都使用这个密码来加密消息或数据。收件人使用相同的密码来解密邮件和数据。没有其他人可以解密数据，因为密码是一个秘密，只有双方共享。

密码加密对我们有好处，原因有几个，主要是它可以用于加密更大的数据块。我们将使用美国数据加密标准(DES)和密码块链接(CBC ),自动将任何大小的数据分成适当的块进行加密；解密后，将结果组合回原始数据。

密码加密的另一个好处是没有公钥，也就是说，没有人知道我们用来加密数据的密钥，假设我们已经充分保护了密码。另一种方法是在客户机和服务器上都使用公钥加密，每一方都用另一方的公钥加密数据，只有接收者才能读取。为了增加保证，让每个人首先用自己的私钥加密他们的消息，然后用另一个人的公钥。仔细想想，你会发现不仅收件人可以解密信息，而且预期的发件人也可以发送信息。(添加一个像 VeriSign 这样的可信证书颁发机构(CA ),您就有了身份保证——每个人都是他们所说的那个人。)然而，我们将仅通过我们的秘密密码加密获得这些好处中的大部分。

我们将在 Oracle 服务器上创建一个密码，并秘密地将其传递回客户端。我们将通过使用客户端的 RSA 公钥对密码进行加密来使其保密。为此，客户机已经将公钥工件(模数和指数)传递给了 Oracle 服务器。只有客户端可以使用私钥解密密码短语。

除了 RSA 公钥加密之外，使用密码加密的最后一个好处是，任何攻击者都必须攻击这两种协议才能拦截我们的数据。

### 接近

当你通读本章时，你会想要打开参考文件，以跟随完整的代码清单。首先，我们将讨论我们为秘密密码加密实现的 Java 代码，因为我们将在 Java 中构建加密密钥并进行加密。然而，在本章结束之前，我们不会编译和运行 Java 代码。然后我们将分两个阶段运行它:第一个阶段将在客户端计算机上用 Java 进行加密和解密；第二阶段将完成客户端计算机和 Oracle 数据库之间的密码加密密钥交换，并演示客户端/服务器加密/解密。

在本章末尾进入测试阶段之前，我们还将讨论这个过程所需的 Oracle SQL 代码。正如我们讨论的那样，您可以随意执行 SQL 代码来创建我们在 Oracle 数据库上需要的结构，或者您可以在我们进行第二阶段测试之前执行所有的 SQL 代码。

### Java 密码加密代码

我们将返回来添加代码并编辑我们在上一章中介绍的`OracleJavaSecure`类。这个类将构成我们在客户端和 Oracle 数据库上的所有安全流程的核心。随着我们在这一部分的进展，打开 OracleJavaSecure.java*并参考完整的代码清单，你会受益匪浅。我们将替换 Oracle 数据库中的`OracleJavaSecure`类，并在我们的客户端计算机上编译和运行更新后的代码，直到本章结束并进行一些测试。*

#### 共享秘密密码钥匙的神器

有几个基于 DES 密码的加密工件必须在客户机和服务器之间共享，以便在每一端都有相同的加密密钥和`Cipher`。首先，有一个密码短语，只有参与加密对话的双方知道。

还有另外两个工件必须共享，但是在特定的上下文中通常被视为常量。这些是 salt 和迭代计数。将这两个参数固定为常数是一个主要缺点。供应商通常会混淆(隐藏)他们的代码，以隐藏这些值。任何能够窃取 salt 和迭代次数的黑客在解密你的数据上都有优势。

我们的计划是为每个会话生成三个不同的工件。我们将使用`SecureRandom`实例来生成随机迭代计数和随机 salt。我们还将从随机可接受的字符中生成最大长度的密码短语。

##### 生成密码和工件

既然我们在这个主题上，让我们继续下去，看看我们如何生成这些工件。我们在`makeSessionSecretDESPassPhrase()`方法中完成，其代码如[清单 6-1](#list_6_1) 所示。

***清单 6-1。**生成 DES 密码神器`makeSessionSecretDESPassPhrase()`*

`    private static SecureRandom **random** = new SecureRandom();

    private static final int SALT_LENGTH = 8;
    private static int maxPassPhraseBytes;
    private static char[] sessionSecretDESPassPhraseChars = null;
    private static byte[] salt;
    private static int iterationCount;
    private static void makeSessionSecretDESPassPhrase() {
        // Pass Phrase, Buffer size is limited by RSACipher class (on Oracle JVM)
        // Max size of data to encrypt is equal to the key bytes minus padding
        // (key.bitlength/8)-PAD_PKCS1_LENGTH (11 Bytes)
        maxPassPhraseBytes = ( keyLengthRSA/8 ) - 11;
        sessionSecretDESPassPhraseChars = new char[maxPassPhraseBytes];
        for( int i = 0; i < maxPassPhraseBytes; i++ ) {
            // I want printable ASCII characters for PassPhrase
            sessionSecretDESPassPhraseChars[i] =
                    ( char )( **random.**nextInt( 126 - 32 ) + 32 );` `        }
        // Appreciate the power of random
        iterationCount = **random**.nextInt( 10 ) + 15;
        salt = new byte[SALT_LENGTH];
        for( int i = 0; i < SALT_LENGTH; i++ ) {
            salt[i] = ( byte )**random.**nextInt( 256 );
        }
    }`

![images](images/square.jpg) **注意**你可以在文件 *[第六章](#ch6)/orajavsec/Oracle javasecure . Java .*中找到这段代码

##### 计算密码的大小

在清单 6-1 中你会注意到的第一件事是密码短语的最大长度的定义。它是根据 RSA 密钥的大小计算的。

`        maxPassPhraseBytes = ( keyLengthRSA/8 ) - 11;`

我们将密码长度基于 RSA 密钥大小的原因是，我们将使用公钥加密我们的密码，而 RSA 只能加密小于其自身密钥的字节数组，减去填充。

我们可以让`maxPassPhraseBytes`成为一个常数，但是如果我们不知道它的来源，我们可能会尝试更大的东西(好吧，我试过了)。此外，我们可能会在某个时候增加 RSA 密钥的大小，这将自动转换为更长的密码长度。

##### 尊重随机的力量

在我们的方法中，如[清单 6-1](#list_6_1) 所示，我们实例化了一个大小为`maxPassPhraseBytes`的字节数组，并在`for`循环中用随机字符填充它。请注意随机字符的参数。我们希望我们的密码短语由 ASCII 范围 32 到 126 的可打印字符组成。

我们将迭代次数设置为 15 到 25 之间的一个随机数。

我们将用 0 到 256 之间的随机字节填充 salt 字节数组。我们的 salt 字节数组大小固定为八个字节。我们将`SALT_LENGTH`声明为常量(static final)。

我们基于密码的加密的所有这些构件将为每个 Oracle 会话生成，并传递回客户端。在传输之前，将使用 RSA 公钥对它们进行加密。客户端将使用私钥解密它们。然后，有了这些工件，客户机将创建一个相同的密码密钥，用于发送和接收加密数据。

#### 初始化静态类成员

我们将把两个静态类成员的初始化从它们之前在方法中的位置移到类体中。参见[清单 6-2](#list_6_2) 。我们统一了创建这些组件的过程，而不是两次单独调用`makeCryptUtilities()`方法(一次在客户端，另一次在服务器端)。我们将在定义时实例化`SecureRandom`，并且我们将在静态初始化块中实例化`cipherRSA`(根据需要，捕捉异常)。

***清单 6-2。**静态类成员*

`    private static SecureRandom random = new SecureRandom();
    private static Cipher cipherRSA;
    static {
        try {
            cipherRSA = Cipher.getInstance( "RSA" );
        } catch( Exception x ) {}
    }

    private static Cipher cipherDES;
    private static SecretKey sessionSecretDESKey = null;
    private static AlgorithmParameterSpec paramSpec;

    private static String sessionSecretDESAlgorithm = "PBEWithSHA1AndDESede";`

除了上一节描述的基于 DES 密码的加密密钥的构件之外，我们将声明密钥本身和我们将使用的 DES `Cipher`。我们还将为 DES 密钥构建和使用一个`AlgorithmParameterSpec`成员。

#### 评估 Java 1.5 基于密码的加密漏洞

我们可以选择使用什么算法来加密我们的秘密密码。美国(DES)不错，但三重 DES (3DES 或 DESede)更强，AES 更是如此；SHA1 是比 MD5 更好的加密散列。所以我们想使用完全由`PBEWithSHA1AndDESede`表示的基于密码的加密算法，我们指定它如[清单 6-2](#list_6_2) 所示。

但是等等，有个问题。在 Java Runtime Edition 版中，有一个 bug。这个链接有报道:`[http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6332761](http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6332761)`。

Oracle JVM 是基于 JRE 1.5 的，所以它显示了这个错误。当我们生成指定我们的首选算法的密钥时，密钥生成器将返回一个类型为`PBEWithMD5AndDES`的较弱的密钥。

#### 编码自动升级:协商算法

程序员的工作是调试问题，比如我们遇到的上一节中描述的 bug，并架设跨越障碍的桥梁。我们将有一个方法向我们展示实际使用中的算法；这将显示错误。此外，我们不会假设我们指定的就是我们得到的——我们会将实际的算法返回给客户端，并使用实际的算法构建密码密钥的副本。

这种方法的好处是，我们将协商一个通用算法，并继续指定一个更强的加密算法。继续指定更强的算法将使我们的代码倾向于在 Oracle JVM 中可用时使用更强的算法。

所以我们将指定`PBEWithSHA1AndDESede`，但此时我们将使用`PBEWithMD5AndDES`。当 Oracle 下一次升级 Oracle JVM 时，我们准备使用更强的算法。这两种算法都使用 CBC 作为它们的模式，所以它们对我们正在做的事情同样适用。

#### 生成密码密钥

现在我们已经拥有了秘密密码密钥的所有构件，让我们来构建密钥。在[清单 6-3](#list_6_3) 中，我们有一个创建密钥的方法`makeSessionSecretDESKey()`。该方法的第一步是检查是否已经生成了密钥(passphrase char array 是否为空)，如果还没有生成，我们调用前面描述的方法`makeSessionSecretDESPassPhrase()`来构建工件。

***清单 6-3。**生成密码密钥，`makeSessionSecretDESKey()`*

`    private static void makeSessionSecretDESKey() throws Exception {
        // DES Pass Phrase is generated on server and passed to client
        if( null == sessionSecretDESPassPhraseChars )
            makeSessionSecretDESPassPhrase();
        paramSpec = new PBEParameterSpec( salt, iterationCount );
        KeySpec keySpec = new PBEKeySpec( sessionSecretDESPassPhraseChars, salt,
                iterationCount );
        // Try with recommended algorithm
        sessionSecretDESKey = SecretKeyFactory.getInstance(
            sessionSecretDESAlgorithm ).generateSecret( keySpec );
        // See what algorithm used
        sessionSecretDESAlgorithm = sessionSecretDESKey.getAlgorithm();
        cipherDES = Cipher.getInstance( sessionSecretDESKey.getAlgorithm() );
    }`

使用我们的秘密密码密匙工件，我们首先实例化`paramSpec`，它是一个`static`类成员。我们在多个方法中使用了那个`paramSpec`成员，所以我们将它创建为一个静态类成员。它将在将来 Java 存储过程从同一个 Oracle 会话调用静态方法时可用。

我们还实例化了一个`KeySpec`类，它是方法的本地类，只在这里使用。`keySpec`成员被`SecretKeyFactory`用来生成`sessionSecretDESAlgorithm`成员中描述的算法类型的密钥。这种算法类型会受到 bug 的影响，所以我们实际上会得到一个 Oracle JVM 版本支持的算法类型的键。之后，我们通过调用`sessionSecretDESKey.getAlgorithm()`得到实际的算法。我们还获得了基于该算法的 DES `Cipher`的一个实例。

请记住，我们已经将 RSA 公钥从客户端传递给了 Oracle。现在，在 Oracle 数据库上，我们正在构建我们的秘密密码密钥，我们将使用客户机公钥对其工件进行加密，并将其传递回客户机。我们还会把实际的算法回传到客户端，所以我们在客户端建立一个通用的算法。

#### 用公开的 RSA 密钥加密

在上一章中，我们已经看到了这段代码。我们使用我们的服务器构建的 RSA 公钥副本来加密(Oracle 上的)明文数据。然而，以前这是一个公共方法，我们直接调用它来演示 RSA 公钥加密。现在我们使用它作为一个实用方法来加密我们的秘密密码密钥的工件，以发送到客户端，所以我们已经使它成为私有的。看看[清单 6-4](#list_6_4) 中的代码。

***清单 6-4。**用 RSA 公钥加密，`getRSACryptData()`*

`    private static final RAW getRSACryptData( String extRSAPubMod,
        String extRSAPubExp, **String clearText** ) throws Exception
    {
        byte[] clearBytes = clearText.getBytes();
        return getRSACryptData( extRSAPubMod, extRSAPubExp, clearBytes );
    }`
`    private static final RAW getRSACryptData( String extRSAPubMod,
        String extRSAPubExp, **byte[] clearBytes** ) throws Exception
    {
        if( ( null == extRSAPubKey ) ||
            ( !saveExtRSAPubMod.equals( extRSAPubMod ) ) )
            makeExtRSAPubKey( extRSAPubMod, extRSAPubExp );
        cipherRSA.init( Cipher.ENCRYPT_MODE, extRSAPubKey, random );
        return new RAW( cipherRSA.doFinal( clearBytes ) );
    }`

还要注意，我们现在有两个同名的方法:`getRSACryptData()`。然而，通过采用不同的参数，它们是不同的:一个采用`String`形式的明文；另一个是字节数组形式。据说这些方法有不同的签名。当我们有多个同名但不同签名的方法时，我们称这个方法为重载。

第一种方法获取明文`String`并创建一个字节数组。然后为了避免重复任何代码，第一个方法简单地调用第二个方法并返回第二个方法返回的内容:加密的文本。我们将多次调用这些方法来加密我们的秘密密码密钥的所有工件。

#### 向客户端返回秘密密码密钥工件

你会看到以下四种方法之间有如此多的相似之处，以至于我们将只描述每个方面一次。这四种方法返回密码短语、算法、salt 和迭代次数，当它们组合在一起时，可以用来生成 DES 加密密码密钥。

这些方法会从 Java 存储过程中调用，所以分别是`public`和`static`。注意，这些方法将 RSA 公钥工件作为参数，它们将使用这些参数来加密秘密密码密钥工件。这些方法将关键工件作为`RAW`数据类型返回，因此我们保持了 Oracle 数据库和客户机之间的数据保真度。让我们看看清单 6-5 中的第一个。它返回密码短语。

***清单 6-5。**加密口令，`getCryptSessionSecretDESPassPhrase()`*

`    public static final RAW getCryptSessionSecretDESPassPhrase(
        String extRSAPubMod, String extRSAPubExp )
    {
        RAW rtrnRAW =
            new RAW( "getCryptSessionSecretDESPassPhrase() failed".getBytes() );
        try {
            if( null == sessionSecretDESKey ) makeSessionSecretDESKey();
            byte[] sessionSecretDESPassPhraseBytes =
                charArrayToByteArray( sessionSecretDESPassPhraseChars );
            rtrnRAW = getRSACryptData( extRSAPubMod, extRSAPubExp,
                sessionSecretDESPassPhraseBytes );
        } catch( Exception x ) {
            **java.io.CharArrayWriter errorText =**
                **new java.io.CharArrayWriter( 32767 );**
            **x.printStackTrace( new java.io.PrintWriter( errorText ) );**
            **rtrnRAW = new RAW( errorText.toString().getBytes() );**
        }
        return rtrnRAW;`
`    }`

我们已经讨论了很多`Exception`处理。这个方法通常被称为当前四人组中的第一个，包括更多的错误报告。因为我们正在返回一个`RAW`，所以我们最多可以返回 32，767 字节的数据。在`catch`块中，我们在内存数组中实例化了一个大小为 32，767 个字符的`CharArrayWriter`。然后通过堆栈调用，我们实例化一个`PrintWriter`，它指向`CharArrayWriter`。然后我们将`Exception` *的*钉痕打印到那个`PrintWriter`上。结果，我们在一个 char 数组编写器`errorText`中得到堆栈跟踪。我们调用`errorText.toString().getBytes()`来获取堆栈跟踪的字节数组，然后从中实例化一个`RAW`，我们可以将它传递回客户端。

在客户端，如果我们在解密从返回的`RAW`中寻找的密码短语时遇到困难，我们可以将`RAW`读取为`String`，并查看`Exception`堆栈跟踪。在客户机/服务器环境中，当您希望看到服务器看到的错误，而不仅仅是客户机上的错误时，这是一种方便的故障排除实践。

[清单 6-6](#list_6_6) 展示了这一堆方法中的第二个。这个函数返回 Oracle 数据库中使用的实际算法的名称。在`try`块中，您将看到所有这些方法共有的一个特性。我们测试一下`sessionSecretDESKey`是否是`null`，如果是，我们调用`makeSessionSecretDESKey()`(前面描述过)来创建秘密的密码密钥。

***清单 6-6。**加密算法名称，`getCryptSessionSecretDESAlgorithm ()`*

`    public static final RAW getCryptSessionSecretDESAlgorithm(
        String extRSAPubMod, String extRSAPubExp )
    {
        RAW rtrnRAW =
            new RAW( "getCryptSessionSecretDESAlgorithm() failed"**.getBytes()** );
        try {
            **if( null == sessionSecretDESKey ) makeSessionSecretDESKey();**
            rtrnRAW = **getRSACryptData**( extRSAPubMod, extRSAPubExp,
                sessionSecretDESAlgorithm );
        } catch( Exception x ) {}
        return rtrnRAW;
    }`

在`try`块中的最后一个公共调用是对前面描述的`getRSACryptData()`方法的调用)来加密秘密密码密钥工件；在这种情况下，是算法名。这会生成一个包含加密工件的`RAW`数据类型，它将被返回给客户端。

请注意调用异常时返回的内容。我们仍然返回`rtrnRAW`，但是它的值是字符串`"getCryptSessionSecretDESAlgorithm() failed"`的字节。将此报告给客户有助于故障排除。另外，请注意我们是如何获得那个`String`的字节的——我们将引号之间的值视为已经是*一个* `String`对象，调用`getBytes()`方法。这是允许的吗？没错。

这组中的最后两个方法，如[清单 6-7](#list_6_7) 和[清单 6-8](#list_6_8) 所示，将 salt 和迭代计数作为加密的`RAW`数据类型返回。

***清单 6-7。**加密盐，`getCryptSessionSecretDESSalt ()`*

`    public static final RAW getCryptSessionSecretDESSalt( String extRSAPubMod,
        String extRSAPubExp )
    {
        RAW rtrnRAW = new RAW( "getCryptSessionSecretDESSalt() failed".getBytes() );
        try {
            if( null == sessionSecretDESKey ) makeSessionSecretDESKey();`
`            rtrnRAW = getRSACryptData( extRSAPubMod, extRSAPubExp, salt );
        } catch( Exception x ) {}
        return rtrnRAW;
    }`

***清单 6-8。**加密计数，`getCryptSessionSecretDESIterationCount ()`*

`    public static final RAW getCryptSessionSecretDESIterationCount(
        String extRSAPubMod, String extRSAPubExp )
    {
        RAW rtrnRAW =
            new RAW( "getCryptSessionSecretDESIterationCount() failed".getBytes() );
        try {
            if( null == sessionSecretDESKey ) makeSessionSecretDESKey();
            **byte[] sessionSecretDESIterationCountBytes =**
                **{ ( byte )iterationCount };**
            rtrnRAW = getRSACryptData( extRSAPubMod, extRSAPubExp,
                sessionSecretDESIterationCountBytes );
        } catch( Exception x ) {}
        return rtrnRAW;
    }`

返回加密迭代计数的最后一个方法创建了一个字节数组`byte`。数组中唯一的`byte`是迭代计数`int`，转换为`byte`。这样，我们可以调用相同的方法将迭代计数加密为一个字节数组。当我们在客户端解密时，我们将不得不逆转这个过程。

#### 使用我们的秘密密码加密数据

我们将在客户机和 Oracle 数据库上调用相同的方法，使用密码密钥加密数据。清单 6-9 中的语法现在应该很熟悉了。该方法获取一个`String`明文数据，并返回一个`RAW`加密数据。注意，使用`sessionSecretDESKey`初始化`Cipher`与我们使用 RSA 密钥的方式非常相似，除了我们还提供了`paramSpec`。

***清单 6-9。**用密码加密数据，`getCryptData()`*

`    public static final RAW getCryptData( String clearData ) {
        if( null == clearData ) return null;
        RAW rtrnRAW = new RAW( "getCryptData() failed".getBytes() );
        try {
            if( null == sessionSecretDESKey ) makeSessionSecretDESKey();
            **cipherDES.init( Cipher.ENCRYPT_MODE, sessionSecretDESKey, paramSpec );**
            rtrnRAW = new RAW( cipherDES.doFinal( clearData.getBytes() ) );
        } catch( Exception x ) {}
        return rtrnRAW;
    }`

像我们之前描述的加密和返回我们的秘密密码密钥工件的方法一样，这个方法测试`sessionSecretDESKey`是否已经被实例化，如果没有，尝试创建它。这在 Oracle 数据库上是一种很好的做法，但是在客户机上就太放肆了(在客户机上，我们不希望生成秘密的口令密钥。)开发人员必须理解，客户端必须首先从 Oracle 数据库获得密码密钥，然后才可以使用它来加密数据，以便插入或更新到 Oracle。如果开发人员没有遵循这个指导方针，不会有任何伤害，但是他们的代码将不会工作。

### Oracle 秘密密码加密结构

在上一章中，我们创建了一个 Oracle 函数和一个过程来演示我们的 RSA 公钥加密在客户机/服务器环境中的使用。现在，我们将创建一个包含多个函数和过程(包括 Java 存储过程)的 Oracle 包，来处理我们的秘密密码加密。

该包将被放置在应用程序安全模式中。作为`appsec`用户，首先使用以下命令将您的角色设置为非默认角色`appsec_role`:

`SET ROLE appsec_role;`

![images](images/square.jpg) **注意**你可以在名为 *Chapter6/AppSec.sql* 的文件中找到以下命令的脚本。

当您阅读本节时，您可以跟随参考的代码文件，并在上下文中查看本文中讨论的代码。此外，在阅读 Oracle 结构时，您可以执行代码来创建 Oracle 结构。我们将在本章末尾运行测试时使用这些结构。

#### 打包获取秘密密码工件和加密数据

Oracle 数据库中的包是一组可以配置为一组的函数和过程。访问包中的函数和过程的权限是通过授予包的可执行权限来授予的。到第 7 章时，我们将了解 Oracle 包的另一个好处:我们可以定义新的数据类型，并在 Oracle 包中使用它们。

Oracle 包有两部分，规范和主体。规范为每个过程或函数提供了签名，但是实际的代码只包含在主体中。包的这种两部分身份允许 PL/SQL 程序员共享功能(规范)而不共享代码(主体)。你这样做可能是为了职责分离、通过混淆实现安全性，或者仅仅是为了保护你的知识产权。c 程序员会认为这种方法类似于每个代码文件都有一个头文件。

#### 应用安全包规范

Oracle 包规范仅定义函数和过程，列出函数的预期参数和返回类型。[清单 6-10](#list_6_10) 显示了`app_sec_pkg`包规范。作为`appsec`用户执行此操作。

***清单 6-10。**密码加密包规范*

`CREATE OR REPLACE PACKAGE appsec.app_sec_pkg IS

    -- For [Chapter 6](#ch6) testing only - move to app in later versions of this package` `    PROCEDURE p_get_shared_passphrase(
        ext_modulus               VARCHAR2,
        ext_exponent              VARCHAR2,
        secret_pass_salt      OUT RAW,
        secret_pass_count     OUT RAW,
        secret_pass_algorithm OUT RAW,
        secret_pass           OUT RAW,
        m_err_no              OUT NUMBER,
        m_err_txt             OUT VARCHAR2 );

    -- For [Chapter 6](#ch6) testing only - remove in later versions of this package
    PROCEDURE p_get_des_crypt_test_data(
        ext_modulus               VARCHAR2,
        ext_exponent              VARCHAR2,
        secret_pass_salt      OUT RAW,
        secret_pass_count     OUT RAW,
        secret_pass_algorithm OUT RAW,
        secret_pass           OUT RAW,
        m_err_no              OUT NUMBER,
        m_err_txt             OUT VARCHAR2,
        test_data                 VARCHAR2,
        crypt_data            OUT RAW );

    FUNCTION f_get_crypt_secret_pass( ext_modulus VARCHAR2,
        ext_exponent VARCHAR2 ) RETURN RAW;

    FUNCTION f_get_crypt_secret_algorithm( ext_modulus VARCHAR2,
        ext_exponent VARCHAR2 ) RETURN RAW;

    FUNCTION f_get_crypt_secret_salt( ext_modulus VARCHAR2,
        ext_exponent VARCHAR2 ) RETURN RAW;

    FUNCTION f_get_crypt_secret_count( ext_modulus VARCHAR2,
        ext_exponent VARCHAR2 ) RETURN RAW;

    FUNCTION f_get_crypt_data( clear_text VARCHAR2 ) RETURN RAW;

    FUNCTION f_get_decrypt_data( crypt_data RAW ) RETURN VARCHAR2;

    -- For [Chapter 6](#ch6) testing only - remove in later versions of this package
    FUNCTION f_show_algorithm RETURN VARCHAR2;

END app_sec_pkg;
/`

参见封装规范后半部分的功能列表。我们有一个函数返回每个秘密密码密钥工件的加密数据:`f_get_crypt_secret_pass`、`f_get_crypt_secret_ algorithm`、`f_get_crypt_secret_ salt`和`f_get_crypt_secret_ count`。我们也有函数来加密明文并返回一个加密的`RAW`、`f_get_crypt_data`，以及解密一个`RAW`并返回明文、`f_get_decrypt_data`(我们还没有看到该过程的 Java 部分)。

在我们的函数上面，我们指定了两个过程:`p_get_shared_passphrase`和`p_get_des_crypt_test_data`。这些过程中的每一个都将客户机 RSA 公钥模数和指数作为输入参数，并将秘密密码密钥工件作为`OUT`参数返回。我们正在处理错误，就像我们在前一章中描述的那样，使用`OUT`参数作为错误号和错误文本。此外，`p_get_des_crypt_test_data`过程接受一个明文输入参数，并返回一个加密的`RAW`作为附加的`OUT`参数。

这两个过程仅用于本章中的测试，并将在以后的章节中从包中移除。最后一个功能`f_show_algorithm`，也仅用于本章中的测试，稍后将被删除。

#### 应用安全包主体:函数

我们的程序包规范中的函数和过程定义必须在我们的程序包主体中精确复制。主体不仅包含定义，还包含过程和函数的代码。此时您可以执行此程序包体；该包将在 Oracle 数据库中创建。

这里有一个来自清单主体的示例函数供我们考虑，在清单 6-11 中。我们将 RSA 公钥模数和指数传递给函数`f_get_crypt_secret_pass`。它将它们传递给名为`getCryptSessionSecretDESPassPhrase()`的 Java 方法(如上所述)。这个 Java 方法返回一个用 RSA 公钥加密的`RAW`，即秘密密码密匙 passphrase。该函数返回 Java 方法返回给它的原始值。

***清单 6-11。**返回密码短语的功能*

`    FUNCTION f_get_crypt_secret_pass( ext_modulus VARCHAR2,
                   ext_exponent VARCHAR2 )
    **RETURN RAW**
    AS LANGUAGE JAVA
    NAME 'orajavsec.OracleJavaSecure.getCryptSessionSecretDESPassPhrase( java.lang.String, java.lang.String ) **return oracle.sql.RAW';**`

采用相同的方法来获得秘密密码密钥的每个工件，并获得加密和解密的数据。我们还有一个函数，它没有输入参数，返回算法字符串作为一个`OUT`参数。那个函数`f_show_algorithm`，只是为了本章的测试。

#### 应用安全包主体:过程

包主体中的过程是我们主要工作的焦点。这些程序如[清单 6-12](#list_6_12) 和[清单 6-13](#list_6_13) 所示。请注意，这两个程序仅用于本章中的测试，在以后的章节中将被删除和替换。我们要看的第一个过程是`p_get_shared_passphrase`，它将一个秘密的密码密钥返回给客户机。如果这个键还不存在，当我们调用`f_get_crypt_secret_salt`时，它将被创建。请记住，我们的加密密钥是特定于 Oracle 会话的，因此我们需要保持会话打开，以便使用秘密密码密钥进行加密。

***清单 6-12。**获取共享密码密钥的程序，`p_get_shared_passphrase`*

`    PROCEDURE p_get_shared_passphrase(
        ext_modulus               VARCHAR2,
        ext_exponent              VARCHAR2,
        secret_pass_salt      OUT RAW,`
`        secret_pass_count     OUT RAW,
        secret_pass_algorithm OUT RAW,
        secret_pass           OUT RAW,
        m_err_no              OUT NUMBER,
        m_err_txt             OUT VARCHAR2 )
    IS BEGIN
        m_err_no := 0;
        secret_pass_salt := **f_get_crypt_secret_salt**( ext_modulus, ext_exponent );
        secret_pass_count := f_get_crypt_secret_count( ext_modulus, ext_exponent );
        secret_pass := f_get_crypt_secret_pass( ext_modulus, ext_exponent );
        secret_pass_algorithm :=
            f_get_crypt_secret_algorithm( ext_modulus, ext_exponent );
    EXCEPTION
        WHEN OTHERS THEN
            m_err_no := SQLCODE;
            m_err_txt := SQLERRM;
    END p_get_shared_passphrase;`

观察清单 6-12 中[的`p_get_shared_passphrase`Oracle 程序中的`IN`和`OUT`参数列表。我们提供 RSA 公钥的模数和指数，然后得到秘密密码密钥的伪像、错误号和文本。每个工件都是通过调用一个 Oracle 函数获得的，如下所示:](#list_6_12)

`secret_pass := f_get_crypt_secret_pass( ext_modulus, ext_exponent );`

像`f_get_crypt_secret_pass`一样，从`p_get_shared_passphrase`调用的每个函数都是 Java 存储过程。我们在清单 6-11 中看到了其中一个函数的代码。Java 存储过程的所有实质性工作都是在 Oracle 数据库上用我们的 Java 代码`OracleJavaSecure`完成的

我们在这里要看的第二个程序是`p_get_des_crypt_test_data`。除了`p_get_des_crypt_test_data`有两个额外的参数，一个`IN`和一个`OUT`之外，它与`p_get_shared_passphrase`非常相似，如[清单 6-13](#list_6_13) 所示。这些参数将用于向 Oracle 数据库提交明文，并以加密形式返回该文本—用秘密口令密钥加密。

***清单 6-13。**获取加密数据的程序，`p_get_des_crypt_test_data`*

`PROCEDURE p_get_des_crypt_test_data(
        ext_modulus               VARCHAR2,
        ext_exponent              VARCHAR2,
        secret_pass_salt      OUT RAW,
        secret_pass_count     OUT RAW,
        secret_pass_algorithm OUT RAW,
        secret_pass           OUT RAW,
        m_err_no              OUT NUMBER,
        m_err_txt             OUT VARCHAR2,
        **test_data                 VARCHAR2,**
        **crypt_data            OUT RAW )**
    IS BEGIN
        m_err_no := 0;
        secret_pass_salt := f_get_crypt_secret_salt( ext_modulus, ext_exponent );
        secret_pass_count := f_get_crypt_secret_count( ext_modulus, ext_exponent );
        secret_pass := f_get_crypt_secret_pass( ext_modulus, ext_exponent );
        secret_pass_algorithm :=` `            f_get_crypt_secret_algorithm( ext_modulus, ext_exponent );
        **crypt_data := f_get_crypt_data( test_data );**
    EXCEPTION
        WHEN OTHERS THEN
            m_err_no := SQLCODE;
            m_err_txt := SQLERRM;
    END p_get_des_crypt_test_data;`

我们将明文`test_data`从客户端发送到 Oracle，这个过程通过调用`f_get_crypt_data`函数在加密后返回`crypt_data`。该函数也是一个 Java 存储过程。

### 用于秘密密码解密的 Java 方法

一旦我们调用了`appsec`过程来将 DES 秘密密码密钥工件和加密数据返回给客户机，我们需要

1)用 RSA 私钥解密工件

2)生成 DES 加密口令密钥

3)用秘密口令密钥解密数据

作为一条规则，我试图限制我要求开发人员完成工作的步骤数量。当开发人员可以调用一个方法来完成其他调用时，为什么要让他们调用三个方法呢？应用程序开发人员的目标是解密数据，因此我们为他们提供了一种方法来完成这项工作。

![images](images/square.jpg) **注**你可以在文件*[chapter 6](#ch6)/orajavsec/Oracle javasecure . Java*中找到这段代码。

#### 使用密码密钥解密数据

在客户端应用程序调用了`p_get_des_crypt_test_data`过程之后，我们让他们调用[清单 6-14](#list_6_14) 中所示的方法`getDecryptData()`。

***清单 6-14。**建立秘密密码并解密数据，`getDecryptData()`*

`public static final String getDecryptData( RAW cryptData,
        RAW cryptSecretDESPassPhrase, RAW cryptSecretDESAlgorithm,
        RAW cryptSecretDESSalt, RAW cryptSecretDESIterationCount )
    {
        String rtrnString = "getDecryptData() A failed";
        try {
            if( ( null == sessionSecretDESKey ) || **testAsClientAndServer** ) {
                decryptSessionSecretDESPassPhrase( cryptSecretDESPassPhrase,
                    cryptSecretDESAlgorithm, cryptSecretDESSalt,
                    cryptSecretDESIterationCount );
                makeSessionSecretDESKey();
            }` `            rtrnString = **getDecryptData**( cryptData );
        } catch( Exception x ) {
            x.printStackTrace();
        }
        return rtrnString;
    }`

我们在`try`块中做的第一件事是测试`sessionSecretDESKey`是否已经被实例化。如果没有，那么我们调用两个方法:`decryptSessionSecretDESPassPhrase()`(在下一节讨论)和`makeSessionSecretDESKey()`。我们在本章前面讨论了`makeSessionSecretDESKey()`——它与我们最初在 Oracle 数据库上调用的构建密码密钥的方法相同。我们在客户端再次调用它来构建一个相同的密钥。

当我们测试我们是否已经有了`sessionSecretDESKey`，我们也测试了`boolean` `testAsClientAndServer`。除非我们从`main()`方法测试`OracleJavaSecure`类，否则`testAsClientAndServer boolean`总是`false`。在`main()`中，当我们将此`boolean`设置为`true`时，我们可以在测试的不同阶段用来自 Oracle 数据库的密钥替换本地生成的 DES 加密密码密钥。我们将在本章稍后检查`main()`方法的代码。

`getDecryptData()`方法重载了一个版本，该版本假设已经构建了秘密密码密钥并进行解密。它接受一个`RAW`并将明文作为一个`String`返回。第一个`getDecryptData()`方法(如上所示)调用第二个`getDecryptData()`方法，参见[清单 6-15](#list_6_15) 。

***清单 6-15。**用已有的密码解密数据，`getDecryptData()`*

`    public static final String getDecryptData( RAW cryptData ) {
        if( null == cryptData ) return null;
        String rtrnString = "getDecryptData() B failed";
        try {
            cipherDES.init( Cipher.DECRYPT_MODE, sessionSecretDESKey, paramSpec );
            rtrnString = new String( cipherDES.doFinal( cryptData.getBytes() ) );
        } catch( Exception x ) {
            //x.printStackTrace();
            //rtrnString = x.toString();
        }
        return rtrnString;
    }`

这个相同的第二个`getDecryptData()`方法也被调用来解密 Oracle 数据库上的数据，用于来自客户端的加密数据插入和更新。在 Oracle 数据库中，我们大概知道我们已经有了 DES 秘密密码密钥。

#### 使用 RSA 私钥解密 DES 密码

`decryptSessionSecretDESPassPhrase()`方法使用客户机的 RSA 私钥来解密服务器 DES 秘密密码密钥的所有工件。代码显示在[清单 6-16](#list_6_16) 中。

***清单 6-16。**解密秘密密码钥匙神器，`decryptSessionSecretDESPassPhrase()`*

`    private static void decryptSessionSecretDESPassPhrase(
        RAW cryptSecretDESPassPhrase, RAW cryptSecretDESAlgorithm,
        RAW cryptSecretDESSalt, RAW cryptSecretDESIterationCount )
        throws Exception`
`    {
        cipherRSA.init( Cipher.DECRYPT_MODE, locRSAPrivKey );
        **byte[] cryptBytes;**
        cryptBytes = cryptSecretDESPassPhrase**.getBytes();**
        sessionSecretDESPassPhraseChars =
            **byteArrayToCharArray**( cipherRSA.doFinal( cryptBytes ) );
        cryptBytes = cryptSecretDESAlgorithm.getBytes();
        sessionSecretDESAlgorithm = **new String**( cipherRSA.doFinal( cryptBytes ) );
        cryptBytes = cryptSecretDESSalt.getBytes();
        salt = cipherRSA.doFinal( cryptBytes );
        cryptBytes = cryptSecretDESIterationCount.getBytes();
        iterationCount = cipherRSA.doFinal( cryptBytes )**[0];**
        //System.out.println( "\n" + new String( sessionSecretDESPassPhraseChars ) );
        //System.out.println( sessionSecretDESAlgorithm );
        //System.out.println( new String( salt ) );
        //System.out.println( iterationCount );
    }`

对于每个工件，我们将加密的`RAW`转换成一个字节数组，并将其传递给`cipherRSA`成员进行解密。我们使用从`Cipher`返回的字节数组，用适当的数据类型填充静态类成员。通过调用`byteArrayToCharArray()`方法将值保存为`salt`的字节数组，通过实例化`new String()`将值保存为`sessionSecretDESPassPhraseChars`的字符数组，将值保存为`sessionSecretDESAlgorithm`的`String`，并将单个`byte`自动转换为`iterationCount`的`int`。

如果您有兴趣在这些特定于会话的随机工件和协商的算法到达客户端时观察它们，您可以在方法末尾取消对`System.out.println()`调用的注释。然而，您应该只是暂时这样做:在下一章的代码中已经删除了`System.out.println()`调用。

#### 数组转换的辅助方法

在前面代码的两个地方，我们调用了一些我们在`OracleJavaSecure`代码中定义的辅助数组转换方法，如[清单 6-17](#list_6_17) 所示。一个是字节数组，将其转换为字符数组。另一个则相反。我们在得到`sessionSecretDESPassPhraseChars`时从`decryptSessionSecretDESPassPhrase()`(见[清单 6-16](#list_6_16) 调用`byteArrayToCharArray()`，在加密`sessionSecretDESPassPhraseChars`时从`getCryptSessionSecretDESPassPhrase()`(见[清单 6-5](#list_6_5) )调用`charArrayToByteArray()`。

***清单 6-17。**数组转换方法，`byteArrayToCharArray()`和`charArrayToByteArray()`T5】*

`    static char[] byteArrayToCharArray( byte[] bytes ) {
        char[] rtrnArray = new char[bytes.length];
        for ( int i = 0; i < bytes.length; i++ ) {
            rtrnArray[i] = ( char )bytes[i];
        }
        return rtrnArray;
    }

    static byte[] charArrayToByteArray( char[] chars ) {
        byte[] rtrnArray = new byte[chars.length];`
`        for ( int i = 0; i < chars.length; i++ ) {
            rtrnArray[i] = ( byte )chars[i];
        }
        return rtrnArray;
    }`

我们通常可以通过强制转换来来回转换这些数组类型，如下例所示。然而，我们需要意识到缩小和扩大转换的含义。我们必须将数组中的`char`值限制为标准 ASCII 字符，而不是 16 位 Unicode 字符，以便在转换中不丢失信息。

`byte[] bAr = new byte[10];
char[] cAr = (char[])bAr;
bAr = (byte[])cAr;`

JDeveloper IDE(可能还有其他地方)不支持这种数组转换，所以我们将依赖于我们的辅助方法。JDeveloper 很好，因为它是免费的，而且它是为使用 Oracle 数据库而高度定制的；它比任何其他 IDE 更好地处理 Oracle 视图。您可以在 Oracle 公司网站上找到 JDeveloper，网址为`[www.oracle.com](http://www.oracle.com)`。

您可能想知道为什么我们将密码短语维护为一个 char 数组。这是我们构建`PBEKeySpec`时需要的格式。

#### 用于显示实际算法的方法

[清单 6-18](#list_6_18) 展示了`showAlgorithm()`方法。这实际上是重复的功能。看一下`decryptSessionSecretDESPassPhrase()`方法的代码(如前所示),您会看到我们将`sessionSecretDESAlgorithm`从 Oracle 数据库发送到客户端的`String`,我们可以简单地打印出来。

直接从 Oracle 数据库中选择(通过函数`f_show_algorithm`)的唯一额外保证是在传输过程中不会混淆。我们已经在`app_sec_pkg`中构建了调用该方法返回算法名称的函数。我们也可以从客户端调用这个方法(在调用服务器之前)并比较使用的算法。

***清单 6-18。**显示正在使用的密码算法名称，`showAlgorithm()`*

`    public static final String showAlgorithm() {
        String rtrnString = "showAlgorithm failed";
        try {
            rtrnString = sessionSecretDESKey.getAlgorithm();
        } catch( Exception x ) {
            rtrnString = x.toString();
        } finally {
            return rtrnString;
        }
    }`

这是一个临时的测试方法，我们将在后面的章节中从代码中删除它和调用它的 Oracle 函数。

### 仅在客户端测试 DES 加密

我们将再次通过从`OracleJavaSecure`的`main()`方法中调用我们的方法来进行我们的仅客户端测试。`main()`第一部分的代码如清单 6-19 中的[所示。从获取我们的客户机公钥模数和指数开始，在这个过程中生成 RSA 公钥/私钥对(如果不存在的话)。](#list_6_19)

***清单 6-19。**仅用于客户端测试的代码，来自`main()`*

`    String clientPubModulus = **getLocRSAPubMod();**
    String clientPubExponent = **getLocRSAPubExp();**

    // Emulates server actions
    RAW mCryptSessionSecretDESPassPhrase =
        getCryptSessionSecretDESPassPhrase( clientPubModulus,
        clientPubExponent );
    RAW mCryptSessionSecretDESSalt =
        getCryptSessionSecretDESSalt( clientPubModulus,
        clientPubExponent );
    RAW mCryptSessionSecretDESAlgorithm =
        getCryptSessionSecretDESAlgorithm( clientPubModulus,
        clientPubExponent );
    RAW mCryptSessionSecretDESIterationCount =
        getCryptSessionSecretDESIterationCount( clientPubModulus,
        clientPubExponent );
    RAW cryptData = **getCryptData**( "Monday" );

    **testAsClientAndServer = true;**

    // As client
    System.out.println( **getDecryptData**( cryptData,
        mCryptSessionSecretDESPassPhrase, mCryptSessionSecretDESAlgorithm,
        mCryptSessionSecretDESSalt, mCryptSessionSecretDESIterationCount ) );
    System.out.println( **showAlgorithm**() );`

接下来，我们模拟服务器，接收模数和指数，从`getCryptSessionSecretDESPassPhrase()`和其他方法获得 DES 秘密密码密钥工件。在该过程中，从工件构建公钥的副本，生成 DES 秘密密码密钥，并且使用 RSA 公钥加密每个秘密密码密钥工件。

我们还模拟服务器，用秘密密码密钥加密一些数据:

`RAW cryptData = getCryptData( "Monday" );`

我们测试的下一步假设我们回到了客户端，并且已经收到了所有加密的秘密密码密钥工件，我们从这些工件中生成了一个秘密密码密钥的副本。为此，我们将`testAsClientAndServer`设置为`true`,以覆盖我们刚刚在模拟服务器时创建的秘密密码密钥(即使密钥是相同的):

`testAsClientAndServer = true;`

现在再次作为客户端，我们用所有的 DES 秘密密码密钥工件和加密数据调用`getDecryptData()`。这将基于工件创建一个新的 DES 密钥，然后使用该密钥解密数据。我们将打印出解密的数据，这些数据应该与我们之前加密的数据相同。此外，我们将打印出用于加密密码的 DES 算法名称。

#### 运行代码

我们假设您按照上一章中的步骤运行了代码。本章将使用相同的程序。在命令提示符下，将目录切换到*第 6 章*。使用以下命令编译代码:

`javac orajavsec/OracleJavaSecure.java`

如果您有任何问题，请参考[第 3 章](03.html#ch3)中关于在命令提示符下编译和设置您的环境`CLASSPATH`以包含 *ojdbc6.jar* 的说明。然后使用以下命令运行同一目录中的代码:

`java orajavsec.OracleJavaSecure.OracleJavaSecure`

#### 观察结果

前面部分中发出的命令将会打印出以下两行:

`Monday
PBEWithSHA1AndDESede`

在模拟服务器时，我们使用 DES 加密密码密钥对字符串“Monday”进行了加密，并将加密的数据以及使用客户端 RSA 公钥加密的加密密码密钥工件传递回客户端。回到客户端，我们使用工件构建了一个复制的 DES 密钥，并解密了加密的数据。我们打印出解密后的数据，在命令提示符下看到了“星期一”。然后我们打印了协商好的算法。如果您在工作站上使用的是 JDK 1.6 或更高版本，您将会看到`PBEWithSHA1AndDESede`；但是，如果你使用的是 JDK 1.5，你会看到`PBEWithMD5AndDES`。

### 编码测试客户端/服务器秘密密码加密

下一行位于我们在 OracleJavaSecure.java 的 Java 代码的顶部。取消对它的注释，并将整个代码复制到您的 Oracle 客户端。

`CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED appsec."orajavsec/OracleJavaSecure" AS`

为了安全起见，向下滚动到类主体，确保在连接字符串中没有有效的密码。如果是这样，请在 Oracle 中执行该命令之前，从连接字符串中删除密码。

`    private static String appsecConnString =
        "jdbc:oracle:thin:AppSec/**password**@localhost:1521:Orcl";`

在您的 Oracle 客户端(如 SQL*Plus)中执行脚本，将 Java 代码加载到 Oracle 数据库中。正如我们所看到的，这个命令将 Java 代码加载到 Oracle 数据库中并进行编译。

#### 设置测试服务器和客户端的代码

为了在您的客户机上编译和执行`OracleJavaSecure`,我们取消注释以在 Oracle 数据库上运行的第一行需要被注释:

`//CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED appsec."orajavsec/OracleJavaSecure" AS`

向下滚动到类主体，并在连接字符串中设置密码。还要更正连接字符串的任何其他地址和名称。

`    private static String appsecConnString =
        "jdbc:oracle:thin:AppSec/**password**@localhost:1521:Orcl";`

还将`testingOnServer` `boolean`设置为`true`:

`    private static boolean testingOnServer = **true;**`

保存文件。

在本章的前面，您可能已经在 Oracle 上执行了`app_sec_pkg`包规范和主体。如果您还没有这样做，现在就做吧。这将创建我们需要做秘密密码加密的 Oracle 结构。

#### 考虑 main()方法的服务器部分

这次当我们运行`OracleJavaSecure`的`main()`方法时，我们将通过`testingOnServer`测试，因此我们将执行`main()`的剩余部分，如[清单 6-20](#list_6_20) 所示。我们声明了几个成员变量来保存从 Oracle、`errNo`和`errMsg`返回的错误号和错误消息。

因为我们是从客户端运行的(不是在 Oracle 数据库上)，所以我们需要加载特定于 Oracle 的驱动程序(假设我们可能没有使用 JDK 1.6 或更高版本)。我们将设置 Oracle 连接以供使用:注意，我们将作为`appsec`用户进行连接。

我们将使用特定于 Oracle 的`OracleCallableStatement`，它允许我们从 Oracle 检索`OUT`参数，并传输特定于 Oracle 的数据类型。

***清单 6-20。**客户端/服务器测试代码，来自`main()`*

`    if( testingOnServer ) {
        int **errNo;**
        String **errMsg;**
        // Since not on the Server, must load Oracle-specific Driver
        Class.forName( "oracle.jdbc.driver.OracleDriver" );
        // This will set the static member "conn" to a new Connection
        conn = DriverManager.**getConnection**( appsecConnString );
        **OracleCallableStatement stmt;**`

#### 从 Oracle 获取 DES 加密口令

在清单 6-21 的[中，我们的第一个过程调用是对`p_get_shared_passphrase`。这将简单地测试我们的客户机和 Oracle 之间的 RSA 和 DES 密钥的交换。我们将我们的 RSA 公钥模数和指数传递给这个过程，作为回报，我们得到了由 Oracle 数据库使用公钥加密的 DES 秘密密码密钥工件。注意，我们注册了`OUT`参数，并设置或`setNull`了我们所有的参数。](#list_6_21)

***清单 6-21。**从`main()`* 获取共享密码

`stmt = ( OracleCallableStatement )conn.prepareCall(
        "CALL app_sec_pkg**.p_get_shared_passphrase**(?,?,?,?,?,?,?,?)" );` `    stmt**.registerOutParameter**( 3, OracleTypes.RAW );
    stmt.registerOutParameter( 4, OracleTypes.RAW );
    stmt.registerOutParameter( 5, OracleTypes.RAW );
    stmt.registerOutParameter( 6, OracleTypes.RAW );
    stmt.registerOutParameter( 7, OracleTypes.NUMBER );
    stmt.registerOutParameter( 8, OracleTypes.VARCHAR );
    stmt.**set**String( 1, clientPubModulus );
    stmt.setString( 2, clientPubExponent );
    stmt.setNull(   3, OracleTypes.RAW );
    stmt.setNull(   4, OracleTypes.RAW );
    stmt.setNull(   5, OracleTypes.RAW );
    stmt.setNull(   6, OracleTypes.RAW );
    stmt.setInt(    7, 0 );
    stmt.setNull(   8, OracleTypes.VARCHAR );
    stmt.executeUpdate();

    errNo = stmt.getInt( 7 );
    **if( errNo != 0 )** {
        errMsg = stmt.getString( 8 );
        System.out.println( "Oracle error " + errNo +
            ", " + errMsg );
        System.out.println( (stmt.getRAW( 3 )).toString() );
    } else {
        **mCryptSessionSecretDESSalt = stmt.getRAW( 3 );**
        mCryptSessionSecretDESIterationCount = stmt.getRAW( 4 );
        mCryptSessionSecretDESAlgorithm = stmt.getRAW( 5 );
        mCryptSessionSecretDESPassPhrase = stmt.getRAW( 6 );
    }
    if( null != stmt ) **stmt.close**();`

在执行该语句后，我们得到从 Oracle 数据库返回的错误号，`errNo`,并确保它为 0。如果没有，我们报告错误。

如果没有错误，那么我们作为客户端应用程序，设置一个与每个加密工件相等的方法成员，比如`mCryptSessionSecretDESSalt`。现在，我们拥有了构建 Oracle 数据库上生成的密码密钥的精确副本所需的一切。至此，我们已经完全交换了钥匙；但是，我们还没有在客户机上建立 DES 加密口令密钥的副本。在这段代码的后面，我们将使用我们的私钥解密每个工件，然后构建秘密的密码密钥，并使用它与 Oracle 交换加密的数据。

因为我们已经完成了这个语句，所以我们关闭它。这是一个一致性和勤奋的问题，在我们结束声明之前，我们保证它不是`null`。实际上，如果`stmt`是`null`，我们会在第一个`registerOutParameter()`调用的早期代码中抛出一个异常。

#### 查看基于密码加密的协商算法

我们调用函数，`f_show_` algorithm 来显示 Oracle 数据库选择的算法名(参见清单 6-22[)。因为 Oracle 11g JVM 是基于标准 JVM 版本 1.5 的，所以我们将看到 Oracle 数据库在这方面表现出了前面提到的错误，并选择了`PBEWithMD5AndDES`作为协议，而不是我们所要求的`PBEWithSHA1AndDESede`。这将作为与客户端协商的通用算法。](#list_6_22)

***清单 6-22。**显示算法，来自`main()`*

`    stmt = ( OracleCallableStatement )conn.prepareCall(
        "{**?** = call app_sec_pkg.**f_show_algorithm**}" );
    stmt**.registerOutParameter( 1**, OracleTypes.VARCHAR );
    stmt.executeUpdate();
    **System.out.println( stmt.getString(1) );**
    if( null != stmt ) stmt.close();`

这里要注意的是调用 Oracle 函数的语法，而不是过程。该函数总是返回值。“领头的？= "代表返回值，我们的语句参数(1)就是那个值。准备好的可调用语句中的每个问号都是一个参数，无论它位于过程名或函数名之前还是之后。参数总是从左到右编号，1(一)是第一个。

此函数调用中使用的格式(带有左花括号和右花括号)称为 SQL92 语法。这是对 1992 年采用的 SQL 国际标准的引用。另一种可用于调用存储过程和函数的语法形式是 PL/SQL 块语法(带有`begin`和`end`语句)。我发现，对于 Oracle 驱动程序的旧版本(例如 jdbc14.jar )(虽然没有 SQL92 旧), PL/SQL 块语法可以工作，而 SQL92 语法则不行。以下是来自清单 6-22 中[的相同`prepareCall()`方法调用的 PL/SQL 块语法:](#list_6_22)

`    stmt = ( OracleCallableStatement )conn.prepareCall(
        "begin ? = call app_sec_pkg.f_show_algorithm; end;" );`

#### 调用 Oracle 数据库获取加密数据

接下来，我们要演示如何从 Oracle 数据库取回加密的数据，并在客户机上使用 DES 加密密码密钥的本地副本对其进行解密。在清单 6-23 的[中，你可以看到我们称这个过程为`p_get_des_crypt_test_data`。同样，我们传递我们的公钥工件，并检索加密的秘密密码密钥工件。因为这个过程是我们将在本书的剩余部分看到重复的，我将称之为“密钥交换”。我们刚刚从另一个检索秘密密码密钥工件的过程中返回，所以我们不需要再次设置我们的方法成员——这些行被注释掉了。请注意，所有这些调用都发生在同一个 Oracle 会话中，因此使用现有的密钥—没有额外的密钥生成。](#list_6_23)

***清单 6-23。**获取 DES 的地穴测试数据，来自`main()`*

`stmt = ( OracleCallableStatement )conn.prepareCall(
        "CALL app_sec_pkg**.p_get_des_crypt_test_data**(?,?,?,?,?,?,?,?,?,?)" );
    stmt.registerOutParameter( 3, OracleTypes.RAW );
    stmt.registerOutParameter( 4, OracleTypes.RAW );
    stmt.registerOutParameter( 5, OracleTypes.RAW );
    stmt.registerOutParameter( 6, OracleTypes.RAW );
    stmt.registerOutParameter( 7, OracleTypes.NUMBER );
    stmt.registerOutParameter( 8, OracleTypes.VARCHAR );
    stmt.registerOutParameter( 10, OracleTypes.RAW );
    stmt.setString( 1, clientPubModulus );
    stmt.setString( 2, clientPubExponent );
    stmt.setString( 9, **"Tuesday"** );
    stmt.setNull(   3, OracleTypes.RAW );
    stmt.setNull(   4, OracleTypes.RAW );
    stmt.setNull(   5, OracleTypes.RAW );
    stmt.setNull(   6, OracleTypes.RAW );` `    stmt.setInt(    7, 0 );
    stmt.setNull(   8, OracleTypes.VARCHAR );
    stmt.setNull(  10, OracleTypes.RAW );
    stmt.executeUpdate();
    errNo = stmt.getInt( 7 );
    if( errNo != 0 ) {
        errMsg = stmt.getString( 8 );
        System.out.println( "Oracle error " + errNo +
            ", " + errMsg );
        System.out.println( (stmt.getRAW( 10 )).toString() );
    } else {
        **//mCryptSessionSecretDESSalt** = stmt.getRAW( 3 );
        //mCryptSessionSecretDESIterationCount = stmt.getRAW( 4 );
        //mCryptSessionSecretDESAlgorithm = stmt.getRAW( 5 );
        //mCryptSessionSecretDESPassPhrase = stmt.getRAW( 6 );
        **cryptData = stmt.getRAW( 10 );**
        **System.out.println( getDecryptData( cryptData,**
            mCryptSessionSecretDESPassPhrase,
            mCryptSessionSecretDESAlgorithm, mCryptSessionSecretDESSalt,
            mCryptSessionSecretDESIterationCount ) );
    }
    if( null != stmt ) stmt.close();`

除了密钥交换，我们还将字符串“Tuesday”发送给`p_get_des_crypt_test_data`过程，以便在 Oracle 数据库上使用秘密密码密钥进行加密。因此，在执行了`Statement`之后，我们检索加密的数据，然后通过在客户端本地调用`getDecryptData()`来解密数据，并打印出解密后的`String`。注意，`getDecryptData()`方法获取所有加密的秘密密码密钥工件。

如果秘密密码密钥还没有建立，那么`getDecryptData()`调用`makeSessionSecretDESKey()`。当我们调用`getDecryptData()`时，我们传递足够的参数，即秘密密码密钥的工件，来构建密钥；但是，如果已经建成，我们就不重复这项工作。我们可能会多次调用`getDecryptData()`来获得多条加密数据，但是构建秘密密码密钥的工作将只进行一次。

#### 测试 Oracle 数据库加密和本地解密数据

清单 6-24 中的下一个测试更加简洁，尽管不太现实。我们将调用临时函数`f_get_crypt_data`来获取代表明文`String`“星期三”的加密数据。我们将从语句中取回加密的数据`RAW`，并在本地调用`getDecryptData()`方法来解密它，打印结果。

***清单 6-24。**获取地穴数据，来自`main()`*

`    stmt = ( OracleCallableStatement )conn.prepareCall(
        "{? = call app_sec_pkg**.f_get_crypt_data**(?) }" );
    stmt.registerOutParameter( 1, OracleTypes.RAW );
    stmt.setString( 2, **"Wednesday"** );
    stmt.executeUpdate();
    **cryptData = stmt.getRAW( 1 );**`
`    **System.out.println( getDecryptData( cryptData,**
        mCryptSessionSecretDESPassPhrase,
        mCryptSessionSecretDESAlgorithm, mCryptSessionSecretDESSalt,
        mCryptSessionSecretDESIterationCount ) );
    if( null != stmt ) stmt.close();`

通常我们不会调用 Oracle 数据库来加密来自客户端的明文数据，然后在客户端解密它以获得明文。然而，这正是我们在这里所做的。

#### 向 Oracle 发送加密数据

在清单 6-25 中的最后一个测试中，我们将在客户端加密明文数据“星期四”。我们用 DES 秘密密码密钥的副本加密它，基于我们从 Oracle 得到的工件。然后我们通过调用`f_get_decrypt_data`函数将加密的数据提交给 Oracle 数据库。Oracle 数据库将使用原始密码密钥解密数据，然后我们的客户机将读取作为参数 1 返回的明文`String`。我们打印结果并关闭`Statement`。

***清单 6-25。**获取解密数据，来自`main()`*

`    **cryptData = getCryptData( "Thursday" );**
    stmt = ( OracleCallableStatement )conn.prepareCall(
        "{? = call app_sec_pkg**.f_get_decrypt_data(?)** }" );
    stmt.registerOutParameter( 1, OracleTypes.VARCHAR );
    **stmt.setRAW( 2, cryptData );**
    stmt.executeUpdate();
    **System.out.println( stmt.getString( 1 ) );**
    if( null != stmt ) stmt.close();`

这是另一个不太可能的场景，我们调用一个 Oracle 函数来解密数据以便在客户机上使用。不要担心向客户端暴露不需要的功能；我们将继续解决这个问题。事实上，我们已经有了！我们的客户端应用程序不会作为`appsec`用户连接，只有`appsec`能够执行`app_sec_pkg`包中的过程和功能。

### 测试我们的安全客户端/服务器数据传输

在命令提示符下，将目录切换到*第 6 章*。使用以下命令编译代码:

`javac orajavsec/OracleJavaSecure.java`

同样，如果你有任何问题，参考[第 3 章](03.html#ch3)关于在命令提示符下编译和设置你的环境`CLASSPATH`包括 *ojdbc6.jar* 的指导。然后使用以下命令运行同一目录中的代码:

`java orajavsec.OracleJavaSecure`

结果将打印以下六行:

`Monday
PBEWithSHA1AndDESede
PBEWithMD5AndDES
Tuesday
Wednesday`
`Thursday`

前两行显示了我们在本章前面执行的相同的仅客户端测试。之后，因为`testingOnServer`是`true`,`main()`方法继续从 Oracle 获取 DES secret 密码密钥。然后我们调用`f_show_algorithm`并在命令提示符下显示协商好的算法，很可能是`PBEWithMD5AndDES`。

之后，我们通过`p_get_des_crypt_test_data`过程将字符串“星期二”发送到 Oracle 数据库进行加密。我们读取加密的数据，用秘密密码密钥的副本解密，并显示“星期二”。

我们也直接调用函数`f_get_crypt_data`，传递给它明文字符串“星期三”。我们读取函数返回的加密数据，用秘密密码密钥的副本再次解密，并显示“星期三”。到目前为止，很明显，我们的 Oracle 连接会话正在为多个查询保留和重用相同的 RSA 和 DES 密钥。

最后，我们在客户机上加密字符串“Thursday”，并将其提交给 Oracle 函数`f_get_decrypt_data`。Oracle 数据库使用原始密码密钥解密数据。我们读取返回的明文字符串并打印出来，“星期四。”

### 章节回顾

我们发现自己正处于另一章的末尾。回顾过去，让我们看看我们走过了哪些路。

*   我们学习了 DES 秘密密码加密。特别是，我们了解了组成秘密密码密钥的各种工件:通行短语、salt、迭代计数和算法。我们还设计了一种方法来观察、报告和解决 JCE 的一个 bug，甚至编码来适应最终的 JVM 升级，而不会有这个 bug。
*   我们发现了如何在 Oracle 上生成密码密钥，进行密钥交换，然后在客户机上构建一个相同的密钥。使用相同的密钥(共享密码)，我们可以交换加密数据。我们还看到了如何使用 RSA 公钥来加密 DES 密钥，这样我们就可以在 Oracle 数据库和客户机之间交换它，但仍然保持它的保密性。
*   我们广泛使用了`SecureRandom`类，以便为每个会话生成一个随机的密码短语、salt 和迭代计数。
*   我们研究了 Oracle 包，这是我们在组织和安全性方面所依赖的东西。

[图 6-1](#fig_6_1) 和 [6-2](#fig_6_2) 展示了我们在本章中介绍的秘密密码加密过程。这些过程将贯穿本书的其余部分。在[图 6-1](#fig_6_1) 的顶部，你会看到我们指的是[图 5-1](05.html#fig_5_1) 中的**【A】**——在那里我们看到了在客户端生成 RSA 公钥/私钥对的标准流程。当我们调用`p_get_shared_pass_phrase`时，我们将公钥指数和模数传递给 Oracle 数据库。您可以在图 6-1 中看到，在最右边，一个等价的公钥建立在 Oracle 数据库上，由标记为 RSA 的密钥图像表示。最右边的另一个密钥图像，标记为 DES，描述了我们在 Oracle 数据库上创建的共享密码密钥。

共享密码密钥的每个工件都在 Oracle 数据库上用公钥加密，并返回给客户机。每个加密的工件都放在`p_get_shared_pass_phrase`过程的一个`OUT`参数中。我们已经概述了整个过程，并在[图 6-1](#fig_6_1) 中将其标记为**【B】**区块。这是我们交换共享密码密钥的标准过程，我们将在以后的图中引用它。

在[图 6-1](#fig_6_1) 的底部，我们说明了客户端如何调用方法来解密秘密密码密钥工件并构建一个等价的秘密密码密钥。底部的密钥图像代表客户端上的密码密钥。

![images](images/0601.jpg)

***图 6-1。**密钥交换*

在[图 6-2](#fig_6_2) 中，您可以看到在客户端和 Oracle 数据库之间交换加密数据的示例流程图。在[图 6-2](#fig_6_2) 的前三分之一，您可以看到在 Oracle 数据库上进行密钥交换和数据加密的过程。加密的数据在`p_get_des_crypt_test_data`过程的`OUT`参数中返回给客户端。这里我们指的是[图 6-1](#fig_6_1) 的【T6【B】块，在这里我们看到了在 Oracle 数据库上构建并返回给客户端的密码密钥。在[图 6-2](#fig_6_2) 中，除了建立密码密钥，我们还使用该密钥对以加密形式返回给客户端的数据进行加密。

在图 6-2 的中间部分，通过调用`getDecryptData()`方法(两个同名方法的版本 **A** ，我们看到了客户端如何解密来自 Oracle 数据库的数据的图示。我们概述了图 6-2 的这一部分，并将其标记为块**【C】**——它说明了解密数据的标准过程。您可以看到，在解密过程中，在客户机上建立了一个等价的加密密码密钥，标记为 DES(根据需要)。

[图 6-2](#fig_6_2) 的最后一部分，在底部显示了这个过程的镜像。在这个例子中，客户机使用已经构建好的等价密码密钥来加密数据。然后通过调用`f_get_decrypt_data`函数将加密的数据发送到 Oracle 数据库。然后，Oracle 数据库使用原始密码密钥解密数据。在我们的示例代码中，解密后的明文数据被返回给客户端进行显示。

![images](images/0602.jpg)

***图 6-2。**加密数据交换示例*