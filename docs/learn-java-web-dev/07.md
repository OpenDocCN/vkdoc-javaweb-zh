第七章

使用 Grails 快速开发 Web

*不再活在碎片里，只有连接。*

埃德加·摩根·福斯特

Grails 将 web 开发带到了下一个抽象层次。Java EE 不是用应用程序级的抽象编写的，这一事实导致了 Spring、Hibernate 等 Java 框架的开发和随后的流行。但是大多数 Java 框架对 web 开发采取了一种分散的方法。您必须维护每一层的配置。Grails 支持配置之上的约定，并通过 Groovy 语言用一个抽象层包装这些强大的框架，从而提供一个完整的开发平台，允许您充分利用 Java 和 JVM。

本章将深入 Grails 机器的内部，查看它的各个部分:它的轮子和齿轮都在协调运动，它的可工作性，它的前沿引擎，以及它的底层形式。它将进一步研究 Grails 生态系统中的交互。它将展示控制器如何处理、管理、指导和编排应用程序的逻辑流，以及它们如何处理请求、重定向请求、执行和委托操作，或者根据需要呈现视图。它将探索视图并揭示 Grails 如何使用 SiteMesh(页面装饰框架)为页面提供一致的外观，以及视图如何利用 Grails 的内置标签和标签库中的动态标签来创建格式良好的标记并促进关注点的清晰分离。它是一台相当好的机器。

Grails 特性

Grails 是一个基于请求的、MVC、开源的 web 开发框架。不仅如此，它还是一个完整的开发平台，一切都运行在健壮的 Java 和 Java EE 平台之上，如图 7-1 所示。它利用了现有的流行 Java 框架，并且包含了利用 Groovy 语言动态性的 web 容器、数据库、构建系统和测试工具。

![9781430259831_Fig07-01.jpg](Images/9781430259831_Fig07-01.jpg)

[图 7-1](#_Fig1) 。Grails 平台

Grails 提供了最佳实践，例如约定优于配置，以及使用 Spring、Hibernate 和 SiteMesh 等框架进行单元测试。本节将重点介绍一些重要的最佳实践。

约定胜于配置

与配置相比，Grails 优先考虑约定。*约定优于配置* ，简单来说，就是只在背离约定的时候才写配置代码。这些巧妙的约定对应于目录结构；Grails 使用文件的名称和位置，而不是通过连接 XML 配置文件来依赖显式配置。这意味着如果你创建一个遵循 Grails 惯例的类，Grails 会把它连接到 Spring 中，或者把它当作一个 Hibernate 实体。如果创建一个名为 book 的新域类，Grails 会自动在数据库中创建一个名为 Book 的表。通过使用约定胜于配置的范例，Grails 可以根据组件的名称及其在目录结构中的位置来设想组件。除了加速应用程序开发之外，这样做的一个直接后果是，只有当配置偏离标准时，您才必须配置组件的特定方面。

脚手架

Grails 脚手架在运行时或开发时从域类生成应用程序的 CRUD 功能。生成的应用程序由与域类相关联的控制器和 GSP 视图组成。脚手架还生成数据库模式，包括每个域类的表。

对象关系映射

Grails 包括一个强大的对象关系映射(ORM) 框架，称为 Grails 对象关系映射(GORM)。像大多数 ORM 框架一样，GORM 将对象映射到关系数据库；但是与其他 ORM 框架不同，GORM 是基于动态语言的。因此，GORM 可以将 CRUD 方法直接注入到类中，而不必实现它们或从持久超类继承它们。

**注意** ORM 是一种将面向对象世界中的对象映射到关系数据库中的表的方法，它提供了 SQL 之上的抽象。

外挂程式

Grails 没有为每一个可能的需求提供现成的解决方案，而是提供了一个插件架构，您可以找到大量功能的插件。

单元测试

为了提高可交付成果的质量，Grails 为自动化 web 界面提供了单元测试、集成测试和功能测试。

集成开源

Grails 集成了行业标准和成熟的开源框架，本节将简要介绍其中的几个。

表 7-1 展示了 Grails 利用的框架。

[表 7-1](#_Tab1) 。Grails 利用的框架

<colgroup><col width="30%" class="calibre14"> <col width="70%" class="calibre14"></colgroup> 
| 

集成开源技术

 | 

描述

 |
| --- | --- |
| Ajax 框架 | Grails 附带了 jQuery 库，但也通过插件系统提供了对其他框架的支持，如 Prototype、Dojo、Yahoo UI 和 Google Web Toolkit。 |
| 冬眠 | Hibernate 是一个 ORM 框架，为 GORM 提供了基础。 |
| 氘 | Grails 使用内存中的 H2 [<sup class="calibre20">1</sup>](#Fn1) 数据库，并在开发模式下启用 H2 数据库控制台(在 URI /dbconsole)，以便可以从浏览器轻松查询内存中的数据库。 |
| 春天 | Spring Framework 在 Java EE API 之上提供了一个应用程序级的抽象。Grails 开发人员可以构建一个内部使用 Spring 和 Hibernate 的应用程序，而无需了解这些框架。Grails 从 Grails 开发人员那里抽象出了这些框架的大部分细节。 |
| SiteMesh | SiteMesh [<sup class="calibre20">2</sup>](#Fn2) 是一个布局呈现框架，它实现了 Decorator 设计模式来呈现带有页眉、页脚和导航元素的 HTML。Grails 从 Grails 开发人员那里抽象出了大多数 SiteMesh 细节。 |
| 雄猫 | 默认情况下，Grails 使用嵌入式 Tomcat 容器。 |

安装 Grails

在安装 Grails 之前，您至少需要一个 Java 开发工具包(JDK)版本 1.6 或更新版本。下载适用于您的操作系统的 JDK，运行安装程序，然后设置一个名为 JAVA_HOME 的环境变量，指向这个安装的位置。

**注意**在您的 Grails 开发环境中需要一个 JDK。一个 JRE 是不够的。

开始使用 Grails 的第一步是安装发行版。为此，请按照下列步骤操作:

1.  从[http://grails.org/](http://grails.org/)下载 Grails 的二进制发行版，并将生成的 ZIP 文件解压到您选择的位置。
2.  将 GRAILS_HOME 环境变量设置为解压缩 ZIP 文件的位置。
    *   在基于 Unix/Linux 的系统上，这通常是在您的概要文件中添加如下内容:export GRAILS _ HOME =/path/to/GRAILS。
    *   在 Windows 上，这通常是在我的电脑/高级/环境变量下设置一个环境变量的问题。
3.  然后将 bin 目录添加到 PATH 变量中。
    *   在基于 Unix/Linux 的系统上，这可以通过将 export PATH = " $ PATH:$ GRAILS _ HOME/bin "添加到您的概要文件中来完成。
        *   在 Windows 上，这是通过修改我的电脑/高级/环境变量下的 PATH 环境变量来完成的。

如果 Grails 工作正常，您现在应该能够在终端窗口中键入 grails -version，并看到类似如下的输出:

```
E:\>grails -version
Grails version: 2.2.4
```

Hello World 应用

在本节中，您将创建您的第一个 Grails web 应用程序。要创建一个 grails 应用程序，您需要熟悉 Grails 命令的用法:

```
grails [command name]
```

运行 create-app 创建应用程序。

```
grails create-app helloworld
```

这将在包含项目的当前目录中创建一个名为 helloworld 的新目录，换句话说，就是您的工作区。在控制台中导航到此目录:

```
cd helloworld
```

进入刚刚创建的 helloworld 目录，通过键入 grails 命令启动 Grails 交互式控制台。

```
\grails2-workspace\helloworld>grails
```

这会下载几个资源，然后你应该会看到一个提示，如图[图 7-2](#Fig2) 所示。

![9781430259831_Fig07-02.jpg](Images/9781430259831_Fig07-02.jpg)

[图 7-2](#_Fig2) 。Grails 交互控制台

我们想要的是一个简单的页面，它只是将消息“Hello World”打印到浏览器。在 Grails 中，每当您想要一个新页面时，您就为它创建一个新的控制器动作。由于我们还没有控制器，现在让我们用 create-controller 命令创建一个。

```
grails> create-controller hello
```

前面的命令将在 grails-app/controllers/hello world 目录下创建一个名为 HelloController.groovy 的新控制器，如清单 7-1 中的[所示。](#list1)

[清单 7-1](#_list1) 。HelloController.groovy

```
package helloworld

class HelloController {

    def index() { }
}
```

我们现在有了一个控制器，所以让我们添加一个动作来生成“Hello World”页面。代码看起来像[清单 7-2](#list2) 。

[清单 7-2](#_list2) 。修改索引操作

```
def index() { render "Hello World" } }
```

动作只是一个方法。在这种特殊情况下，它调用 Grails 提供的特殊方法来呈现页面。

要查看应用程序的运行情况，您需要使用另一个名为 run-app 的命令启动服务器。

```
grails> run-app
```

这将在端口 8080 上启动一个托管您的应用程序的嵌入式服务器。现在，您应该能够通过 URL[http://localhost:8080/hello world/](http://localhost:8080/helloworld/)访问您的应用程序。结果将看起来像[图 7-3](#Fig3) 。

![9781430259831_Fig07-03.jpg](Images/9781430259831_Fig07-03.jpg)

[图 7-3](#_Fig3) 。Grails 的欢迎屏幕

这是 Grails 简介页面，由 grails-app/view/index.gsp 文件呈现。它检测控制器的存在，并提供指向它们的链接。单击 HelloController 链接，查看包含文本“Hello World”的自定义页面您有了第一个工作的 Grails 应用程序。

**注意[图 7-3](#Fig3) 中的**有一个到 Dbdoc 控制器的链接。单击此链接将产生一条错误消息，因为控制器尚未实现。DbdocController 的目的是生成静态 HTML 文件来查看更改日志信息。您可以在 conf/Config.groovy 中通过设置 dbDocController.enabled = true 来启用它

书店应用

在本章中，您将学习如何利用 Grails 约定和搭建来创建一个简单但功能强大的书店应用程序版本。然而，这个应用程序的初始版本还不能用于生产；这个应用程序的目的是向你展示如何使用脚手架，你可以用除了你的域类代码之外几乎没有任何代码来呈现一个 CRUD web 应用程序。此外，Grails 将生成一个数据库模式，并在应用程序运行时用该模式填充数据库。

创建书店应用程序

要创建书店应用程序，您需要在命令行上使用可选的项目名称来执行 create-app 目标，如下所示:

```
>grails create-app bookstore
```

前面命令行中的整行都是命令，其中 create-app 是目标。目标是您希望 Grails 执行的特定任务。

**注意**使用 help 命令会产生一个可用目标列表:> grails 帮助。

如果您在使用 create-app 时没有提供项目名称，系统会提示您提供项目名称。

在 create-app 目标运行之后，您将拥有一个与项目名称相匹配的新目录。这是新项目的根目录，您必须从这个目录中进行所有后续的 Grails 命令行调用。现在使用 cd 命令进入目录是个好主意，这样你就不会忘记了。在新的项目目录中，您会发现一个与图 7-4 所示目录结构相匹配的结构。

![9781430259831_Fig07-04.jpg](Images/9781430259831_Fig07-04.jpg)

[图 7-4](#_Fig4) 。书店应用程序的目录结构

您可以使用自己选择的 IDE，而不是从命令行创建应用程序。我们推荐 Groovy/GrailsTool 套件(GGTS)，你可以从[www.springsource.org/downloads/sts-ggts](http://www.springsource.org/downloads/sts-ggts)下载。这本书用的是最新版本，GGTS 3.0。GGTS 为构建 Groovy 和 Grails 应用程序提供了最好的基于 Eclipse 的开发环境。GGTS 提供了对 Groovy 和 Grails 最新版本的支持，并基于最新的 Eclipse 版本。[图 7-5](#Fig5) 显示了如何在 GGTS 配置 Grails。在 Preferences 下，单击 Grails，然后单击 Add 按钮。在“配置 Grails 安装”窗口中，通过单击“浏览”按钮浏览 Grails，这将打开“Grails 安装目录”窗口。选择 Grails 安装目录，然后单击 OK。

![9781430259831_Fig07-05.jpg](Images/9781430259831_Fig07-05.jpg)

[图 7-5](#_Fig5) 。用 Grails 配置 GGTS

Grails 现在被添加到构建路径中，如图 7-6 所示。单击确定。现在 GGTS 已经配置了 Grails，您可以创建一个 Grails 项目了。

![9781430259831_Fig07-06.jpg](Images/9781430259831_Fig07-06.jpg)

[图 7-6](#_Fig6) 。构建路径中的 grails

在 GGTS 新建一个项目，使用菜单选项 File ![image](Images/arrow.jpg) New ![image](Images/arrow.jpg) Grails Project，如图[图 7-7](#Fig7) 所示。

![9781430259831_Fig07-07.jpg](Images/9781430259831_Fig07-07.jpg)

[图 7-7](#_Fig7) 。创建新项目

因为您已经从命令行创建了项目，所以您可以在 GGTS 中导入创建的项目。在导入窗口中选择已有的项目到工作区，如图[图 7-8](#Fig8) 所示。

![9781430259831_Fig07-08.jpg](Images/9781430259831_Fig07-08.jpg)

[图 7-8](#_Fig8) 。导入现有项目

单击下一步。选择项目的根目录，如图[图 7-9](#Fig9) 所示。

![9781430259831_Fig07-09.jpg](Images/9781430259831_Fig07-09.jpg)

[图 7-9](#_Fig9) 。选择一个目录来搜索现有的 Eclipse 项目

单击完成。[图 7-10](#Fig10) 展示了 GGTS 书店应用程序的目录结构。

![9781430259831_Fig07-10.jpg](Images/9781430259831_Fig07-10.jpg)

[图 7-10](#_Fig10) 。书店应用程序的目录结构

运行应用程序

此时，您已经有了一个可以通过 web 浏览器运行和访问的功能性应用程序。它还没有做很多事情，但是现在运行它将使您能够在添加域和控制器类时获得即时反馈。

要运行 Grails 应用程序，请从项目根目录执行 run-app 目标，如下所示:

```
> grails run-app
```

执行 run-app 目标的输出如下所示:

```
Server running. Browse to http://localhost:8080/bookstore
```

在 URL[http://localhost:8080/book store](http://localhost:8080/bookstore)访问应用程序，显示欢迎屏幕，如图[图 7-11](#Fig11) 所示。

![9781430259831_Fig07-11.jpg](Images/9781430259831_Fig07-11.jpg)

[图 7-11](#_Fig11) 。书店应用程序的欢迎屏幕

要在 GGTS 运行应用程序，请单击 Grails 命令历史，如图 7-12 中突出显示的[。在命令窗口中键入 **run-app** ，并按回车键。或者你也可以在 IDE 中右击项目，选择 Run As ![image](Images/arrow.jpg) Grails (run app)。](#Fig12)

![9781430259831_Fig07-12.jpg](Images/9781430259831_Fig07-12.jpg)

[图 7-12](#_Fig12) 。Grails 命令历史

创建控制器

控制器处理请求并创建或准备响应。控制器可以直接生成响应或委托给视图。要创建控制器类，请使用 Grails create-controller 目标。这将在 grails-app/controllers 目录中创建新的 Grails 控制器类，并在 test/unit 中为控制器类创建单元测试。如果 grails-app/views/ <controller name="">目录不存在，它还会创建一个目录。</controller>

要创建 BookController 类，需要使用可选的类名执行 create-controller 目标，如下所示:

```
>grails create-controller book
```

如果不提供类名，系统会提示您提供一个。执行 create-controller 目标的输出如下所示:

```
| Created file grails-app/controllers/bookstore/BookController.groovy
| Created file grails-app/views/book
| Created file test/unit/bookstore/BookControllerTests.groovy
```

注意，当运行带有可选类名的 create-controller 时，您可以让类名保持小写，Grails 会自动将其大写，这样它就遵循了标准的 Groovy 类命名约定。

要使用 GGTS 创建控制器，单击书店项目层次中的控制器，然后使用新的![image](Images/arrow.jpg)控制器。在 Grails 命令向导中键入 **Book** ，如图[图 7-13](#Fig13) 所示。

![9781430259831_Fig07-13.jpg](Images/9781430259831_Fig07-13.jpg)

[图 7-13](#_Fig13) 。使用 GGTS 创建控制器

单击完成。GGTS 将生成控制器并进行测试，如以下输出所示:

```
Loading Grails 2.2.4
| Environment set to development.....
| Created file grails-app/controllers/bookstore/BookController.groovy
| Created file grails-app/views/book
| Compiling 1 source files.....
| Created file test/unit/bookstore/BookControllerTests.groovy
```

[清单 7-3](#list3) 展示了生成的控制器。

[清单 7-3](#_list3) 。Grails 生成的 BookController

```
package bookstore

class BookController {

    def index() {
}
}
```

现在刷新浏览器，您可以在欢迎屏幕上看到该控制器，如图 7-14 所示。

![9781430259831_Fig07-14.jpg](Images/9781430259831_Fig07-14.jpg)

[图 7-14](#_Fig14) 。书店应用的欢迎屏幕

修改 index(){}的代码，如[清单 7-4](#list4) 所示。

[清单 7-4](#_list4) 。修改索引操作

```
    def index() {
render "book list"
}
```

现在你可以点击[图 7-14](#Fig14) 中的 BookController 链接，你将得到如图[图 7-15](#Fig15) 所示的简单文本响应。

![9781430259831_Fig07-15.jpg](Images/9781430259831_Fig07-15.jpg)

[图 7-15](#_Fig15) 。简单的文字回复

测试控制器

清单 7-5 展示了 Grails 生成的 BookControllerTests 测试。

[清单 7-5](#_list5) 。由 Grails 生成的 BookControllerTests

```
package bookstore

import grails.test.mixin.*
import org.junit.*

/**
 * See the API for {@link grails.test.mixin.web.ControllerUnitTestMixin} for usage instructions
 */
@TestFor(BookController)
class BookControllerTests {

void testSomething() {
       fail "Implement me"
}
}
```

修改 testSomething()，如[清单 7-6](#list6) 所示。

[清单 7-6](#_list6) 。添加断言

```
1.void testSomething() {
2.controller.index()
3.assert "book list" == response.text
4.}
```

现在通过 Run as ![image](Images/arrow.jpg) Grails 命令(test-app)运行测试，如图 7-16 中的[所示。](#Fig16)

![9781430259831_Fig07-16.jpg](Images/9781430259831_Fig07-16.jpg)

[图 7-16](#_Fig16) 。Grails 中的 test-app 命令

在运行 test-app 命令时，Grails 运行测试，如以下输出所示:

```
| Loading Grails 2.2.4
| Configuring classpath.
| Environment set to test.....
| Running 1 unit test... 1 of 1
| Completed 1 unit test, 0 failed in 3444ms
| Packaging Grails application.....
| Packaging Grails application.....
| Tests PASSED - view reports in E:\ModernJava\grails2-workspace\bookstore\target\test-reports
```

您可以从先前输出的最后一行所示的路径生成图 7-17 所示的报告。

![9781430259831_Fig07-17.jpg](Images/9781430259831_Fig07-17.jpg)

[图 7-17](#_Fig17) 。测试报告:通过测试

**注意**通过这种方式，您可以在 Grails 生成的 ControllerTests 中增加控制器的单元测试。

测试通过了，因为在[清单 7-6](#list6) 中，第 3 行的断言是正确的。现在替换[清单 7-6](#list6) 中的第 3 行，如下所示:

```
assert "xyz" == response.text
```

这是一个不正确的断言，因为在[图 7-15](#Fig15) 中显示的简单文本响应是“书单”而不是“xyz”所以这个测试应该会失败。要查看 Grails 如何报告失败的测试，通过用清单 7-7 中的[替换 testSomething()来使测试失败。](#list7)

[清单 7-7](#_list7) 。用不正确的断言替换测试

```
void testSomething() {
controller.index()
assert "xyz" == response.text
}
```

在运行 test-app 命令时，Grails 运行测试，如以下输出所示:

```
| Loading Grails 2.2.4
| Configuring classpath.
| Environment set to test.....
| Compiling 1 source files.
| Running 1 unit test... 1 of 1
| Failure:  testSomething(bookstore.BookControllerTests)
|  Assertion failed:

assert "xyz" == response.text
             |  |        |
             |  |        book list
             |  org.codehaus.groovy.grails.plugins.testing.GrailsMockHttpServletResponse@14cf61d
             false

at bookstore.BookControllerTests.testSomething(BookControllerTests.groovy:16)
| Completed 1 unit test, 1 failed in 3210ms
| Packaging Grails application.....
| Packaging Grails application.....
| Tests FAILED  - view reports in E:\ModernJava\grails2-workspace\bookstore\target\test-reports
```

您可以从先前输出的最后一行所示的路径生成图 7-18 所示的报告。

![9781430259831_Fig07-18.jpg](Images/9781430259831_Fig07-18.jpg)

[图 7-18](#_Fig18) 。测试报告:测试失败

创建域类

此时，我们创建的应用程序实际上并不做任何事情；它只是呈现一个简单的文本响应。我们将继续创建一个域类。要创建域类，请使用 Grails create-domain-class 目标。这将在 grails-app/domain 目录中创建一个新的 Grails 域类，并在 test/unit 中为该域类创建一个单元测试。

要创建 Book domain 类，您需要使用可选的类名执行 create-domain-class 目标，如下所示:

```
> grails createdomain-class book
```

如果不提供类名，系统会提示您提供一个。

请注意，当运行带有可选类名的 create-domain-class 目标时，您可以将类名保留为小写，Grails 会自动将其大写，以便它遵循标准的 Groovy 类命名约定。

要使用 GGTS 创建域类，在项目层次中点击“域”，然后使用新的![image](Images/arrow.jpg)域类，如图 7-19 中的[所示。](#Fig19)

![9781430259831_Fig07-19.jpg](Images/9781430259831_Fig07-19.jpg)

[图 7-19](#_Fig19) 。使用 GGTS 创建域类

当你点击[图 7-19](#Fig19) 中的域类时，会显示 Grails 命令向导窗口，如图[图 7-20](#Fig20) 所示。

![9781430259831_Fig07-20.jpg](Images/9781430259831_Fig07-20.jpg)

[图 7-20](#_Fig20) 。使用 GGTS 创建域类

在名称字段中输入域类的名称，然后单击完成。Grails 创建 Book domain 类和 BookTests，如以下输出所示:

```
Loading Grails 2.2.4
| Environment set to development.....
| Created file grails-app/domain/bookstore/Book.groovy
| Compiling 1 source files.....
| Created file test/unit/bookstore/BookTests.groovy
```

清单 7-8 展示了 Grails 生成的图书类。

[清单 7-8](#_list8) 。Grails 生成的图书领域类

```
package bookstore

class Book {

    static constraints = {
    }
}
```

清单 7-8 中的 Book 类为空。现在你可以完成这个域类，如[清单 7-9](#list9) 所示。

[清单 7-9](#_list9) 。图书领域类

```
1.package bookstore
2.
3.class Book {
4.String bookTitle
5.Long price
6.Long isbn
7.
8.static constraints = {
9.bookTitle(blank:false)
10.price(blank:false)
11.}
12.String toString() {
13.bookTitle
14.}
15.}
```

清单 7-9 中[的第 8 到 11 行的约束](#list9)为 Grails 提供了定义验证规则的声明性机制。[表 7-2](#Tab2) 展示了 Grails 可用的约束。

[表 7-2](#_Tab2) 。Grails 可用的约束

<colgroup><col width="15%" class="calibre14"> <col width="85%" class="calibre14"></colgroup> 
| 

限制

 | 

描述

 |
| --- | --- |
| 空白的 | 验证字符串值不为空 |
| 信用卡呢 | 验证字符串值是有效的信用卡号 |
| 电子邮件 | 验证字符串值是有效的电子邮件地址 |
| 在列表中 | 验证值是否在受约束值的范围或集合内 |
| 比赛 | 验证字符串值是否与给定的正则表达式匹配 |
| 最大 | 验证值不超过给定的最大值 |
| maxSize(最大值) | 验证值的大小没有超过给定的最大值 |
| 部 | 验证值不低于给定的最小值 |
| 最小尺寸 | 验证值的大小不低于给定的最小值 |
| 不等 | 验证属性不等于指定的值 |
| 可空的 | 允许将属性设置为 null 默认为假 |
| 范围 | 使用 Groovy 范围来确保属性值出现在指定的范围内 |
| 规模 | 设置浮点数所需的小数位数(即小数点右边的位数) |
| 大小 | 使用 Groovy 范围来限制集合或数字的大小或字符串的长度 |
| 独一无二的 | 将属性约束为数据库级别的唯一属性 |
| 全球资源定位器(Uniform Resource Locator) | 验证字符串值是有效的 URL |
| 验证器 | 向字段添加自定义验证 |

脚手架

Scaffolding 允许您为给定的域类自动生成整个应用程序，包括 CRUD 操作的视图和控制器动作。脚手架可以是静态的也可以是动态的；这两种类型生成相同的代码。主要区别在于，在静态搭建中，生成的代码在编译之前就可供用户使用，因此如果需要的话可以很容易地修改。然而，在动态搭建中，代码是在运行时在内存中生成的，对用户是不可见的。在接下来的部分中，您将学习动态和静态搭建。

动态脚手架

如前所述，动态脚手架在运行时为 CRUD 应用程序生成控制器动作和视图。要动态搭建一个域类，您需要一个控制器。您在清单 7-3 的[中创建了一个控制器(BookController)。要使用动态脚手架，将索引动作更改为脚手架属性，并为其分配域类，如清单 7-10](#list3) 中的[所示。这导致为指定的域类生成列表页面、创建页面、编辑页面、显示页面视图以及删除功能。](#list10)

[清单 7-10](#_list10) 。启用动态脚手架的记账员T3】

```
package bookstore

class BookController {

    static scaffold = Book
}
```

在将 BookController 更改为类似于清单 7-10 中的[之后，执行 run-app 目标。](#list10)

执行 run-app 目标的输出如下所示:

```
| Loading Grails 2.2.4
| Configuring classpath.
| Environment set to development.....
| Packaging Grails application.....
| Running Grails application
| Server running. Browse tohttp://localhost:8080/bookstore
```

单击欢迎页面上的 BookController 链接。

点击 BookController 链接，进入[图 7-21](#Fig21) 所示的图书列表视图。

![9781430259831_Fig07-21.jpg](Images/9781430259831_Fig07-21.jpg)

[图 7-21](#_Fig21) 。书单查看

您可以通过点按“新书”来创建或添加新书。[图 7-22](#Fig22) 显示了创建新书的屏幕。[图 7-22](#Fig22) 也显示了验证 的运行，你不必为其编写任何代码。这个验证的代码包含在域类手册中，如清单 7-9 第 8 到 11 行的[所示。](#list9)

![9781430259831_Fig07-22.jpg](Images/9781430259831_Fig07-22.jpg)

[图 7-22](#_Fig22) 。创建视图并进行验证

[图 7-23](#Fig23) 显示了通过完成所有验证来创建一本新书。

![9781430259831_Fig07-23.jpg](Images/9781430259831_Fig07-23.jpg)

[图 7-23](#_Fig23) 。创建视图

[图 7-24](#Fig24) 显示了新创建的图书。T3】

![9781430259831_Fig07-24.jpg](Images/9781430259831_Fig07-24.jpg)

[图 7-24](#_Fig24) 。显示视图

您可以编辑、删除或添加新创建的图书。您可以通过点按“更新”来编辑创建的图书。[图 7-25](#Fig25) 说明了编辑视图。T3】

![9781430259831_Fig07-25.jpg](Images/9781430259831_Fig07-25.jpg)

[图 7-25](#_Fig25) 。编辑视图

[图 7-26](#Fig26) 说明了更新后的图书。

![9781430259831_Fig07-26.jpg](Images/9781430259831_Fig07-26.jpg)

[图 7-26](#_Fig26) 。显示带有更新消息的视图

您可以通过点按“新书”来添加新书。[图 7-27](#Fig27) 显示了以这种方式添加的图书列表。

![9781430259831_Fig07-27.jpg](Images/9781430259831_Fig07-27.jpg)

[图 7-27](#_Fig27) 。带有已添加图书列表的列表视图

静态脚手架

Static scaffolding 提供了一个优秀的学习工具，帮助您熟悉 Grails 框架以及一切是如何组合在一起的。现在，是时候将静态脚手架作为一种学习工具来使用了。动态和静态搭建的域类没有区别。为了快速参考，Book 类如[清单 7-11](#list11) 所示。

[清单 7-11](#_list11) 。图书领域类

```
package bookstore

class Book {
String bookTitle
Long price
Long isbn

static constraints = {
bookTitle(blank:false)
price(blank:false)
}
String toString() {
bookTitle
}
}
```

静态搭建与动态搭建的不同之处在于视图和控制器的生成方式。在这两种情况下，域类保持不变。然而，在动态搭建中，您需要控制器向 Grails 表明您需要动态搭建来为您生成应用程序。如果你想让 Grails 通过静态搭建生成应用程序，你必须使用清单 7-12 中的命令。

[清单 7-12](#_list12) 。通过静态搭建生成应用程序的命令

```
>grails generate-all bookstore.Book
```

从命令行或 GGTS 运行该命令后，Grails 会生成如下所示的应用程序:

```
Loading Grails 2.2.4
| Configuring classpath.
| Environment set to development.....
| Packaging Grails application.....
| Packaging Grails application.....
| Generating views for domain class bookstore.Book
| Generating controller for domain class bookstore.Book
| Finished generation for domain class bookstore.Book
```

如果我们现在运行应用程序，我们将拥有一个完整的 CRUD 应用程序。这个 generate-all 命令为我们的域类 Book 生成一个控制器(BookController)和四个视图，并为我们的控制器 BookControllerTest 生成一个单元测试。这些文件为我们提供了一个完整的 CRUD 应用程序，充当了我们可以添加定制代码的存根。让我们仔细看看我们生成的代码。我们从图 7-28 中的[所示的图书控制器开始。](#Fig28)

![9781430259831_Fig07-28.jpg](Images/9781430259831_Fig07-28.jpg)

图 7-28 。BookController(帐簿控制器)

在图 7-28 所示的 BookController 代码中，你会注意到的第一件事是 Grails 控制器是一个普通的 Groovy 类，它不扩展任何类，也不实现任何接口。接下来您会注意到 BookController 有八个动作。

*   创建行动
*   删除操作
*   编辑操作
*   索引操作
*   列表操作
*   保存操作
*   显示动作
*   更新操作

这些动作是控制器的闭包属性。控制器中的所有工作都在动作中完成。控制器中声明的每个闭包都是一个动作，可以通过 URL 访问，默认情况下，URL 映射到控制器动作。URL 的第一部分代表控制器名称，第二部分代表操作名称。在接下来的几节中，您将更深入地了解这些操作，但在此之前，有必要了解如何退出控制器操作。正确退出控制器动作有三个选项。

*   调用 render()方法
*   调用 redirect()方法
*   返回模型或空值

在接下来的章节中，在探究图 7-28 中的[所示的 BookController 中的每个动作之前，您将查看这三个选项。](#Fig28)

调用 render()方法

退出控制器动作的第一个选项是调用 render()方法来呈现视图或文本响应。为了理解 render()方法是如何工作的，[清单 7-13](#list13) 展示了一个简单的 Grails 控制器，当它被调用时，会向您问候。

[清单 7-13](#_list13) 。呈现文本响应

```
package chapter5
class HelloController {
def index() {
render 'hello'
}
defshow(){}
def someOtherAction(){}
}
```

如[清单 7-13](#list13) 所示，控制器在被/hello/index 请求调用时，将执行控制器中定义的 index()动作，index()动作将使用 render()方法呈现文本响应。在 HelloController 中调用 index()动作的完整 URL 是[http://localhost:8080/chapter 5/hello/index](http://localhost:8080/chapter5/hello/index)。如清单所示，控制器中可以有任意数量的动作。

如果您在 render()方法中指定视图名称，如清单 7-14 中的[所示，Grails 会假设您指的是位于 Grails-app/views/hello/hello . gsp 位置的视图，并呈现一个名为 hello](#list14) 的视图。

[清单 7-14](#_list14) 。渲染视图

```
class HelloController {
...
def show() {
render view: "hello"
}
...
}
```

调用 redirect()方法

退出控制器操作的第二个选项是调用 redirect()方法来发出一个到另一个 URL 的 HTTP 重定向。Grails 为所有控制器提供了一个接受 Map 作为参数的 redirect()方法。该映射应该包含 Grails 执行重定向所需的所有信息，包括重定向到的动作的名称。

此外，映射可以包含要重定向到的控制器的名称。清单 7-15 显示了在同一个控制器中从第一个动作到第二个动作的标准重定向。

[清单 7-15](#_list15) 。重定向到同一控制器中的动作

```
class HelloController {
def first() {
redirect action: "second"
}
def second() {
...
}
}
```

如果重定向是针对另一个控制器中的操作，则必须指定另一个控制器的名称。清单 7-16 展示了如何重定向到另一个控制器中的动作。

[清单 7-16](#_list16) 。重定向到另一个控制器中的操作

```
class HelloController {
def first() {
redirect action: "second", controller: "other"
}
}
```

在[清单 7-16](#list16) 中，HelloController 中的第一个()动作重定向到另一个控制器中的第二个()动作。

返回模型

退出控制器动作的第三个选项是返回一个模型，它是一个包含数据的地图，如清单 7-17 中的[所示。](#list17)

[清单 7-17](#_list17) 。归还模型

```
class HelloController {
def show() {
    [user: User.get(params.id)]
}
}
```

Grails 将尝试呈现与动作同名的视图。它将在以控制器的基本名称命名的目录中查找这个视图。在[清单 7-17](#list17) 中，从 HelloController 的 show()操作返回将导致 Grails 呈现 view /views/hello/show.gsp。

现在你知道如何调用控制器的动作，以及如何退出。有了这些知识，看一看[图 7-28](#Fig28) ，让我们开始逐一研究每个动作。首先让我们把 allowedMethods 属性去掉。

```
static allowedMethods = [save: "POST", update: "POST", delete: "POST"]
```

allowedMethods 属性提供了一个简单的声明性语法来指定控制器操作允许哪些 HTTP 方法。默认情况下，所有控制器操作都允许所有请求方法。allowedMethods 属性是可选的，只有当控制器的操作需要限制为某些请求方法时，才需要定义该属性。BookController 中的这个属性指定只有 save、update 和 delete 可以是 POST 方法。

索引操作

index()动作是导航到 BookController 时调用的默认动作。默认情况下，这个动作只是使用之前解释的 redirect()方法重定向到 list()动作，如[清单 7-18](#list18) 所示。

[清单 7-18](#_list18) 。图书管理员的索引操作

```
def index() {
        redirect(action: "list", params: params)
    }
```

redirect()方法将 HTTP 重定向到由这些参数构造的 URL。如果未指定操作，将使用 index()操作。params 保存请求参数，如果有的话。

列表操作

[清单 7-19](#list19) 展示了 BookController 的 list()动作。

[清单 7-19](#_list19) 。BookController 的列表操作

```
def list(Integer max) {
        params.max = Math.min(max ?: 10, 100)
        [bookInstanceList: Book.list(params), bookInstanceTotal: Book.count()]
    }
```

列表闭包的第一行使用 params 属性，这是一个包含传入请求的所有参数的映射。

最后一行返回一个包含两个元素的映射:bookInstanceList 和 bookInstanceTotal。bookInstanceList 是通过对 Book.list()的调用加载的。向 list()传递参数映射，它将从该映射中提取任何可以使用的参数。bookInstanceTotal 是用 Book.count()加载的。bookInstanceTotal 的使用将在后面的“列表视图”部分提到。list()操作使用从该操作返回的地图中的数据呈现列表视图。

创建行动

清单 7-20 展示了 BookController 的 create()动作。

[清单 7-20](#_list20) 。BookController 的创建操作

```
def create() {
        [bookInstance: new Book(params)]
    }
```

create()动作创建一个新的 Book 实例，然后将参数分配给 Book instance 的属性，因为稍后会用到它，如下面在[清单 7-21](#list21) 中讨论的“保存动作”部分所述。然后它用 bookInstance 的键在 Map 中返回该实例。最后，它呈现 create 视图。

保存操作

清单 7-21 展示了 BookController 的 save()动作。

[清单 7-21](#_list21) 。BookController 的保存操作

```
def save() {
        def bookInstance = new Book(params)
        if (!bookInstance.save(flush: true)) {
            render(view: "create", model: [bookInstance: bookInstance])
            return
        }

        flash.message = message(code: 'default.created.message', args: [message(code: 'book.label', default: 'Book'), bookInstance.id])
        redirect(action: "show", id: bookInstance.id)
    }
```

如果有错误，用户将被重定向到 create()操作。对于这个重定向到 create()动作的操作，params 被分配给 bookInstance 的属性，正如前面在[清单 7-20](#list20) 中的 create()动作所提到的。如果没有错误，将使用新创建的实例呈现 show 视图。

显示动作

清单 7-22 展示了 BookController 的 show()动作。

[清单 7-22](#_list22) 。BookController 的显示操作

```
def show(Long id) {
        def bookInstance = Book.get(id)
        if (!bookInstance) {
            flash.message = message(code: 'default.not.found.message', args: [message(code: 'book.label', default: 'Book'), id])
            redirect(action: "list")
            return
        }

        [bookInstance: bookInstance]
    }
```

show()操作需要一个 id 参数。show()操作的第一行调用 Book.get()方法来检索 id 参数所引用的图书。如果不存在带有传入 id 的 Book 实例，则在 flash 范围内会存储一条错误消息，用户会被重定向到列表视图。

如果找到一个带有传入 id 的 Book 实例，它将在一个 Map 中返回，键为 Book instance，show()操作将呈现 show 视图。

编辑操作

清单 7-23 展示了 BookController 的 edit()动作。

[清单 7-23](#_list23) 。BookController 的编辑操作

```
def edit(Long id) {
        def bookInstance = Book.get(id)
        if (!bookInstance) {
            flash.message = message(code: 'default.not.found.message', args: [message(code: 'book.label', default: 'Book'), id])
            redirect(action: "list")
            return
        }

        [bookInstance: bookInstance]
    }
```

edit()动作加载将在编辑过程中使用的必要数据，并将其传递给 edit 视图。edit()操作与 show()操作非常相似。edit()动作的名称 edit 用于呈现编辑视图。

更新操作

当提交来自编辑视图的更改时，将调用 update()操作。清单 7-24 展示了 BookController 的 update()动作。

[清单 7-24](#_list24) 。BookController 的更新操作

```
def update(Long id, Long version) {
        def bookInstance = Book.get(id)
        if (!bookInstance) {
            flash.message = message(code: 'default.not.found.message', args: [message(code: 'book.label', default: 'Book'), id])
            redirect(action: "list")
            return
        }

        if (version != null) {
            if (bookInstance.version > version) {
                bookInstance.errors.rejectValue("version", "default.optimistic.locking.failure",
                          [message(code: 'book.label', default: 'Book')] as Object[],
                          "Another user has updated this Book while you were editing")
                render(view: "edit", model: [bookInstance: bookInstance])
                return
            }
        }

        bookInstance.properties = params

        if (!bookInstance.save(flush: true)) {
            render(view: "edit", model: [bookInstance: bookInstance])
            return
        }

        flash.message = message(code: 'default.updated.message', args: [message(code: 'book.label', default: 'Book'), bookInstance.id])
        redirect(action: "show", id: bookInstance.id)
    }
```

update()操作试图用 id 参数检索一个 Book 实例。id 是从编辑视图中提供的。如果找到实例，将执行开放式并发检查。如果没有错误，edit 视图中的所有值都被分配给 Book 实例的适当属性，包括任何必要的数据转换。

```
bookInstance.properties = params
```

如果这两个步骤都成功，flash 中会存储一条“成功”消息，用户会被定向到 show 视图。如果任一步骤失败，flash 中会存储一条“失败”消息，用户将返回到编辑视图。

删除操作

默认情况下，delete()操作在编辑和显示视图中可用。清单 7-25 展示了 BookController 的 delete()动作。

[清单 7-25](#_list25) 。BookController 的删除操作

```
def delete(Long id) {
     def bookInstance = Book.get(id)
     if (!bookInstance) {
         flash.message = message(code: 'default.not.found.message', args: [message(code: 'book.label', default: 'Book'), id])
         redirect(action: "list")
         return
     }

     try {
         bookInstance.delete(flush: true)
         flash.message = message(code: 'default.deleted.message', args: [message(code: 'book.label', default: 'Book'), id])
         redirect(action: "list")
     }
     catch (DataIntegrityViolationException e) {
         flash.message = message(code: 'default.not.deleted.message', args: [message(code: 'book.label', default: 'Book'), id])
         redirect(action: "show", id: id)
     }
}
```

delete()操作试图检索一个 Book 实例，如果找不到，就重定向到列表视图。如果找到一个实例，则进入 try/catch 块，尝试删除该实例。如果删除成功，消息将存储在闪存中，并重定向到列表视图。如果出现异常，不同的消息将存储在 flash 中，并重定向到 show 视图。

现在，您已经看到了 BookController 中为 Book 类生成的所有操作，让我们检查一下由静态搭建为 Book 类生成的视图。

Grails 视图

Grails 使用 Groovy 服务器页面(GSP) 作为其视图层。Grails 还使用页面装饰框架 SiteMesh 来帮助页面布局。SiteMesh 合并每个。gsp 文件合并到一个名为 main.gsp 的文件中，以使所有页面具有一致的外观。您将从 main.gsp 开始生成视图，它可以在\views\layouts 中找到，然后是为 Book 类生成的四个视图:list.gsp、show.gsp、create.gsp 和 edit . gsp。[清单 7-26](#list26) 展示了 main.gsp

[清单 7-26](#_list26) 。main .普惠制

```
1.<!DOCTYPE html>
2.<!--[if lt IE 7 ]><html lang="en" class="no-js ie6"><![endif]-->
3.<!--[if IE 7 ]><html lang="en" class="no-js ie7"><![endif]-->
4.<!--[if IE 8 ]><html lang="en" class="no-js ie8"><![endif]-->
5.<!--[if IE 9 ]><html lang="en" class="no-js ie9"><![endif]-->
6.<!--[if (gt IE 9)|!(IE)]><!--><html lang="en" class="no-js"><!--<![endif]-->
7.<head>
8.<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
9.<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
10.<title><g:layoutTitle default="Grails"/></title>
11.<meta name="viewport" content="width=device-width, initial-scale=1.0">
12.<link rel="shortcut icon" href="${resource(dir: 'images', file: 'favicon.ico')}" type="image/x-icon">
13.<link rel="apple-touch-icon" href="${resource(dir: 'images', file: 'apple-touch-icon.png')}">
14.<link rel="apple-touch-icon" sizes="114x114" href="${resource(dir: 'images', file: 'apple-touch-icon-retina.png')}">
15.<link rel="stylesheet" href="${resource(dir: 'css', file: 'main.css')}" type="text/css">
16.<link rel="stylesheet" href="${resource(dir: 'css', file: 'mobile.css')}" type="text/css">
17.<g:layoutHead/>
18.<r:layoutResources />
19.</head>
20.<body>
21.<div id="grailsLogo" role="banner"><a href="http://grails.org"><imgsrc="${resource(dir: 'images', file: 'grails_logo.png')}" alt="Grails"/></a></div>
22.<g:layoutBody/>
23.<div class="footer" role="contentinfo"></div>
24.<div id="spinner" class="spinner" style="display:none;"><g:message code="spinner.alt" default="Loading&hellip;"/></div>
25.<g:javascript library="application"/>
26.<r:layoutResources />
27.</body>
28.</html>
```

*   *第 1 行到第 6 行*:main . gsp 页面以<开头！doctype html >。这是一个 HTML5 文档类型。Grails 支持现成的 HTML5。
*   *第 10 行* : < g:layoutTitle >在布局中用于呈现装饰页面的 Title 标签的内容。< g:layoutTitle >标签替换了正在被合并的视图中的<标题>,并将它链接到所有视图都将使用的样式表和 favicon 中。
*   *第 17 行*:<g:layout head>标签合并到目标视图的< head >部分的内容中。< g:layoutHead >在布局中用于呈现装饰页面的 Head 标签的内容。
*   *第 22 行* : < g:layoutBody >在 layouts 中用来输出装饰页面的 Body 标签的内容。< g:layoutBody >标签合并到目标视图的<主体>内容中。
*   第 25 行 : < g:javascript >包括 javascript 库和脚本，并提供了内联 JavaScript 的简写。指定一个库告诉 Ajax 标签使用哪个 JavaScript 提供者。

列表视图

列表视图如[清单 7-27](#list27) 所示。

[清单 7-27](#_list27) 。list.gsp

```
1.<%@ page import="bookstore.Book" %>
2.<!DOCTYPE html>
3.<html>
4.<head>
5.<meta name="layout" content="main">
6.<g:set var="entityName" value="${message(code: 'book.label', default: 'Book')}" />
7.<title><g:message code="default.list.label" args="[entityName]" /></title>
8.</head>
9.<body>
10.<a href="#list-book" class="skip" tabindex="-1"><g:message code="default.link.skip.label" default="Skip to content&hellip;"/></a>
11.<div class="nav" role="navigation">
12.<ul>
13.<li><a class="home" href="${createLink(uri: '/')}"><g:message code="default.home.label"/></a></li>
14.<li><g:link class="create" action="create"><g:message code="default.new.label" args="[entityName]" /></g:link></li>
15.</ul>
16.</div>
17.<div id="list-book" class="content scaffold-list" role="main">
18.<h1><g:message code="default.list.label" args="[entityName]" /></h1>
19.<g:if test="${flash.message}">
20.<div class="message" role="status">${flash.message}</div>
21.</g:if>
22.<table>
23.<thead>
24.<tr>
25.
26.<g:sortableColumn property="bookTitle" title="${message(code: 'book.bookTitle.label', default: 'Book Title')}" />
27.
28.<g:sortableColumn property="price" title="${message(code: 'book.price.label', default: 'Price')}" />
29.
30.<g:sortableColumn property="isbn" title="${message(code: 'book.isbn.label', default: 'Isbn')}" />
31.
32.</tr>
33.</thead>
34.<tbody>
35.<g:each in="${bookInstanceList}" status="i" var="bookInstance">
36.<tr class="${(i % 2) == 0 ? 'even' : 'odd'}">
37.
38.<td><g:link action="show" id="${bookInstance.id}">${fieldValue(bean: bookInstance, field: "bookTitle")}</g:link></td>
39.
40.<td>${fieldValue(bean: bookInstance, field: "price")}</td>
41.
42.<td>${fieldValue(bean: bookInstance, field: "isbn")}</td>
43.
44.</tr>
45.</g:each>
46.</tbody>
47.</table>
48.<div class="pagination">
49.<g:paginate total="${bookInstanceTotal}" />
50.</div>
51.</div>
52.</body>
53.</html>
```

*   *第 14 行*:<g:link>标签创建了一个到 BookController 的 create 动作的链接。
*   *第 19 行*:<g:if>标签检查存储在动作中的 flash.message 是否存在，如果存在，就显示出来。
*   *第 26 到 31 行*:<g:sortable column>标签用于在我们的列表视图中提供排序。
*   *第 35 到 45 行*:<g:each>标签遍历 bookInstanceList。列表中的每一项都被分配给 bookInstance 变量。< g:each >标签的主体用 bookInstance 的属性填充表格行。在第<行 tr class="${(i % 2) == 0？even' : 'odd'}" >，用 Groovy 表达式确定< tr >的样式类，用 fieldValue()方法渲染每个 Book 属性的值。
*   *第 49 行*:<g:paginate>标签显示列表视图中是否有足够的元素的分页控件。如前所述，bookInstanceTotal 是从[清单 7-19](#list19) 中使用的。

创建视图

创建视图如清单 7-28 中的[所示。](#list28)

[清单 7-28](#_list28) 。create.gsp

```
1.<%@ page import="bookstore.Book" %>
2.<!DOCTYPE html>
3.<html>
4.<head>
5.<meta name="layout" content="main">
6.<g:set var="entityName" value="${message(code: 'book.label', default: 'Book')}" />
7.<title><g:message code="default.create.label" args="[entityName]" /></title>
8.</head>
9.<body>
10.<a href="#create-book" class="skip" tabindex="-1"><g:message code="default.link.skip.label" default="Skip to content&hellip;"/></a>
11.<div class="nav" role="navigation">
12.<ul>
13.<li><a class="home" href="${createLink(uri: '/')}"><g:message code="default.home.label"/></a></li>
14.<li><g:link class="list" action="list"><g:message code="default.list.label" args="[entityName]" /></g:link></li>
15.</ul>
16.</div>
17.<div id="create-book" class="content scaffold-create" role="main">
18.<h1><g:message code="default.create.label" args="[entityName]" /></h1>
19.<g:if test="${flash.message}">
20.<div class="message" role="status">${flash.message}</div>
21.</g:if>
22.<g:hasErrors bean="${bookInstance}">
23.<ul class="errors" role="alert">
24.<g:eachError bean="${bookInstance}" var="error">
25.<li <g:if test="${error in org.springframework.validation.FieldError}">data-field-id="${error.field}"</g:if>><g:message error="${error}"/></li>
26.</g:eachError>
27.</ul>
28.</g:hasErrors>
29.<g:form action="save" >
30.<fieldset class="form">
31.<g:render template="form"/>
32.</fieldset>
33.<fieldset class="buttons">
34.<g:submitButton name="create" class="save" value="${message(code: 'default.button.create.label', default: 'Create')}" />
35.</fieldset>
36.</g:form>
37.</div>
38.</body>
39.</html>
```

*   *第 22 行到第 28 行*:<g:has errors>标签检查分配给其 bean 属性的 Book 实例，如果发现错误，则呈现其主体。
*   *第 29 行到第 36 行*:<g:form>标签建立了一个 HTML 表单。这个标签有一个动作，这个动作将导致表单提交到的 URL。
*   *Line 31* : < g:render >对模型应用内置或用户定义的 Groovy 模板，这样模板就可以被共享和重用。在这种情况下，模板称为 form，位于 views 目录中，名为 _form.gsp。gsp 文件是一个模板。

显示视图

展示视图如清单 7-29 中的[所示。](#list29)

[清单 7-29](#_list29) 。show.gsp

```
1.<%@ page import="bookstore.Book" %>
2.<!DOCTYPE html>
3.<html>
4.<head>
5.<meta name="layout" content="main">
6.<g:set var="entityName" value="${message(code: 'book.label', default: 'Book')}" />
7.<title><g:message code="default.show.label" args="[entityName]" /></title>
8.</head>
9.<body>
10.<a href="#show-book" class="skip" tabindex="-1"><g:message code="default.link.skip.label" default="Skip to content&hellip;"/></a>
11.<div class="nav" role="navigation">
12.<ul>
13.<li><a class="home" href="${createLink(uri: '/')}"><g:message code="default.home.label"/></a></li>
14.<li><g:link class="list" action="list"><g:message code="default.list.label" args="[entityName]" /></g:link></li>
15.<li><g:link class="create" action="create"><g:message code="default.new.label" args="[entityName]" /></g:link></li>
16.</ul>
17.</div>
18.<div id="show-book" class="content scaffold-show" role="main">
19.<h1><g:message code="default.show.label" args="[entityName]" /></h1>
20.<g:if test="${flash.message}">
21.<div class="message" role="status">${flash.message}</div>
22.</g:if>
23.<ol class="property-list book">
24.
25.<g:if test="${bookInstance?.bookTitle}">
26.<li class="fieldcontain">
27.<span id="bookTitle-label" class="property-label"><g:message code="book.bookTitle.label" default="Book Title" /></span>
28.
29.<span class="property-value" aria-labelledby="bookTitle-label"><g:fieldValue bean="${bookInstance}" field="bookTitle"/></span>
30.
31.</li>
32.</g:if>
33.
34.<g:if test="${bookInstance?.price}">
35.<li class="fieldcontain">
36.<span id="price-label" class="property-label"><g:message code="book.price.label" default="Price" /></span>
37.
38.<span class="property-value" aria-labelledby="price-label"><g:fieldValue bean="${bookInstance}" field="price"/></span>
39.
40.</li>
41.</g:if>
42.
43.<g:if test="${bookInstance?.isbn}">
44.<li class="fieldcontain">
45.<span id="isbn-label" class="property-label"><g:message code="book.isbn.label" default="Isbn" /></span>
46.
47.<span class="property-value" aria-labelledby="isbn-label"><g:fieldValue bean="${bookInstance}" field="isbn"/></span>
48.
49.</li>
50.</g:if>
51.
52.</ol>
53.<g:form>
54.<fieldset class="buttons">
55.<g:hiddenField name="id" value="${bookInstance?.id}" />
56.<g:link class="edit" action="edit" id="${bookInstance?.id}"><g:message code="default.button.edit.label" default="Edit" /></g:link>
57.<g:actionSubmit class="delete" action="delete" value="${message(code: 'default.button.delete.label', default: 'Delete')}" onclick="return confirm('${message(code: 'default.button.delete.confirm.message', default: 'Are you sure?')}');" />
58.</fieldset>
59.</g:form>
60.</div>
61.</body>
62.</html>
```

*   *第 55 行到第 56 行*:这个？bookInstance 引用后是一个安全的导航运算符。计算该表达式时，如果 bookInstance 为 null，则整个表达式的计算结果为 null，并且不会引发异常。
*   *Line 57*:<g:action submit>标签生成一个提交按钮，该按钮映射到一个特定的动作，这使得在一个表单中可以有多个提交按钮。可以使用与 HTML 中相同的参数名添加 JavaScript 事件处理程序。

编辑视图

编辑视图如清单 7-30 中的[所示。](#list30)

[清单 7-30](#_list30) 。edit.gsp

```
1.<%@ page import="bookstore.Book" %>
2.<!DOCTYPE html>
3.<html>
4.<head>
5.<meta name="layout" content="main">
6.<g:set var="entityName" value="${message(code: 'book.label', default: 'Book')}" />
7.<title><g:message code="default.edit.label" args="[entityName]" /></title>
8.</head>
9.<body>
10.<a href="#edit-book" class="skip" tabindex="-1"><g:message code="default.link.skip.label" default="Skip to content&hellip;"/></a>
11.<div class="nav" role="navigation">
12.<ul>
13.<li><a class="home" href="${createLink(uri: '/')}"><g:message code="default.home.label"/></a></li>
14.<li><g:link class="list" action="list"><g:message code="default.list.label" args="[entityName]" /></g:link></li>
15.<li><g:link class="create" action="create"><g:message code="default.new.label" args="[entityName]" /></g:link></li>
16.</ul>
17.</div>
18.<div id="edit-book" class="content scaffold-edit" role="main">
19.<h1><g:message code="default.edit.label" args="[entityName]" /></h1>
20.<g:if test="${flash.message}">
21.<div class="message" role="status">${flash.message}</div>
22.</g:if>
23.<g:hasErrors bean="${bookInstance}">
24.<ul class="errors" role="alert">
25.<g:eachError bean="${bookInstance}" var="error">
26.<li <g:if test="${error in org.springframework.validation.FieldError}">data-field-id="${error.field}"</g:if>><g:message error="${error}"/></li>
27.</g:eachError>
28.</ul>
29.</g:hasErrors>
30.<g:form method="post" >
31.<g:hiddenField name="id" value="${bookInstance?.id}" />
32.<g:hiddenField name="version" value="${bookInstance?.version}" />
33.<fieldset class="form">
34.<g:render template="form"/>
35.</fieldset>
36.<fieldset class="buttons">
37.<g:actionSubmit class="save" action="update" value="${message(code: 'default.button.update.label', default: 'Update')}" />
38.<g:actionSubmit class="delete" action="delete" value="${message(code: 'default.button.delete.label', default: 'Delete')}" formnovalidate="" onclick="return confirm('${message(code: 'default.button.delete.confirm.message', default: 'Are you sure?')}');" />
39.</fieldset>
40.</g:form>
41.</div>
42.</body>
43.</html>
```

*   *第 31 到 32 行*:在[清单 7-24](#list24) 中，提到了 update()动作中的 id 是从这个编辑视图中提供的。id 来自于< g:隐藏字段>标签，如代码所示。

至此，我们已经完成了 Book 类的静态搭建所生成的所有视图。

H2 控制台

如前所述，Grails 在开发模式下启用了 H2 数据库控制台(在 URI /dbconsole 处),这样就可以从浏览器轻松地查询内存中的数据库。要查看 dbconsole 的运行情况，请浏览到[http://localhost:8080/book store/dbconsole](http://localhost:8080/bookstore/dbconsole)。默认的登录参数应该与 grails-app/conf/data source . groovy 中的默认参数相匹配，如图[图 7-29](#Fig29) 所示。

![9781430259831_Fig07-29.jpg](Images/9781430259831_Fig07-29.jpg)

[图 7-29](#_Fig29) 。H2 的登录界面

你可以从 Datasource.groovy 中获取用户名和密码[图 7-30](#Fig30) 说明了 H2 控制台 。

![9781430259831_Fig07-30.jpg](Images/9781430259831_Fig07-30.jpg)

[图 7-30](#_Fig30) 。H2 控制台

现在，在我们的书店应用程序中添加一本书，然后在数据库控制台中输入 **SELECT * from BOOK** 。我们在应用程序中创建的用户将会出现，如图[图 7-31](#Fig31) 所示。

![9781430259831_Fig07-31.jpg](Images/9781430259831_Fig07-31.jpg)

[图 7-31](#_Fig31) 。查询 H2表

创建域关系 s

在应用程序域中，类与类之间有关系。域关系定义了域类如何交互。Grails 支持领域类之间的几种关系。一对多关系是指一个类 Author 拥有 Book 类的多个实例。使用 Grails，你可以用 hasMany 设置定义这样的关系，如清单 7-31 所示。

[清单 7-31](#_list31) 。作者和书之间的一对多关系

```
class Author {
    static hasMany = [books: Book]

String name }

class Book {
    String title
}
```

在清单 7-31 中有一个单向的一对多。默认情况下，Grails 会用一个连接表来映射这种关系。Grails 会根据 hasMany 设置自动将 java.util.Set 类型的属性注入到域类中。Grails 通过在关系的两端定义 hasMany 并在关系的拥有方定义 belongsTo 来支持多对多关系。

您将创建一个在作者和图书之间具有多对多域关系的应用程序。您可以在源代码档案的第 7 章中的 books 项目中找到这个应用程序的源代码，您可以从 Apress 网站下载。[清单 7-32](#list32) 说明了图书类。

[清单 7-32](#_list32) 。创建图书和作者之间的域关系

```
1.package books
2.
3.class Book {
4.    static belongsTo = Author
5.    static hasMany = [authors:Author]
6.    String title
7.Long isbn
8.String publisher
9.static constraints = {
10.title(blank:false)
11.}
12.
13.String toString() {
14.title
15.}
16.}
```

*   *第 4 行*:这一行通知 Grails Book 类属于它自己的作者。
*   *第 5 行*:这一行通知 Grails Book 类有许多 Author 实例。

[清单 7-33](#list33) 说明了作者类。

[清单 7-33](#_list33) 。作者类。

```
1.package books
2.
3.class Author {
4.
5.    static hasMany = [books:Book]
6.    String firstName
7.String lastName
8.static constraints = {
9.firstName(blank:false)
10.lastName(blank:false)
11.}
12.String toString() {
13."$lastName, $firstName"
14.}
15.}
```

*   *第 5 行*:这一行告诉 Grails 一个作者有许多 Book 的实例。

Grails 使用数据库级别的连接表映射多对多关系。关系的拥有方(本应用程序中的作者)负责保持关系，因为 Grails 使用 Hibernate 作为 ORM 框架，而在 Hibernate 中，多对多关系中只有一方负责管理关系。

创建了域类之间的关系后，您需要做的就是创建 BookController 和 AuthorController，并设置它们的 scaffold 属性。在您创建的 BookController 中，用设置为 Book 的 scaffold 属性替换 index()动作，如[清单 7-34](#list34) 所示。

[清单 7-34](#_list34) 。图书管理员

```
class BookController {

    static scaffold = Book
}
```

在 AuthorController 中，将 scaffold 属性设置为 Author，如清单 7-35 所示。

[清单 7-35](#_list35) 。AuthorController

```
class AuthorController {

    static scaffold = Author
}
```

现在您可以运行应用程序了。脚手架将为您生成应用程序，并将您指向 URL。[图 7-32](#Fig32) 显示了应用程序的欢迎界面。

![9781430259831_Fig07-32.jpg](Images/9781430259831_Fig07-32.jpg)

[图 7-32](#_Fig32) 。图书应用的欢迎界面

点击 AuthorController，显示作者列表界面，如图[图 7-33](#Fig33) 所示。

![9781430259831_Fig07-33.jpg](Images/9781430259831_Fig07-33.jpg)

[图 7-33](#_Fig33) 。作者列表屏幕

在[图 7-33](#Fig33) 中，您可以通过点击新作者链接来创建新作者。[图 7-34](#Fig34) 显示了这样创建的作者列表。

![9781430259831_Fig07-34.jpg](Images/9781430259831_Fig07-34.jpg)

[图 7-34](#_Fig34) 。作者名单

现在你可以通过点击欢迎界面上的图书控制器链接来查看图书列表，如图[图 7-35](#Fig35) 所示。

![9781430259831_Fig07-35.jpg](Images/9781430259831_Fig07-35.jpg)

[图 7-35](#_Fig35) 。图书列表屏幕

您可以通过单击新书链接来添加新书。单击“新建图书”时，将显示“创建图书”屏幕。如果你试图创建一个标题和 Isbn 字段为空的书，你会得到如图[图 7-36](#Fig36) 所示的确认信息。在[清单 7-32](#list32) 中，您没有为 ISBN 编写任何约束，但是 ISBN 字段仍然有验证，因为 Grails 默认为一些字段提供了约束，ISBN 就是其中之一(如本章[表 7-2](#Tab2) 中所列)。

![9781430259831_Fig07-36.jpg](Images/9781430259831_Fig07-36.jpg)

[图 7-36](#_Fig36) 。验证错误

现在，您可以通过为这些字段提供值来创建图书。[图 7-37](#Fig37) 显示了创建了两本图书的图书列表屏幕。

![9781430259831_Fig07-37.jpg](Images/9781430259831_Fig07-37.jpg)

[图 7-37](#_Fig37) 。图书列表屏幕

现在你可以进入作者列表界面，点击编辑按钮，如图[图 7-38](#Fig38) 所示。

![9781430259831_Fig07-38.jpg](Images/9781430259831_Fig07-38.jpg)

[图 7-38](#_Fig38) 。编辑作者

点击编辑按钮，会看到有两本书可用，如图[图 7-39](#Fig39) 所示。您可以选择这两本书，然后单击“更新”按钮。

![9781430259831_Fig07-39.jpg](Images/9781430259831_Fig07-39.jpg)

[图 7-39](#_Fig39) 。编辑作者屏幕

这样，您可以为您创建的所有作者添加图书。现在，当你进入图书列表界面并点击其中一个书名链接时，显示图书界面会显示该书所有作者的名字，如图[图 7-40](#Fig40) 所示。

![9781430259831_Fig07-40.jpg](Images/9781430259831_Fig07-40.jpg)

[图 7-40](#_Fig40) 。显示图书屏幕

本章到此结束，它概述了 Grails 2 的概况。对于更详细的报道，我推荐 Vishal Layka、Christopher M. Judd、Joseph Faisal Nusairat 和 Jim shiller(2012 年出版)的 *Beginning Groovy、Grails* 、*和 Griffon* ，以及 Jeff 斯科特·布朗和 Graeme Rocher(2012 年出版)的*Grails 2*权威指南。

摘要

在本章中，您了解了 Grails 是一个快速的 web 开发框架，它结合了 Java 开源、约定、Groovy 动态语言和 Java 平台的优势。您看到了使用 Grails 脚手架来完成大部分工作，开发一个全功能的应用程序是多么容易。您使用静态搭建作为学习工具，为一个领域类(书籍)生成控制器和视图。然后浏览控制器，看到控制器中的所有工作都在动作中完成了。然后，您学习了负责相应视图的每个动作的代码。最后，您浏览了视图，看到了视图如何利用 Grails 标记库来促进关注点的清晰分离。

[<sup class="calibre12">1</sup>](#_Fn1)【www.h2database.com/html/main.html】T4

[<sup class="calibre12">2</sup>](#_Fn2)【http://wiki.sitemesh.org/display/sitemesh/Home】T4