# 六、添加防灾难层

## 介绍

编写代码，运行单元和集成测试，进行代码质量分析，创建 CI/CD 管道——许多开发人员认为旅程到此结束，新的迭代将重新开始。我们忘记了应用运行时。我不是指在哪里执行这个应用，我们已经说过我们将在 Docker 容器中运行这个应用。我说的是*应用将如何*运行:

*   用户会如何使用 QuarkuShop？

*   如何控制用户对应用的访问？

*   我们能处理未经授权的访问吗？我们知道哪些该承认，哪些该拒绝吗？

*   如何测量和跟踪 CPU 和内存资源的消耗？

*   如果应用耗尽资源会发生什么？

关于运行时还有更多问题要问。这些问题揭示了 QuarkuShop 中缺失的两层:

*   **安全层**:所有的认证和授权部分。

*   **监控层**:所有的度量，即测量和跟踪组件。

## 实现安全层

保安！对于开发人员来说，这是最令人痛苦的话题之一，但它可能是任何企业应用中最关键的主题。安全性在 IT 界一直是一个非常具有挑战性的话题:技术和框架在不断发展，黑客也在不断发展。![img/509649_1_En_6_Figb_HTML.gif](img/509649_1_En_6_Figb_HTML.gif)

对于这个 QuarkuShop，我们将使用专用的 Quarkus 组件以及推荐的实践和设计选择。本章讨论如何实现一个典型的认证和授权引擎。

![img/509649_1_En_6_Figc_HTML.gif](img/509649_1_En_6_Figc_HTML.gif)我将认证和授权过程称为`auth` <sup>2</sup> 。

### 分析安全要求和需求

在编写任何代码之前，我们从创建设计开始，例如使用 UML 图。安全层也是如此；我们需要在实现代码之前创建设计。但是哪个设计呢？代码在那里。我们将设计什么？

QuarkuShop 的全部功能已经实现，但还有很多需要设计。

我喜欢把建筑软件比作盖房子。到目前为止，我们所做的是:

*   建了房子，这和写源代码是一样的。

*   验证建筑与计划的一致性，这与编写测试相同。

*   将房子连接到电、水和下水道网络，这与配置数据库、SonarCloud 等的访问权限是一样的。

*   得到家具并装饰房子，这与创建 CI/CD 管道是一样的。

房子现在准备好了，业主希望有一个安全系统。我们从检查窗户和门开始，以定位可能的入口，这就是我们放置锁的地方。只有钥匙持有人可以进入，视人而定，主人会分配钥匙。例如，只有司机才有车库钥匙。园丁将有两把钥匙:一把开外门，一把开存放工具的花园小屋。住在房子里的家庭成员将毫无例外地拥有所有的钥匙。

我们也将有摄像头和传感器来监控和审计进入房子。当我们怀疑有人非法进入房子，我们可以检查摄像头，看看发生了什么。

这个家庭安全系统部署过程在某种程度上与添加应用的安全层是一样的。我们遵循相同的基本步骤:

1.  我们分析并定位应用的所有访问点。这个过程叫做*攻击面分析。*

> 攻击面分析帮你:

*   确定系统的哪些功能和部分需要检查/测试安全漏洞。

*   识别需要纵深防御保护的高风险代码区域；你需要保护系统的哪些部分。

*   确定何时改变了攻击面，何时需要进行某种威胁评估。

> —OWASP 小抄系列 [`https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html`](https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html)

1.  我们会在这些入口上锁。这些锁是*认证*过程的一部分。

> 认证是验证个人、实体或网站是否是其所声称的人的过程。web 应用上下文中的身份验证通常通过提交用户名或 ID 以及一项或多项只有给定用户才应该知道的私有信息来执行。
> 
> —OWASP 小抄系列 [`https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html`](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)

1.  我们将定义一个访问控制机制，以确保只有被允许的人才能访问给定的“门”。这个过程叫做*授权*。

> 授权是访问特定资源的请求应该被准许或拒绝的过程。应该注意的是，授权并不等同于认证——因为这些术语及其定义经常被混淆。身份验证是提供和验证身份。授权包括确定用户(或主体)可以访问哪些功能和数据的执行规则，确保在身份验证成功后正确分配访问权限。
> 
> —OWASP 小抄系列 [`https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html`](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)

QuarkuShop 是一个 Java 企业应用，它公开了 REST APIs，这是与应用用户的唯一通信渠道。

QuarkuShop 的用户可分为三类:

*   **访客或匿名**:未经认证的客户

*   **用户**:经过认证的客户

*   **Admin** :应用超级用户

下一步是定义允许哪个用户类别访问每个 REST API 服务。这可以使用*授权矩阵*来完成。

### 为 REST APIs 定义授权矩阵

**Cart REST API*的授权矩阵*

 *<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

操作

 | 

匿名的

 | 

用户

 | 

管理

 |
| --- | --- | --- | --- |
| 获取所有购物车 | ![img/509649_1_En_6_Figd_HTML.gif](img/509649_1_En_6_Figd_HTML.gif) | ![img/509649_1_En_6_Fige_HTML.gif](img/509649_1_En_6_Fige_HTML.gif) | ![img/509649_1_En_6_Figf_HTML.gif](img/509649_1_En_6_Figf_HTML.gif) |
| 获取活动购物车 | ![img/509649_1_En_6_Figg_HTML.gif](img/509649_1_En_6_Figg_HTML.gif) | ![img/509649_1_En_6_Figh_HTML.gif](img/509649_1_En_6_Figh_HTML.gif) | ![img/509649_1_En_6_Figi_HTML.gif](img/509649_1_En_6_Figi_HTML.gif) |
| 按客户 ID 获取购物车 | ![img/509649_1_En_6_Figj_HTML.gif](img/509649_1_En_6_Figj_HTML.gif) | ![img/509649_1_En_6_Figk_HTML.gif](img/509649_1_En_6_Figk_HTML.gif) | ![img/509649_1_En_6_Figl_HTML.gif](img/509649_1_En_6_Figl_HTML.gif) |
| 为给定客户创建新购物车 | ![img/509649_1_En_6_Figm_HTML.gif](img/509649_1_En_6_Figm_HTML.gif) | ![img/509649_1_En_6_Fign_HTML.gif](img/509649_1_En_6_Fign_HTML.gif) | ![img/509649_1_En_6_Figo_HTML.gif](img/509649_1_En_6_Figo_HTML.gif) |
| 按 ID 获取购物车 | ![img/509649_1_En_6_Figp_HTML.gif](img/509649_1_En_6_Figp_HTML.gif) | ![img/509649_1_En_6_Figq_HTML.gif](img/509649_1_En_6_Figq_HTML.gif) | ![img/509649_1_En_6_Figr_HTML.gif](img/509649_1_En_6_Figr_HTML.gif) |
| 按 ID 删除购物车 | ![img/509649_1_En_6_Figs_HTML.gif](img/509649_1_En_6_Figs_HTML.gif) | ![img/509649_1_En_6_Figt_HTML.gif](img/509649_1_En_6_Figt_HTML.gif) | ![img/509649_1_En_6_Figu_HTML.gif](img/509649_1_En_6_Figu_HTML.gif) |

**类别 REST API* 的授权矩阵*

 *<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

操作

 | 

匿名的

 | 

用户

 | 

管理

 |
| --- | --- | --- | --- |
| 列出所有类别 | ![img/509649_1_En_6_Figv_HTML.gif](img/509649_1_En_6_Figv_HTML.gif) | ![img/509649_1_En_6_Figw_HTML.gif](img/509649_1_En_6_Figw_HTML.gif) | ![img/509649_1_En_6_Figx_HTML.gif](img/509649_1_En_6_Figx_HTML.gif) |
| 创建新类别 | ![img/509649_1_En_6_Figy_HTML.gif](img/509649_1_En_6_Figy_HTML.gif) | ![img/509649_1_En_6_Figz_HTML.gif](img/509649_1_En_6_Figz_HTML.gif) | ![img/509649_1_En_6_Figaa_HTML.gif](img/509649_1_En_6_Figaa_HTML.gif) |
| 按 ID 获取类别 | ![img/509649_1_En_6_Figab_HTML.gif](img/509649_1_En_6_Figab_HTML.gif) | ![img/509649_1_En_6_Figac_HTML.gif](img/509649_1_En_6_Figac_HTML.gif) | ![img/509649_1_En_6_Figad_HTML.gif](img/509649_1_En_6_Figad_HTML.gif) |
| 按 ID 删除类别 | ![img/509649_1_En_6_Figae_HTML.gif](img/509649_1_En_6_Figae_HTML.gif) | ![img/509649_1_En_6_Figaf_HTML.gif](img/509649_1_En_6_Figaf_HTML.gif) | ![img/509649_1_En_6_Figag_HTML.gif](img/509649_1_En_6_Figag_HTML.gif) |
| 按类别 ID 获取产品 | ![img/509649_1_En_6_Figah_HTML.gif](img/509649_1_En_6_Figah_HTML.gif) | ![img/509649_1_En_6_Figai_HTML.gif](img/509649_1_En_6_Figai_HTML.gif) | ![img/509649_1_En_6_Figaj_HTML.gif](img/509649_1_En_6_Figaj_HTML.gif) |

**客户休息 API* 的授权矩阵*

 *<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

操作

 | 

匿名的

 | 

用户

 | 

管理

 |
| --- | --- | --- | --- |
| 获取所有客户 | ![img/509649_1_En_6_Figak_HTML.gif](img/509649_1_En_6_Figak_HTML.gif) | ![img/509649_1_En_6_Figal_HTML.gif](img/509649_1_En_6_Figal_HTML.gif) | ![img/509649_1_En_6_Figam_HTML.gif](img/509649_1_En_6_Figam_HTML.gif) |
| 创建新客户 | ![img/509649_1_En_6_Figan_HTML.gif](img/509649_1_En_6_Figan_HTML.gif) | ![img/509649_1_En_6_Figao_HTML.gif](img/509649_1_En_6_Figao_HTML.gif) | ![img/509649_1_En_6_Figap_HTML.gif](img/509649_1_En_6_Figap_HTML.gif) |
| 获得活跃客户 | ![img/509649_1_En_6_Figaq_HTML.gif](img/509649_1_En_6_Figaq_HTML.gif) | ![img/509649_1_En_6_Figar_HTML.gif](img/509649_1_En_6_Figar_HTML.gif) | ![img/509649_1_En_6_Figas_HTML.gif](img/509649_1_En_6_Figas_HTML.gif) |
| 获得不活跃的客户 | ![img/509649_1_En_6_Figat_HTML.gif](img/509649_1_En_6_Figat_HTML.gif) | ![img/509649_1_En_6_Figau_HTML.gif](img/509649_1_En_6_Figau_HTML.gif) | ![img/509649_1_En_6_Figav_HTML.gif](img/509649_1_En_6_Figav_HTML.gif) |
| 按 ID 获取客户 | ![img/509649_1_En_6_Figaw_HTML.gif](img/509649_1_En_6_Figaw_HTML.gif) | ![img/509649_1_En_6_Figax_HTML.gif](img/509649_1_En_6_Figax_HTML.gif) | ![img/509649_1_En_6_Figay_HTML.gif](img/509649_1_En_6_Figay_HTML.gif) |
| 按 ID 删除客户 | ![img/509649_1_En_6_Figaz_HTML.gif](img/509649_1_En_6_Figaz_HTML.gif) | ![img/509649_1_En_6_Figba_HTML.gif](img/509649_1_En_6_Figba_HTML.gif) | ![img/509649_1_En_6_Figbb_HTML.gif](img/509649_1_En_6_Figbb_HTML.gif) |

*授权矩阵为* *订单* *REST API*

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

操作

 | 

匿名的

 | 

用户

 | 

管理

 |
| --- | --- | --- | --- |
| 获取所有订单 | ![img/509649_1_En_6_Figbc_HTML.gif](img/509649_1_En_6_Figbc_HTML.gif) | ![img/509649_1_En_6_Figbd_HTML.gif](img/509649_1_En_6_Figbd_HTML.gif) | ![img/509649_1_En_6_Figbe_HTML.gif](img/509649_1_En_6_Figbe_HTML.gif) |
| 创建新订单 | ![img/509649_1_En_6_Figbf_HTML.gif](img/509649_1_En_6_Figbf_HTML.gif) | ![img/509649_1_En_6_Figbg_HTML.gif](img/509649_1_En_6_Figbg_HTML.gif) | ![img/509649_1_En_6_Figbh_HTML.gif](img/509649_1_En_6_Figbh_HTML.gif) |
| 按客户 ID 获取订单 | ![img/509649_1_En_6_Figbi_HTML.gif](img/509649_1_En_6_Figbi_HTML.gif) | ![img/509649_1_En_6_Figbj_HTML.gif](img/509649_1_En_6_Figbj_HTML.gif) | ![img/509649_1_En_6_Figbk_HTML.gif](img/509649_1_En_6_Figbk_HTML.gif) |
| 检查是否有给定 ID 的订单 | ![img/509649_1_En_6_Figbl_HTML.gif](img/509649_1_En_6_Figbl_HTML.gif) | ![img/509649_1_En_6_Figbm_HTML.gif](img/509649_1_En_6_Figbm_HTML.gif) | ![img/509649_1_En_6_Figbn_HTML.gif](img/509649_1_En_6_Figbn_HTML.gif) |
| 按 ID 获取订单 | ![img/509649_1_En_6_Figbo_HTML.gif](img/509649_1_En_6_Figbo_HTML.gif) | ![img/509649_1_En_6_Figbp_HTML.gif](img/509649_1_En_6_Figbp_HTML.gif) | ![img/509649_1_En_6_Figbq_HTML.gif](img/509649_1_En_6_Figbq_HTML.gif) |
| 按 ID 删除订单 | ![img/509649_1_En_6_Figbr_HTML.gif](img/509649_1_En_6_Figbr_HTML.gif) | ![img/509649_1_En_6_Figbs_HTML.gif](img/509649_1_En_6_Figbs_HTML.gif) | ![img/509649_1_En_6_Figbt_HTML.gif](img/509649_1_En_6_Figbt_HTML.gif) |

**订单授权矩阵-项目* *REST API**

 *<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

操作

 | 

匿名的

 | 

用户

 | 

管理

 |
| --- | --- | --- | --- |
| 创建新的订单项目 | ![img/509649_1_En_6_Figbu_HTML.gif](img/509649_1_En_6_Figbu_HTML.gif) | ![img/509649_1_En_6_Figbv_HTML.gif](img/509649_1_En_6_Figbv_HTML.gif) | ![img/509649_1_En_6_Figbw_HTML.gif](img/509649_1_En_6_Figbw_HTML.gif) |
| 按订单 ID 获取订单项目 | ![img/509649_1_En_6_Figbx_HTML.gif](img/509649_1_En_6_Figbx_HTML.gif) | ![img/509649_1_En_6_Figby_HTML.gif](img/509649_1_En_6_Figby_HTML.gif) | ![img/509649_1_En_6_Figbz_HTML.gif](img/509649_1_En_6_Figbz_HTML.gif) |
| 按 ID 获取订单项目 | ![img/509649_1_En_6_Figca_HTML.gif](img/509649_1_En_6_Figca_HTML.gif) | ![img/509649_1_En_6_Figcb_HTML.gif](img/509649_1_En_6_Figcb_HTML.gif) | ![img/509649_1_En_6_Figcc_HTML.gif](img/509649_1_En_6_Figcc_HTML.gif) |
| 按 ID 删除订单项目 | ![img/509649_1_En_6_Figcd_HTML.gif](img/509649_1_En_6_Figcd_HTML.gif) | ![img/509649_1_En_6_Figce_HTML.gif](img/509649_1_En_6_Figce_HTML.gif) | ![img/509649_1_En_6_Figcf_HTML.gif](img/509649_1_En_6_Figcf_HTML.gif) |

*授权矩阵为* *支付* *休息 API*

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

操作

 | 

匿名的

 | 

用户

 | 

管理

 |
| --- | --- | --- | --- |
| 获得所有付款 | ![img/509649_1_En_6_Figcg_HTML.gif](img/509649_1_En_6_Figcg_HTML.gif) | ![img/509649_1_En_6_Figch_HTML.gif](img/509649_1_En_6_Figch_HTML.gif) | ![img/509649_1_En_6_Figci_HTML.gif](img/509649_1_En_6_Figci_HTML.gif) |
| 创建新的付款 | ![img/509649_1_En_6_Figcj_HTML.gif](img/509649_1_En_6_Figcj_HTML.gif) | ![img/509649_1_En_6_Figck_HTML.gif](img/509649_1_En_6_Figck_HTML.gif) | ![img/509649_1_En_6_Figcl_HTML.gif](img/509649_1_En_6_Figcl_HTML.gif) |
| 获得低于或等于限额的付款 | ![img/509649_1_En_6_Figcm_HTML.gif](img/509649_1_En_6_Figcm_HTML.gif) | ![img/509649_1_En_6_Figcn_HTML.gif](img/509649_1_En_6_Figcn_HTML.gif) | ![img/509649_1_En_6_Figco_HTML.gif](img/509649_1_En_6_Figco_HTML.gif) |
| 通过 ID 获得付款 | ![img/509649_1_En_6_Figcp_HTML.gif](img/509649_1_En_6_Figcp_HTML.gif) | ![img/509649_1_En_6_Figcq_HTML.gif](img/509649_1_En_6_Figcq_HTML.gif) | ![img/509649_1_En_6_Figcr_HTML.gif](img/509649_1_En_6_Figcr_HTML.gif) |
| 按 ID 删除付款 | ![img/509649_1_En_6_Figcs_HTML.gif](img/509649_1_En_6_Figcs_HTML.gif) | ![img/509649_1_En_6_Figct_HTML.gif](img/509649_1_En_6_Figct_HTML.gif) | ![img/509649_1_En_6_Figcu_HTML.gif](img/509649_1_En_6_Figcu_HTML.gif) |

**产品* *REST API* 的授权矩阵*

 *<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

操作

 | 

匿名的

 | 

用户

 | 

管理

 |
| --- | --- | --- | --- |
| 获取所有产品 | ![img/509649_1_En_6_Figcv_HTML.gif](img/509649_1_En_6_Figcv_HTML.gif) | ![img/509649_1_En_6_Figcw_HTML.gif](img/509649_1_En_6_Figcw_HTML.gif) | ![img/509649_1_En_6_Figcx_HTML.gif](img/509649_1_En_6_Figcx_HTML.gif) |
| 创造新产品 | ![img/509649_1_En_6_Figcy_HTML.gif](img/509649_1_En_6_Figcy_HTML.gif) | ![img/509649_1_En_6_Figcz_HTML.gif](img/509649_1_En_6_Figcz_HTML.gif) | ![img/509649_1_En_6_Figda_HTML.gif](img/509649_1_En_6_Figda_HTML.gif) |
| 按类别 ID 获取产品 | ![img/509649_1_En_6_Figdb_HTML.gif](img/509649_1_En_6_Figdb_HTML.gif) | ![img/509649_1_En_6_Figdc_HTML.gif](img/509649_1_En_6_Figdc_HTML.gif) | ![img/509649_1_En_6_Figdd_HTML.gif](img/509649_1_En_6_Figdd_HTML.gif) |
| 清点所有产品 | ![img/509649_1_En_6_Figde_HTML.gif](img/509649_1_En_6_Figde_HTML.gif) | ![img/509649_1_En_6_Figdf_HTML.gif](img/509649_1_En_6_Figdf_HTML.gif) | ![img/509649_1_En_6_Figdg_HTML.gif](img/509649_1_En_6_Figdg_HTML.gif) |
| 按类别 ID 计算产品数量 | ![img/509649_1_En_6_Figdh_HTML.gif](img/509649_1_En_6_Figdh_HTML.gif) | ![img/509649_1_En_6_Figdi_HTML.gif](img/509649_1_En_6_Figdi_HTML.gif) | ![img/509649_1_En_6_Figdj_HTML.gif](img/509649_1_En_6_Figdj_HTML.gif) |
| 通过 ID 获取产品 | ![img/509649_1_En_6_Figdk_HTML.gif](img/509649_1_En_6_Figdk_HTML.gif) | ![img/509649_1_En_6_Figdl_HTML.gif](img/509649_1_En_6_Figdl_HTML.gif) | ![img/509649_1_En_6_Figdm_HTML.gif](img/509649_1_En_6_Figdm_HTML.gif) |
| 按 ID 删除产品 | ![img/509649_1_En_6_Figdn_HTML.gif](img/509649_1_En_6_Figdn_HTML.gif) | ![img/509649_1_En_6_Figdo_HTML.gif](img/509649_1_En_6_Figdo_HTML.gif) | ![img/509649_1_En_6_Figdp_HTML.gif](img/509649_1_En_6_Figdp_HTML.gif) |

*授权矩阵为* *审核* *REST API*

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

操作

 | 

匿名的

 | 

用户

 | 

管理

 |
| --- | --- | --- | --- |
| 按产品 ID 获取评论 | ![img/509649_1_En_6_Figdq_HTML.gif](img/509649_1_En_6_Figdq_HTML.gif) | ![img/509649_1_En_6_Figdr_HTML.gif](img/509649_1_En_6_Figdr_HTML.gif) | ![img/509649_1_En_6_Figds_HTML.gif](img/509649_1_En_6_Figds_HTML.gif) |
| 按产品 ID 创建新评论 | ![img/509649_1_En_6_Figdt_HTML.gif](img/509649_1_En_6_Figdt_HTML.gif) | ![img/509649_1_En_6_Figdu_HTML.gif](img/509649_1_En_6_Figdu_HTML.gif) | ![img/509649_1_En_6_Figdv_HTML.gif](img/509649_1_En_6_Figdv_HTML.gif) |
| 按 ID 获取评论 | ![img/509649_1_En_6_Figdw_HTML.gif](img/509649_1_En_6_Figdw_HTML.gif) | ![img/509649_1_En_6_Figdx_HTML.gif](img/509649_1_En_6_Figdx_HTML.gif) | ![img/509649_1_En_6_Figdy_HTML.gif](img/509649_1_En_6_Figdy_HTML.gif) |
| 按 ID 删除评论 | ![img/509649_1_En_6_Figdz_HTML.gif](img/509649_1_En_6_Figdz_HTML.gif) | ![img/509649_1_En_6_Figea_HTML.gif](img/509649_1_En_6_Figea_HTML.gif) | ![img/509649_1_En_6_Figeb_HTML.gif](img/509649_1_En_6_Figeb_HTML.gif) |

### 实现安全层

我们将使用专用的身份存储来处理 QuarkuShop 用户的凭证。我们使用 Keycloak 来实现这个目的。

What is Keycloak?

Keycloak 是一个开源的身份和访问管理(IAM)解决方案，面向现代应用和服务。它使保护应用和服务变得很容易，只需要很少的代码，甚至不需要代码。

![img/509649_1_En_6_Figec_HTML.png](img/509649_1_En_6_Figec_HTML.png)

用户使用 Keycloak 进行身份验证，而不是使用单独的应用。这意味着您的应用不必处理登录表单、认证用户和存储用户。一旦登录到 Keycloak，用户无需再次登录即可访问不同的应用。这也适用于注销。

Keycloak 提供单点注销，这意味着用户只需注销一次，就可以从所有使用 Keycloak 的应用中注销。

Keycloak 基于标准协议，并提供对 OpenID Connect、OAuth 2.0 和 SAML 的支持。

如果基于角色的授权不能满足您的需求，Keycloak 还提供了细粒度的授权服务。这允许您从 Keycloak 管理控制台管理所有服务的权限，并赋予您准确定义所需策略的权力。

我们将分四步实施这一安全策略:

1.  准备和配置 Keycloak。

2.  在 QuarkuShop 中实现 auth <sup>**2**</sup> Java 组件。

3.  更新集成测试以支持授权 <sup>**2**</sup> 。

4.  向我们的生产环境添加 Keycloak。

#### 准备和配置钥匙锁

安全性实现的第一步是拥有一个 Keycloak 实例。本节逐步讨论如何创建和配置 Keycloak。

![img/509649_1_En_6_Figed_HTML.gif](img/509649_1_En_6_Figed_HTML.gif)很多教程里都有准备好的配置，可以导入到 Keycloak 里轻松上手。你不能在这里这样做。您将逐步执行所有需要的配置。这是最好的学习方法:边做边学。

首先在 Docker 容器中创建 Keycloak 实例:

*   ①默认情况下，没有创建`admin`用户，因此您将无法登录到`admin`控制台。要创建一个`admin`账户，您需要使用环境变量来传递初始用户名和密码。

*   ②使用`H2`作为 Keycloak 数据库。

*   ③列出暴露的端口。

*   ④这是基于 Keycloak 11.0.0。

```java
docker run -d --name docker-keycloak \
          -e KEYCLOAK_USER=admin \        ①
          -e KEYCLOAK_PASSWORD=admin \    ①
          -e DB_VENDOR=h2 \               ②
          -p 9080:8080 \                  ③
          -p 8443:8443 \                  ③
          -p 9990:9990 \                  ③
          jboss/keycloak:11.0.0           ④

```

打开`http://localhost:9080`进入欢迎页面:

![img/509649_1_En_6_Figee_HTML.jpg](img/509649_1_En_6_Figee_HTML.jpg)

接下来，单击“管理控制台”向控制台进行身份验证。使用`admin`凭证作为用户名和密码:

![img/509649_1_En_6_Figef_HTML.jpg](img/509649_1_En_6_Figef_HTML.jpg)

接下来，您需要创建一个新的*领域*。首先单击添加领域:

![img/509649_1_En_6_Figeg_HTML.png](img/509649_1_En_6_Figeg_HTML.png)

What is a Keycloak Realm?

一个*领域*是 Keycloak 中的核心概念。一个领域管理一组用户、凭据、角色和组。用户属于并登录到一个领域。领域相互隔离，只能管理和验证它们控制的用户。

当你第一次启动 Keycloak 时，它会为你创建一个预定义的领域。这个初始领域就是`master`领域。它是领域层级中的最高级别。该领域中的管理员帐户有权查看和管理在服务器实例上创建的任何其他领域。当您定义您的初始`admin`帐户时，您在`master`领域中创建了一个帐户。您首次登录管理控制台也将通过`master`领域。

接下来你将踏上创建新领域的第一步。调用领域`quarkushop-realm`然后点击创建:

![img/509649_1_En_6_Figeh_HTML.jpg](img/509649_1_En_6_Figeh_HTML.jpg)

接下来，您将看到`quarkushop-realm`配置页面:

![img/509649_1_En_6_Figei_HTML.jpg](img/509649_1_En_6_Figei_HTML.jpg)

在`quarkushop-realm`中，您需要定义您将使用的角色:`user`和`admin`角色。为此，只需转到角色➤Add 角色:

![img/509649_1_En_6_Figej_HTML.jpg](img/509649_1_En_6_Figej_HTML.jpg)

现在您可以创建`admin`角色:

![img/509649_1_En_6_Figek_HTML.jpg](img/509649_1_En_6_Figek_HTML.jpg)

创建`user`角色:

![img/509649_1_En_6_Figel_HTML.jpg](img/509649_1_En_6_Figel_HTML.jpg)

现在您已经创建了角色，您需要创建用户。只需进入用户菜单:

![img/509649_1_En_6_Figem_HTML.jpg](img/509649_1_En_6_Figem_HTML.jpg)

有时在这个屏幕上，当你打开页面时，用户列表并没有载入。如果发生这种情况，只需单击查看所有用户来加载列表。

单击 Add User 创建用户(在本例中为 Nebrass、Jason 和 Marie):

![img/509649_1_En_6_Figeo_HTML.jpg](img/509649_1_En_6_Figeo_HTML.jpg)

然后在单击 Save 之后，单击 Credentials 选项卡，您将在其中定义用户密码。

![img/509649_1_En_6_Figep_HTML.gif](img/509649_1_En_6_Figep_HTML.gif)不要忘记将`Temporary`设置为`OFF`以防止 Keycloak 在你第一次登录时要求你更新密码。然后，单击设置密码:

![img/509649_1_En_6_Figeq_HTML.jpg](img/509649_1_En_6_Figeq_HTML.jpg)

接下来，转到 Role Mappings 选项卡，将所有角色添加到 Nebrass 中。![img/509649_1_En_6_Figer_HTML.gif](img/509649_1_En_6_Figer_HTML.gif)是的！我将是这个应用的管理员。![img/509649_1_En_6_Figes_HTML.gif](img/509649_1_En_6_Figes_HTML.gif)

![img/509649_1_En_6_Figet_HTML.jpg](img/509649_1_En_6_Figet_HTML.jpg)

现在创建 Jason 用户并定义密码:

![img/509649_1_En_6_Figeu_HTML.jpg](img/509649_1_En_6_Figeu_HTML.jpg)

将用户角色添加到 Jason:

![img/509649_1_En_6_Figev_HTML.jpg](img/509649_1_En_6_Figev_HTML.jpg)

接下来，创建 Marie 用户并定义密码:

![img/509649_1_En_6_Figew_HTML.jpg](img/509649_1_En_6_Figew_HTML.jpg)

给 Marie 添加`user`角色:

![img/509649_1_En_6_Figex_HTML.jpg](img/509649_1_En_6_Figex_HTML.jpg)

您已完成角色和用户的配置！现在，单击“客户机”列出领域客户机。

![img/509649_1_En_6_Figey_HTML.jpg](img/509649_1_En_6_Figey_HTML.jpg)

What is a Realm Client?

客户端是可以请求 Keycloak 对用户进行身份验证的实体。大多数情况下，客户端是希望使用 Keycloak 来保护自己并提供单点登录解决方案的应用和服务。客户端也可以是只是想要请求身份信息或访问令牌的实体，以便它们可以安全地调用网络上由 Keycloak 保护的其他服务。

单击“创建”添加具有以下设置的新客户端:

![img/509649_1_En_6_Figez_HTML.jpg](img/509649_1_En_6_Figez_HTML.jpg)

*   客户端 ID: `quarkushop`

*   客户端协议:`openid-connect`

*   根 URL: `http://localhost:8080/`

单击保存以显示客户端配置屏幕:

![img/509649_1_En_6_Figfa_HTML.jpg](img/509649_1_En_6_Figfa_HTML.jpg)

必须为您的客户端定义一个协议映射器。

What is a Protocol Mapper?

*协议映射器*对令牌和文档执行转换。他们可以将用户数据映射到协议声明，并转换客户端和`auth`服务器之间的任何请求。

单击映射器选项卡以配置映射器:

![img/509649_1_En_6_Figfb_HTML.jpg](img/509649_1_En_6_Figfb_HTML.jpg)

然后单击创建以添加新的映射器:

![img/509649_1_En_6_Figfc_HTML.jpg](img/509649_1_En_6_Figfc_HTML.jpg)

![img/509649_1_En_6_Figfd_HTML.gif](img/509649_1_En_6_Figfd_HTML.gif) *为什么我们将*令牌声明名称*定义为组？*

我们将使用协议映射器将用户领域角色(可以是`user`或`admin`)映射到一个名为`groups`的属性，我们将把它作为一个普通字符串添加到 ID 令牌、访问令牌和 userinfo 中。

选择`groups`是基于 Quarkus SmallRye JWT 库的`MpJwtValidator` Java 类(这是用于管理 JWT 的 Quarkus 实现)；在这里，我们使用`jwtPrincipal.getGroups()`来定义`SecurityIdentity`角色:

```java
JsonWebToken jwtPrincipal = parser.parse(request.getToken().getToken());
uniEmitter.complete(
        QuarkusSecurityIdentity.builder().setPrincipal(jwtPrincipal)
            .addRoles(jwtPrincipal.getGroups())
            .addAttribute(SecurityIdentity.USER_ATTRIBUTE, jwtPrincipal)
            .build()
);

```

这就是为什么我们定义映射器来影响嵌入在 JWT 令牌中的用户组属性的用户角色。![img/509649_1_En_6_Figfe_HTML.gif](img/509649_1_En_6_Figfe_HTML.gif)

现在可以测试 Keycloak 实例是否按预期运行。只需使用`cURL`命令请求一个`access_token`:

```java
curl -X POST http://localhost:9080/auth/realms/quarkushop-realm/protocol/openid-connect/token \
      -H 'content-type: application/x-www-form-urlencoded' \
      -d 'client_id=quarkushop' \
      -d 'username=nebrass' \
      -d 'password=password' \
      -d 'grant_type=password' | jq '.'

```

![img/509649_1_En_6_Figff_HTML.gif](img/509649_1_En_6_Figff_HTML.gif)URL`http://localhost:9080/auth/realms/quarkushop-realm/protocol/openid-connect/token`由以下内容组成:

![img/509649_1_En_6_Figfg_HTML.gif](img/509649_1_En_6_Figfg_HTML.gif)

![img/509649_1_En_6_Figfh_HTML.gif](img/509649_1_En_6_Figfh_HTML.gif)`jq`是一个轻量级且灵活的命令行 JSON 处理器，我用它来格式化 JSON 输出。

您将得到如下的 JSON 响应:

```java
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJKcmlxWGQzYVBNOS13djhXUmVJekZkRnRJa3Z1WG5uNDd4a0JmTl95R19zIn0.eyJleHAiOjE1OTc0OTEwNTIsImlhdCI6MTU5NzQ5MDc1MiwianRpIjoiZmIxZmQxOWMtNWJlMC00YTgwLWExOTUtOTAxZjFkOTI3NDI5IiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo5MDgwL2F1dGgvcmVhbG1zL3F1YXJrdXNob3AtcmVhbG0iLCJhdWQiOiJhY2NvdW50Iiwic3ViIjoiMzU1ODc3YWQtMjY3Ny00ODJiLWE5NWYtYTI4ZjdmZGI1OTk5IiwidHlwIjoiQmVhcmVyIiwiYXpwIjoicXVhcmt1c2hvcCIsInNlc3Npb25fc3RhdGUiOiJjM2E4ZmU3Mi02MzRmLTRiNmUtYTZkMS03MTkyOGI2YTBlN2YiLCJhY3IiOiIxIiwiYWxsb3dlZC1vcmlnaW5zIjpbImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MCJdLCJyZWFsbV9hY2Nlc3MiOnsicm9sZXMiOlsib2ZmbGluZV9hY2Nlc3MiLCJhZG1pbiIsInVtYV9hdXRob3JpemF0aW9uIiwidXNlciJdfSwicmVzb3VyY2VfYWNjZXNzIjp7ImFjY291bnQiOnsicm9sZXMiOlsibWFuYWdlLWFjY291bnQiLCJtYW5hZ2UtYWNjb3VudC1saW5rcyIsInZpZXctcHJvZmlsZSJdfX0sInNjb3BlIjoiZW1haWwgcHJvZmlsZSIsImVtYWlsX3ZlcmlmaWVkIjp0cnVlLCJuYW1lIjoiTmVicmFzcyBMYW1vdWNoaSIsImdyb3VwcyI6WyJvZmZsaW5lX2FjY2VzcyIsImFkbWluIiwidW1hX2F1dGhvcml6YXRpb24iLCJ1c2VyIl0sInByZWZlcnJlZF91c2VybmFtZSI6Im5lYnJhc3MiLCJnaXZlbl9uYW1lIjoiTmVicmFzcyIsImZhbWlseV9uYW1lIjoiTGFtb3VjaGkiLCJlbWFpbCI6Im5lYnJhc3NAcXVhcmt1c2hvcC5zdG9yZSJ9.HZmicWhE9V8g74of9KGcZOVGvwC_oo2zs4-ElBBuV6XSWDUoiFLJVkSUzOV4WFzwvsM7V7_aZRzihZqq6QTtezweyhZIauo3pjmmtbMnq16WUFV-4oJWzk3P_6T5y74sh93aPuQtnw5hSQ4L68RjwQ6HIcaHJFkqrh6fX7uy0ZiHuPnRzhv38uQrD9YMC_z3tApWKTS2TA9igizZrlJCDfTdfiThUDuXEgOmw-pffYx1BASfL14O0c0apGPqirNkSgSrCpuFvikXlRdeu3YnI1JQ6S7Jn-qQI-bdCD5M0_ynaUiJn_p6sZqI6ioSmLGyA__S5J7nj_BO--fdIl0lUA",
  "expires_in": 300,
  "refresh_expires_in": 1800,
  "refresh_token": "...",
  "token_type": "bearer",
  "not-before-policy": 0,
  "session_state": "c3a8fe72-634f-4b6e-a6d1-71928b6a0e7f",
  "scope": "email profile"
}

```

![img/509649_1_En_6_Figfi_HTML.gif](img/509649_1_En_6_Figfi_HTML.gif)为了更漂亮的输出，我省略了`refresh_token`的值，因为它很长而且没用。

复制`access_token`值。然后去 [`jwt.io`](https://jwt.io) 把 JWT `access_token`贴在那里解码:

![img/509649_1_En_6_Figfj_HTML.jpg](img/509649_1_En_6_Figfj_HTML.jpg)

注意，有一个名为`groups`的 JSON 属性保存着我们在 Keycloak 中分配给 Nebrass 的 Roles 数组。

很好！Keycloak 运行正常，工作正常。现在，您将开始在 Java 端实现安全性。

#### 在 QuarkuShop 中实现 auth <sup>2</sup> Java 组件

##### Java 配置端

第一步是向 QuarkuShop 添加 Quarkus SmallRye JWT 依赖项:

```java

./mvnw quarkus:add-extension -Dextensions="io.quarkus:quarkus-smallrye-jwt"

```

接下来，将安全配置添加到`application.properties`:

*   ①启用 HTTP CORS 过滤器。

```java
1  ### Security
2  quarkus.http.cors=true  ①
3  # MP-JWT Config
4  mp.jwt.verify.issuer=http://localhost:9080/auth/realms/quarkushop-realm   ②
5  mp.jwt.verify.publickey.location=http://localhost:9080/auth/realms/quarkushop-realm/protocol/openid-connect/certs   ③
6  # Keycloak Configuration
7  keycloak.credentials.client-id=quarkushop   ④

```

What is CORS?

跨源资源共享(CORS)是一种机制，允许从提供第一资源的域之外的另一个域请求网页上的受限资源。

*   ② Config 属性指定服务器将接受为有效的 JWT 令牌的`iss`(颁发者)声明的值。我们已经在解密的 JWT 令牌的`iss`字段中获得了这个值。

*   ③ Config 属性允许指定公钥的外部或内部位置。该值可以是相对路径或 URL。当使用 Keycloak 作为身份管理器时，该值将是`mp.jwt.verify.issuer`加上`/protocol/openid-connect/certs`。

*   ④一个带有名为`keycloak.credentials.client-id`的键的自定义属性，它保存值`quarkushop`，这是领域客户端 ID。

##### Java 源代码端

在 Java 代码中，您需要根据我们为每个服务创建的授权矩阵来保护 REST APIs。

让我们从 Carts REST API 开始，其中所有操作都允许用户和管理员进行。Carts REST API 上只允许经过身份验证的主题。为了满足这个需求，我们从`io.quarkus.security`包中获得了一个`@Authenticated`注释，该注释将只授予经过身份验证的主体访问权限。

![img/509649_1_En_6_Figfl_HTML.gif](img/509649_1_En_6_Figfl_HTML.gif)为了区分*应用用户*和*角色用户*，我将应用用户称为*主体*。术语 subject 来自旧的 good Java 认证和授权服务(JAAS ),用来表示请求访问资源的调用者。主体可以是任何*实体*，包括作为*人*或*服务*。

因为`CartResource`中的所有操作都需要一个经过认证的主题，所以你必须用`@Authenticated`来注释`CartResource`类，这样它将被应用到所有的操作中。见清单 6-1 。

```java
@Authenticated
@Path("/carts")
@Tags(value = @Tag(name = "cart", description = "All the cart methods"))
public class CartResource {
    ...
}

Listing 6-1com.targa.labs.quarkushop.web.CartResource

```

下一个 REST API 是 Category API，只有管理员可以创建和删除类别。所有人(管理员、用户和匿名用户)都可以进行其他操作。要仅授予特定角色访问权限，请使用`javax.annotation.security`包中的`@RolesAllowed`注释。

![img/509649_1_En_6_Figfm_HTML.gif](img/509649_1_En_6_Figfm_HTML.gif)*JavaDoc of javax . annotation . security . roles allowed*

`@RolesAllowed`:指定允许访问应用中的方法的安全角色列表。

`@RolesAllowed`注释的值是安全角色名称的列表。可以在类或方法上指定此批注:

*   在类级别指定它意味着它适用于类中的所有操作。

*   在方法上指定它意味着它仅适用于该方法。

*   如果应用于类和操作级别，当两者冲突时，方法值将覆盖类值。

基于 JavaDoc，我们将传递期望的角色作为注释的值。将`@RolesAllowed("admin")`注释应用于创建和删除类别的操作:

```java
@Path("/categories")
@Tags(value = @Tag(name = "category", description = "All the category methods"))
public class CategoryResource {
    ...

    @RolesAllowed("admin")
    @POST
        public CategoryDto create(CategoryDto categoryDto) {
        return this.categoryService.create(categoryDto);
    }

    @RolesAllowed("admin")
    @DELETE
    @Path("/{id}")
    public void delete(@PathParam("id") Long id) {
        this.categoryService.delete(id);
    }
}

```

对于 Customer REST API，只有管理员可以访问所有的服务。用`@RolesAllowed("admin")`注释`CustomerResource`类将应用这个策略。

接下来是 Order REST API，通过身份验证的主体可以访问所有操作，除了`findAll()`方法，该方法只允许用于`admin`。因此，我们将类级别的两个`@Authenticated`注释和需要特定角色的方法上的`@RolesAllowed`注释结合起来:

```java
@Authenticated
@Path("/orders")
@Tag(name = "order", description = "All the order methods")
public class OrderResource {
    ...

    @RolesAllowed("admin")
    @GET
    public List<OrderDto> findAll() {
        return this.orderService.findAll();
    }
    ...
}

```

![img/509649_1_En_6_Figfn_HTML.gif](img/509649_1_En_6_Figfn_HTML.gif)当我们在本地方法中使用`@RolesAllowed`时，我们覆盖了类级别`@Authenticated`应用的策略。

在`OrderResource`之后，我们将处理 OrderItem REST API，其中只允许经过身份验证的主体访问所有服务。用`@Authenticated`注释`OrderItemResource`类将应用这个策略。

除了删除和列出所有付款仅授权给`admin`之外，`PaymentResource`仅授权给经过身份验证的主体访问:

```java
@Authenticated
@Path("/payments")
@Tag(name = "payment", description = "All the payment methods")
public class PaymentResource {
    ...

    @RolesAllowed("admin")
    @GET
    public List<PaymentDto> findAll() {
        return this.paymentService.findAll();
    }

    @RolesAllowed("admin")
    @DELETE
    @Path("/{id}")
    public void delete(@PathParam("id") Long id) {
        this.paymentService.delete(id);
    }
    ...
}

```

对于产品 REST API，除了创建和删除产品之外，所有人都可以执行所有操作，只有`admin`才可以执行这些操作:

```java
@Path("/products")
@Tag(name = "product", description = "All the product methods")
public class ProductResource {
    ...

    @RolesAllowed("admin")
    @POST
        public ProductDto create(ProductDto productDto) {
        return this.productService.create(productDto);
    }

    @RolesAllowed("admin")
    @DELETE
    @Path("/{id}")
    public void delete(@PathParam("id") Long id) {
        this.productService.delete(id);
    }
    ...
}

```

最后，最后一个 REST API 是`ReviewResource`:

```java
@Path("/reviews")
@Tag(name = "review", description = "All the review methods")
public class ReviewResource {
    ...

    @Authenticated
    @POST
    @Path("/product/{id}")
        public ReviewDto create(ReviewDto reviewDto, @PathParam("id") Long id) {
        return this.reviewService.create(reviewDto, id);
    }

    @RolesAllowed("admin")
    @DELETE
    @Path("/{id}")
    public void delete(@PathParam("id") Long id) {
        this.reviewService.delete(id);
    }
}

```

太好了。您已经应用了一级授权层！![img/509649_1_En_6_Figfo_HTML.gif](img/509649_1_En_6_Figfo_HTML.gif)

不过，不要太自信。![img/509649_1_En_6_Figfp_HTML.gif](img/509649_1_En_6_Figfp_HTML.gif)这个实现泄露了更多级别的授权。例如，用户被授权删除`Orders`或`OrderItems`，但是我们无法验证被认证的主体只是删除了自己的`Orders`或`OrderItems`，而没有删除其他用户的`Orders`或`OrderItems`。我们知道如何定义基于角色的访问规则，但是我们如何收集关于被认证主体的更多信息呢？

为此，我们将创建一个名为`UserResource`的新 REST API。当被调用时，`UserResource`将返回当前已验证的主题信息作为响应。

`UserResource`会是这样的:

*   ①注入一个`JsonWebToken`，它是定义使用 JWT 作为承载令牌的规范的实现。这个注入将在传入的请求中使用 JWT 令牌的一个实例。

*   ②`JsonWebToken`将返回注入的 JWT 令牌。

*   ③`getCurrentUserInfoClaims()`方法将返回可用声明的列表以及嵌入在 JWT 令牌中的它们各自的值。声明将从注入到`UserResource`中的 JWT 令牌实例中提取出来。

```java
@Path("/user")
@Authenticated
@Tag(name = " user", description = "All the user methods")
public class UserResource {

    @Inject
    JsonWebToken jwt;                                           ①

    @GET
    @Path("/current/info")
    public JsonWebToken getCurrentUserInfo() {                  ②
        return jwt;
    }

    @GET
    @Path("/current/info/claims")
    public Map<String, Object> getCurrentUserInfoClaims() {     ③
        return jwt.getClaimNames()
                .stream()
                .map(name -> Map.entry(name, jwt.getClaim(name)))
                .collect(Collectors.toMap(
                        entry -> entry.getKey(),
                        entry -> entry.getValue())
                );
    }
}

```

让我们测试这个新的 REST API。从获得新的`access_token`开始:

```java
export access_token=$(curl -X POST http://localhost:9080/auth/realms/quarkushop-realm/protocol/openid-connect/token \
      -H 'content-type: application/x-www-form-urlencoded' \
      -d 'client_id=quarkushop' \
      -d 'username=nebrass' \
      -d 'password=password' \
      -d 'grant_type=password' | jq --raw-output '.access_token')

```

然后，调用`/user/current/info` REST API:

```java
curl -X GET -H "Authorization: Bearer $access_token" http://localhost:8080/api/user/current/info | jq '.'

```

作为回应，您将获得 JWT 令牌:

```java
{
  "audience": [
    "account"
  ],
  "claimNames": [
    "sub", "resource_access", "email_verified", "allowed-origins", "raw_token", "iss",
    "groups", "typ", "preferred_username", "given_name", "aud", "acr", "realm_access",
    "azp", "scope", "name", "exp", "session_state", "iat", "family_name", "jti", "email"
  ],
  "expirationTime": 1597530481,
  "groups": ["offline_access", "admin", "uma_authorization", "user"],
  "issuedAtTime": 1597530181,
  "issuer": "http://localhost:9080/auth/realms/quarkushop-realm",
  "name": "nebrass",
  "rawToken": "eyJhbGci...L5A",
  "subject": "355877ad-2677-482b-a95f-a28f7fdb5999",
  "tokenID": "7416ee6e-e74c-45ae-bf85-8889744eaacf"
}

```

很好，我们有可用的索赔。让我们得到它们各自的值:

```java
{
  "sub": "355877ad-2677-482b-a95f-a28f7fdb5999",
  "resource_access": {
    "account": {
      "roles": ["manage-account", "manage-account-links", "view-profile"]
    }
  },
  "email_verified": true,
  "allowed-origins": ["http://localhost:8080"],
  "raw_token": "eyJhbGci...L5A",
  "iss": "http://localhost:9080/auth/realms/quarkushop-realm",
  "groups": ["offline_access", "admin", "uma_authorization", "user"],
  "typ": "Bearer",
  "preferred_username": "nebrass",
  "given_name": "Nebrass",
  "aud": ["account"],
  "acr": "1",
  "realm_access": {
    "roles": ["offline_access", "admin", "uma_authorization", "user"]
  },
  "azp": "quarkushop",
  "scope": "email profile",
  "name": "Nebrass Lamouchi",
  "exp": 1597530481,
  "session_state": "68069099-f534-434f-8d08-d8d75b8ff1c6",
  "iat": 1597530181,
  "family_name": "Lamouchi",
  "jti": "7416ee6e-e74c-45ae-bf85-8889744eaacf",
  "email": "nebrass@quarkushop.store"
}

```

太棒了！现在，您知道了如何访问安全细节，您可以使用这些细节来准确地识别经过身份验证的主题。顺便说一句，你可以得到关于 JWT 币的同样信息。你可以通过另一种方式获得同样的 JWT 代币:

```java
@GET()
@Path("/current/info-alternative")
public Principal getCurrentUserInfoAlternative(@Context SecurityContext ctx) {
    return ctx.getUserPrincipal();
}

```

作为方法参数传递的`@Context SecurityContext ctx`用于在当前上下文中注入`SecurityContext`。

![img/509649_1_En_6_Figfr_HTML.gif](img/509649_1_En_6_Figfr_HTML.gif) `SecurityContext`是一个可注入的接口，像`Principal`一样提供对安全相关信息的访问。

![img/509649_1_En_6_Figfs_HTML.gif](img/509649_1_En_6_Figfs_HTML.gif)`Principal`接口表示委托人的抽象概念，可以用来表示任何实体，比如个人、公司或登录 ID。在这种情况下，主体是 JWT 令牌。![img/509649_1_En_6_Figft_HTML.gif](img/509649_1_En_6_Figft_HTML.gif)

我不会深入研究授权层的完整实现。我就讲到这里；否则，我就需要花两章的时间来讨论这个内容。

安全部分的最后一步是添加一个 REST API，为给定的用户名和密码返回一个`access_token`。这可能很有用，尤其是对于 Swagger UI。说到 Swagger UI，我们需要让它知道我们的安全层。

我们将从创建`TokenService`开始，它将是从 Keycloak 发出`access_token`请求的 REST 客户端。

当我们使用 Java 11 时，我们可以享受它的一个伟大的新特性:全新的 HTTP 客户端。

正如您在使用`cURL`命令之前所做的那样，您需要使用 Java 11 HTTP 客户端来请求一个`access_token`:

*   ①注释为每个 HTTP 请求创建一个`TokenService`实例。

*   ②获取`mp.jwt.verify.issuer`属性值以构建 Keycloak 令牌的端点 URL。

*   ③获取请求`access_token`所需的`keycloak.credentials.client-id`属性值。

```java
@RequestScoped                              ①
public class TokenService {

    @ConfigProperty(name = "mp.jwt.verify.issuer", defaultValue = "undefined")
    Provider<String> jwtIssuerUrlProvider;  ②

    @ConfigProperty(name = "keycloak.credentials.client-id", defaultValue = "undefined")
    Provider<String> clientIdProvider;      ③

    public String getAccessToken(String userName, String password)
                        throws IOException, InterruptedException {

        String keycloakTokenEndpoint =
                    jwtIssuerUrlProvider.get() + "/protocol/openid-connect/token";

        String requestBody = "username=" + userName + "&password=" + password +
                    "&grant_type=password&client_id=" + clientIdProvider.get();

        if (clientSecret != null) {
            requestBody += "&client_secret=" + clientSecret;
        }

        HttpClient client = HttpClient.newBuilder().build();

        HttpRequest request = HttpRequest.newBuilder()
                .POST(BodyPublishers.ofString(requestBody))
                .uri(URI.create(keycloakTokenEndpoint))
                .header("Content-Type", "application/x-www-form-urlencoded")
                .build();

        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

        String accessToken = "";

        if (response.statusCode() == 200) {
            ObjectMapper mapper = new ObjectMapper();
            try {
                accessToken = mapper.readTree(response.body()).get("access_token").textValue();
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            throw new UnauthorizedException();
        }

        return accessToken;
    }
}

```

![img/509649_1_En_6_Figfv_HTML.gif](img/509649_1_En_6_Figfv_HTML.gif)我们将属性值设为`Provider<String>`而不是`String`，以避免本地映像构建失败。

接下来，添加`getAccessToken()`方法:

```java
@Path("/user")
@Authenticated
@Tag(name = " user", description = "All the user methods")
public class UserResource {

    @Inject JsonWebToken jwt;

    @POST
    @PermitAll
    @Path("/access-token")
    @Produces(MediaType.TEXT_PLAIN)
    public String getAccessToken(@QueryParam("username") String username,
                                @QueryParam("password") String password)
                        throws IOException, InterruptedException {
        return tokenService.getAccessToken(username, password);
    }
    ...
}

```

太棒了。您可以从 Swagger UI 测试新方法:

![img/509649_1_En_6_Figfx_HTML.jpg](img/509649_1_En_6_Figfx_HTML.jpg)

耶！![img/509649_1_En_6_Figfy_HTML.gif](img/509649_1_En_6_Figfy_HTML.gif)您现在需要找到一种方法让 Swagger UI 应用`access_token`来请求所有的 REST APIs。

我原以为这将是一次长途旅行，但这是一项非常容易的任务。仅仅 10 行代码就足以让聚会:![img/509649_1_En_6_Figfz_HTML.gif](img/509649_1_En_6_Figfz_HTML.gif)

*   ① `@SecurityScheme`定义了 OpenAPI 操作可以使用的安全方案。

*   ②添加 OpenAPI 定义的描述。

*   ③将创建的安全模式`jwt`链接到 OpenAPI 定义。

```java
@SecurityScheme(
        securitySchemeName = "jwt",             ①
        description = "JWT authentication with bearer token",
        type = SecuritySchemeType.HTTP,         ①
        in = SecuritySchemeIn.HEADER,           ①
        scheme = "bearer",                      ①
        bearerFormat = "Bearer [token]")        ①
@OpenAPIDefinition(
        info = @Info(                           ②
                title = "QuarkuShop API",
                description = "Sample application for the book 'Playing with Java Microservices with Quarkus and Kubernetes'",
                contact = @Contact(name = "Nebrass Lamouchi", email = "lnibrass@gmail.com", url = "https://blog.nebrass.fr"),
                version = "1.0.0-SNAPSHOT"
        ),
        security = @SecurityRequirement(name = "JWT") ③
)
public class OpenApiConfig extends Application {
}

```

再次检查 Swagger UI:

![img/509649_1_En_6_Figga_HTML.jpg](img/509649_1_En_6_Figga_HTML.jpg)

注意有锁图标![img/509649_1_En_6_Figgb_HTML.gif](img/509649_1_En_6_Figgb_HTML.gif)。

使用`getAccessToken()`操作创建一个`access_token`，然后点击【授权 将生成的`access_token`传递给`SecurityScheme`。最后，单击授权:

![img/509649_1_En_6_Figgd_HTML.jpg](img/509649_1_En_6_Figgd_HTML.jpg)

现在，当您单击任何操作时，Swagger UI 将包含`access_token`作为每个请求的载体。

太棒了！现在您已经有了 Keycloak 和安全性 Java 组件。接下来，您需要重构测试以了解安全层。

#### 更新集成测试以支持授权 <sup>`2`</sup>

对于测试，您需要动态地提供 Keycloak 实例，就像您使用`Testcontainers`库为数据库所做的那样。

我们将使用同一个库来提供 Keycloak。我们不会像使用 PostgreSQL 那样使用普通的 Docker 容器，因为在那里，Flyway 为我们填充了数据库。对于 Keycloak，我们没有一个内置的机制来为我们创建 Keycloak 领域。唯一可能的解决方案是使用 Docker Compose 文件，该文件将导入一个示例 Keycloak 领域文件。幸运的是，`Testcontainers`提供了对 Docker 编写文件的强大支持。

要使用`TestContainers`从 Docker 合成文件中提供容器，请使用:

```java
public static DockerComposeContainer KEYCLOAK = new DockerComposeContainer(
    new File("src/main/docker/keycloak-test.yml"))
       .withExposedService("keycloak_1", 9080,
           Wait.forListeningPort().withStartupTimeout(Duration.ofSeconds(30)));

```

我们将使用一个包含以下内容的示例 Keycloak 领域:

*   两个用户:
    *   管理员(用户名`admin`，密码`test`，角色`admin`

    *   测试(用户名`user`，密码`test`，角色`user`

*   Keycloak 客户端有一个`client-id=quarkus-client`:和``secret=mysecret`。

`QuarkusTestResourceLifecycleManager`将使用我们创建的`TokenService`与提供的 Keycloak 实例通信，并且它将使用示例领域凭证来获取我们将在集成测试中使用的`access_tokens`。

我们将得到两个`access_tokens`:一个用于`admin`角色，一个用于`user`角色。我们将把它们与`mp.jwt.verify.publickey.location`和`mp.jwt.verify.issuer`一起存储，作为当前测试范围中的系统属性。

自定义`QuarkusTestResourceLifecycleManager`将是这样的:

```java
public class KeycloakRealmResource implements QuarkusTestResourceLifecycleManager {
     @ClassRule
     public static DockerComposeContainer KEYCLOAK = new DockerComposeContainer(
           new File("src/main/docker/keycloak-test.yml"))
          .withExposedService("keycloak_1",
                    9080,
                    Wait.forListeningPort().withStartupTimeout(Duration.ofSeconds(30)));

       @Override
       public Map<String, String> start() {
              KEYCLOAK.start();

             String jwtIssuerUrl = String.format(
                    "http://%s:%s/auth/realms/quarkus-realm",
                    KEYCLOAK.getServiceHost("keycloak_1", 9080),
                    KEYCLOAK.getServicePort("keycloak_1", 9080)
             );

            TokenService tokenService = new TokenService();
            Map<String, String> config = new HashMap<>();
            try {
                 String adminAccessToken = tokenService.getAccessToken(jwtIssuerUrl,
                      "admin", "test", "quarkus-client", "mysecret"
                );

                String testAccessToken = tokenService.getAccessToken(jwtIssuerUrl,
                      "test", "test", "quarkus-client", "mysecret"
                );

               config.put("quarkus-admin-access-token", adminAccessToken);
               config.put("quarkus-test-access-token", testAccessToken);

           } catch (IOException | InterruptedException e) {
                  e.printStackTrace();
          }

          config.put("mp.jwt.verify.publickey.location", jwtIssuerUrl + "/protocol/openidconnect/certs");
          config.put("mp.jwt.verify.issuer", jwtIssuerUrl);

          return config;
      }

     @Override
      public void stop() {
              KEYCLOAK.stop();
     }
}

```

我们将把它和`@QuarkusTestResource(KeycloakRealmResource.class)`注释一起使用。

在`@BeforeAll`方法中，我们从系统属性中获取`access_tokens`,使它们准备好在测试中使用。一个典型的测试头骨看起来像这样:

```java
@QuarkusTest
@QuarkusTestResource(TestContainerResource.class)
@QuarkusTestResource(KeycloakRealmResource.class)
class CategoryResourceTest {

     static String ADMIN_BEARER_TOKEN;
     static String USER_BEARER_TOKEN;

     @BeforeAll
     static void init() {
       ADMIN_BEARER_TOKEN = System.getProperty("quarkus-admin-access-token");
       USER_BEARER_TOKEN = System.getProperty("quarkus-test-access-token");
    }

    ...
}

```

要在测试中使用这些令牌:

```java
@Test
void testFindAllWithAdminRole() {
   given().when()
          .header(HttpHeaders.AUTHORIZATION, "Bearer " + ADMIN_BEARER_TOKEN)
          .get("/carts")
          .then()
          .statusCode(OK.getStatusCode())
          .body("size()", greaterThan(0));
}

```

您需要在测试中测试和验证授权规则，例如，验证给定的概要文件不是`Unauthorized`:

```java
@Test
void testFindAll() {
    get("/carts").then()
          .statusCode(UNAUTHORIZED.getStatusCode());
}

```

要验证对于给定的请求，REST API 上不允许主题，请使用以下命令:

```java
@Test
void testDeleteWithUserRole() {
   given().when()
          .header(HttpHeaders.AUTHORIZATION, "Bearer " + USER_BEARER_TOKEN)
          .delete("/products/1")
          .then()
          .statusCode(FORBIDDEN.getStatusCode());
}

```

很好！我实现了所有的测试；你可以在我的 GitHub 库中找到它们。![img/509649_1_En_6_Figgf_HTML.gif](img/509649_1_En_6_Figgf_HTML.gif)

#### 将 Keycloak 添加到生产环境

最后一步是将生产 Keycloak 条目添加到生产虚拟机的 Docker Compose 中。我们还需要添加生产领域。

您可以通过非常少的步骤从本地 Keycloak 实例导出领域。

要从本地 Keycloak 容器(名为`docker-keycloak`)中导出领域，请使用以下命令:

```java
$docker exec -it docker-keycloak bash

bash-4.4$ cd /opt/jboss/keycloak/bin/

bash-4.4$ mkdir backup

bash-4.4$ ./standalone.sh -Djboss.socket.binding.port-offset=1000 \
      -Dkeycloak.migration.realmName=quarkushop-realm \
      -Dkeycloak.migration.action=export \
      -Dkeycloak.migration.provider=dir \
      -Dkeycloak.migration.dir=./backup/

```

要将存储的领域从`docker-keycloak`容器复制到本地目录，请使用以下命令:

```java
$ mkdir ~/keycloak-realms

$ docker cp docker-keycloak:/opt/jboss/keycloak/bin/backup ~/keycloak-realms

```

你将在`~/keycloak-realms`中获得两个钥匙锁王国文件——`quarkushop-realm-realm.json`和`quarkushop-realm-users-0.json`。

您需要编辑`quarkushop-realm-realm.json`文件并将`sslRequired`从`external`更改为`none`:

```java
{
    ...
    "sslRequired": "none",
    ...
}

```

![img/509649_1_En_6_Figgg_HTML.gif](img/509649_1_En_6_Figgg_HTML.gif)`"sslRequired": "none"`属性禁用任何请求所需的 SSL 证书。

然后，将两个文件——`quarkushop-realm-realm.json`和`quarkushop-realm-users-0.json`——复制到 Azure VM 实例中的`/opt/realms`目录，这是生产环境。

这是 Azure 虚拟机实例。![img/509649_1_En_6_Figgh_HTML.gif](img/509649_1_En_6_Figgh_HTML.gif)我们将完成最后一步:将 Keycloak 服务添加到`/opt/docker-compose.yml`文件中:

*   ①覆盖`MP_JWT_VERIFY_PUBLICKEY_LOCATION`和`MP_JWT_VERIFY_ISSUER`属性以确保应用指向 Azure VM 实例而不是`localhost`。

*   ②添加 Keycloak Docker 服务。

*   ③定义 Keycloak 集群的用户名和密码。

*   ④将 Keycloak 数据库供应商定义为 PostgreSQL，因为我们的服务中有一个 PostgreSQL DB 实例。

*   ⑤将 DB 主机定义为`postgresql-db`，由 Docker 用服务 IP 动态解析。

*   ⑥将 Keycloak 数据库凭据定义为与 PostgreSQL 凭据相同。

*   ⑦表示 Keycloak 和 PostgreSQL 服务之间的依赖关系。

```java
 1 version: '3'
 2 services:
 3   quarkushop:
 4     image: nebrass/quarkushop-monolithic-application:latest
 5     environment:
 6       - QUARKUS_DATASOURCE_JDBC_URL=jdbc:postgresql://postgresql-db:5432/demo
 7       -
  MP_JWT_VERIFY_PUBLICKEY_LOCATION=http://51.103.50.23:9080/auth/realms/quarkushoprealm/protocol/openid-connect/certs   ①
 8       - MP_JWT_VERIFY_ISSUER=http://51.103.50.23:9080/auth/realms/quarkushop-realm ①
 9    ports:
10      - 8080:8080
11   postgresql-db:
12     image: postgres:13
13     volumes:
14       - /opt/postgres-volume:/var/lib/postgresql/data
15     environment:
16       - POSTGRES_USER=developer
17       - POSTGRES_PASSWORD=p4SSW0rd
18       - POSTGRES_DB=demo
19       - POSTGRES_HOST_AUTH_METHOD=trust
20    ports:
21      - 5432:5432
22   keycloak:                                     ②
23     image: jboss/keycloak:latest
24     command:
25       [
26         '-b','0.0.0.0',
27
28         '-Dkeycloak.migration.action=import',
29         '-Dkeycloak.migration.provider=dir',
30         '-Dkeycloak.migration.dir=/opt/jboss/keycloak/realms',
31         '-Dkeycloak.migration.strategy=OVERWRITE_EXISTING',
32         '-Djboss.socket.binding.port-offset=1000',
33         '-Dkeycloak.profile.feature.upload_scripts=enabled',
34       ]
35
36
37   volumes:
38     - ./realms:/opt/jboss/keycloak/realms
39   environment:
40     - KEYCLOAK_USER=admin     ③
41     - KEYCLOAK_PASSWORD=admin ③
42     - DB_VENDOR=POSTGRES      ④
43     - DB_ADDR=postgresql-db   ⑤
44     - DB_DATABASE=demo        ⑥
45     - DB_USER=developer       ⑥
46     - DB_SCHEMA=public        ⑥
47     - DB_PASSWORD=p4SSW0rd    ⑥
48   ports:
49     - 9080:9080
50   depends_on:                 ⑦
51     - postgresql-db           ⑦

```

![img/509649_1_En_6_Figgi_HTML.gif](img/509649_1_En_6_Figgi_HTML.gif)如您所见，所有凭证都以纯文本形式列在`docker-compose.yml`文件中。

您可以使用 Docker 机密来保护这些凭证。每个密码都将存储在 Docker secret 中。

```java
docker service create --name POSTGRES_USER --secret developer
docker service create --name POSTGRES_PASSWORD --secret p4SSW0rd
docker service create --name POSTGRES_DB --secret demo
docker service create --name KEYCLOAK_USER --secret admin
docker service create --name KEYCLOAK_PASSWORD --secret admin

```

![img/509649_1_En_6_Figgj_HTML.gif](img/509649_1_En_6_Figgj_HTML.gif)遗憾的是，该功能仅适用于 Docker Swarm 集群。

为了保护凭证，将它们存储在 Azure VM 实例上的一个`~/.env`文件中:

```java
POSTGRES_USER=developer
POSTGRES_PASSWORD=p4SSW0rd
POSTGRES_DB=demo
KEYCLOAK_USER=admin
KEYCLOAK_PASSWORD=admin

```

然后，更改`docker-compose.yml`以使用`~/.env`元素:

```java
version: '3'
services:
   quarkushop:
     image: nebrass/quarkushop-monolithic-application:latest
     environment:
       - QUARKUS_DATASOURCE_JDBC_URL=jdbc:postgresql://postgresql-db:5432/${POSTGRES_DB}
       - MP_JWT_VERIFY_PUBLICKEY_LOCATION=http://51.103.50.23:9080/auth/realms/quarkushop-realm/protocol/openid-connect/certs
       - MP_JWT_VERIFY_ISSUER=http://51.103.50.23:9080/auth/realms/quarkushop-realm
     ports:
       - 8080:8080
   postgresql-db:
     image: postgres:13
     volumes:
       - /opt/postgres-volume:/var/lib/postgresql/data
     environment:
       - POSTGRES_USER=${POSTGRES_USER}
       - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
       - POSTGRES_DB=${POSTGRES_DB}
       - POSTGRES_HOST_AUTH_METHOD=trust
     ports:
       - 5432:5432
   keycloak:
     image: jboss/keycloak:latest
     command:
      [
       '-b',
       '0.0.0.0',
       '-Dkeycloak.migration.action=import',
       '-Dkeycloak.migration.provider=dir',
       '-Dkeycloak.migration.dir=/opt/jboss/keycloak/realms',
       '-Dkeycloak.migration.strategy=OVERWRITE_EXISTING',
       '-Djboss.socket.binding.port-offset=1000',
       '-Dkeycloak.profile.feature.upload_scripts=enabled',
      ]
     volumes:
       - ./realms:/opt/jboss/keycloak/realms
     environment:
       - KEYCLOAK_USER=${KEYCLOAK_USER}
       - KEYCLOAK_PASSWORD=${KEYCLOAK_PASSWORD}
       - DB_VENDOR=POSTGRES
       - DB_ADDR=postgresql-db
       - DB_DATABASE=${POSTGRES_DB}
       - DB_USER=${POSTGRES_USER}
       - DB_SCHEMA=public
       - DB_PASSWORD=${POSTGRES_PASSWORD}
     ports:
       - 9080:9080
     depends_on:
       - postgresql-db

```

很好！Docker 编写服务已经准备就绪！![img/509649_1_En_6_Figgk_HTML.gif](img/509649_1_En_6_Figgk_HTML.gif)

我们只需要为 Keycloak 端口的 Azure VM 实例网络规则添加一个例外。在 Azure VM 实例中，转到网络部分，为端口 9080 添加一个例外:

![img/509649_1_En_6_Figgl_HTML.jpg](img/509649_1_En_6_Figgl_HTML.jpg)

太棒了！![img/509649_1_En_6_Figgm_HTML.gif](img/509649_1_En_6_Figgm_HTML.gif)生产环境拥有部署新版本 QuarkuShop 容器所需的所有元素，而不会给 PostgreSQL 数据库或 Keycloak 集群带来风险。

转到生产 Swagger UI，享受 QuarkuShop:最伟大的在线商店！![img/509649_1_En_6_Figgn_HTML.gif](img/509649_1_En_6_Figgn_HTML.gif)

![img/509649_1_En_6_Figgo_HTML.jpg](img/509649_1_En_6_Figgo_HTML.jpg)

很好！![img/509649_1_En_6_Figgp_HTML.gif](img/509649_1_En_6_Figgp_HTML.gif)该进入下一个抗灾层了:*监控* ![img/509649_1_En_6_Figgq_HTML.gif](img/509649_1_En_6_Figgq_HTML.gif)。

## 实现监控层

安全性并不是应用中唯一重要的附加层。指标监控也是一个非常重要的层，可以防止灾难。想象一下这样一种情况，您在云中的服务器上部署了一个超级安全、功能强大的应用。如果您不定期检查应用指标，应用可能会在您不知道的情况下耗尽资源。

应用监控不仅仅是一种获取指标的机制；它包括分析不同组件的性能和行为。在本章中，我不会涵盖所有不同的监控工具和实践。

相反，您将看到如何实现两个组件:

*   应用状态指示器，也称为运行状况检查指示器。

*   应用指标服务，用于提供有关应用的各种指标和统计信息。

### 实施健康检查

在 Quarkus 中实现健康检查是一项非常简单的任务:只需添加 SmallRye 健康扩展。没错。你只要给`pom.xml`加一个库就行了！魔法会自动发生！

```java
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-smallrye-health</artifactId>
</dependency>

```

SmallRye Health 会自动将健康检查端点添加到您的 Quarkus 应用中。

对于那些习惯了 Spring Boot 的人来说，SmallRye Health 就相当于执行器。

新的*健康检查*终点是:

*   `/health/live`:应用启动并运行。

*   应用已经准备好服务请求。

*   `/health`:累积应用中的所有健康检查程序。

运行应用并在`http://localhost:8080/api/health`上执行`cURL` GET:

```java
curl -X GET http://localhost:8080/api/health | jq '.'

```

您将得到一个 JSON 响应:

```java
{
  "status": "UP",
  "checks": [
    {
      "name": "Database connections health check",
      "status": "UP"
    }
  ]
}

```

这个 JSON 响应确认应用正在正确运行，并且进行了一次检查，确认数据库是`UP`。

所有的 health REST 端点都返回一个简单的 JSON 对象，它有两个字段:

*   `status`:所有健康检查程序的总体结果

*   `checks`:单个支票的数组

Quarkus 开箱即用，包括一个数据库检查。让我们为 Keycloak 实例创建一个健康检查:

*   ①您获得了`mp.jwt.verify.publickey.location`属性，它将被用作 Keycloak URL。

*   ②你用 3000 毫秒的超时实例化 Java 11 `HTTPClient`。

*   ③您将健康检查的名称定义为`Keycloak connection health check`。

*   ④您验证了 Keycloak URL 是可访问的，并且响应状态代码是 HTTP 200。

*   ⑤如果`keycloakConnectionVerification()`抛出异常，健康检查状态将为`down`。

*   ⑥您构建健康检查响应并将其发送回调用者。

```java
@Liveness
@ApplicationScoped
public class KeycloakConnectionHealthCheck implements HealthCheck {

    @ConfigProperty(name = "mp.jwt.verify.publickey.location", defaultValue = "false")
    private Provider<String> keycloakUrl;                                 ①

    @Override
    public HealthCheckResponse call() {

        HealthCheckResponseBuilder responseBuilder =
                HealthCheckResponse.named("Keycloak connection health check");                               ③

        try {
            keycloakConnectionVerification();                             ④
            responseBuilder.up();                                         ⑤
        } catch (IllegalStateException e) {
            // cannot access keycloak
            responseBuilder.down().withData("error", e.getMessage());                                              ⑤
        }

        return responseBuilder.build();                                   ⑥
    }

    private void keycloakConnectionVerification() {
        HttpClient httpClient = HttpClient.newBuilder()                   ②
                .connectTimeout(Duration.ofMillis(3000))
                .build();

        HttpRequest request = HttpRequest.newBuilder()
                .GET()
                .uri(URI.create(keycloakUrl.get()))
                .build();

        HttpResponse<String> response = null;

        try {
            response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }

        if (response == null || response.statusCode() != 200) {
            throw new IllegalStateException("Cannot contact Keycloak");
        }
    }
}

```

让我们再来看一下`cURL`的`/health`终点:

```java
curl -X GET http://localhost:8080/api/health | jq '.'

```

新的 JSON 响应将是:![img/509649_1_En_6_Figgs_HTML.gif](img/509649_1_En_6_Figgs_HTML.gif)

```java
{
  "status": "UP",
  "checks": [
    {
      "name": "Keycloak connection health check",
      "status": "UP"
    },
    {
      "name": "Database connections health check",
      "status": "UP"
    }
  ]
}

```

很好！![img/509649_1_En_6_Figgt_HTML.gif](img/509649_1_En_6_Figgt_HTML.gif)就这么简单！

还有呢！SmallRye Health 在`http://localhost:8080/api/health-ui/`提供了一个非常有用的健康 UI:

![img/509649_1_En_6_Figgu_HTML.jpg](img/509649_1_En_6_Figgu_HTML.jpg)

甚至还有一个池服务，可以配置为按照您设置的时间间隔刷新页面:

![img/509649_1_En_6_Figgv_HTML.jpg](img/509649_1_En_6_Figgv_HTML.jpg)

这个健康用户界面非常有用，但不幸的是，在`prod`配置文件中它没有被默认激活。要为每个配置文件/环境启用它，请使用此属性:

```java
### Health Check
quarkus.smallrye-health.ui.always-include=true

```

太好了。为了实现*指标服务*，是时候进入下一步了。

### 实现度量服务

指标是重要且关键的监控数据。Quarkus 有许多用于度量公开的专用库，以及非常丰富的工具集来构建定制的应用度量。毫不奇怪，第一个库也来自 SmallRye 家族。它被称为`quarkus-smallrye-metrics`，用于公开基于微文件规范的度量。

从 Quarkus v1.9 开始，不推荐使用 SmallRye 度量。Quarkus 正式采用微米作为其度量的新标准。这种采用是基于云市场的趋势和需求。

![img/509649_1_En_6_Figgx_HTML.gif](img/509649_1_En_6_Figgx_HTML.gif)要了解更多关于从微轮廓度量到微米度量的转换，参见 [`https://quarkus.io/blog/micrometer-metrics/`](https://quarkus.io/blog/micrometer-metrics/) 。

实现度量服务的第一步是添加`quarkus-micrometer` Maven 依赖项:

```java
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-micrometer</artifactId>
</dependency>

```

这种依赖性将提供对千分尺核心度量类型的访问:

*   **计数器**:计数器用于测量只增加的数值。例如，测量调用 REST API 的次数。

*   **标尺**:显示当前值的指示器，如创建的对象或线程的数量。

*   **定时器**:用于测量短时潜伏期及其频率。

*   **分布汇总**:用于跟踪事件的分布。它在结构上类似于计时器，但记录的值不代表时间单位。例如，分布摘要可用于测量到达服务器的请求的有效负载大小。

所有这些对象都需要存储在某个地方，这就是*仪表注册表*的目的。As Micrometer 支持很多监控系统(Prometheus、Azure Monitor、Stackdriver、Datadog、Cloudwatch 等。)，我们会为`MeterRegistry`找一个专用的实现。在这个例子中，我们使用 Prometheus 作为监控系统。在这种情况下，您需要添加它的 Maven 依赖项:

```java
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>

```

现在，重启应用并检查 Quarkus Micrometer 生成的`http://localhost:8080/metrics` URL:

```java
# HELP jvm_threads_live_threads The current number of live threads including both daemon and non-daemon threads
# TYPE jvm_threads_live_threads gauge
jvm_threads_live_threads 64.0
# HELP jvm_memory_max_bytes The maximum amount of memory in bytes that can be used for memory management
# TYPE jvm_memory_max_bytes gauge
jvm_memory_max_bytes{area="nonheap",id="CodeHeap 'profiled nmethods'",} 1.63971072E8
jvm_memory_max_bytes{area="heap",id="G1 Survivor Space",} -1.0
jvm_memory_max_bytes{area="heap",id="G1 Old Gen",} 8.589934592E9
jvm_memory_max_bytes{area="nonheap",id="Metaspace",} -1.0
jvm_memory_max_bytes{area="nonheap",id="CodeHeap 'non-nmethods'",} 7598080.0
jvm_memory_max_bytes{area="heap",id="G1 Eden Space",} -1.0
jvm_memory_max_bytes{area="nonheap",id="Compressed Class Space",} 1.073741824E9
jvm_memory_max_bytes{area="nonheap",id="CodeHeap 'non-profiled nmethods'",} 1.63975168E8
...

```

这些指标由 Micrometer 生成，与 Prometheus 兼容。您可以尝试在独立的 Prometheus 实例中导入它们。

先从 [`https://prometheus.io/download/`](https://prometheus.io/download/) 下载普罗米修斯:

![img/509649_1_En_6_Figgy_HTML.png](img/509649_1_En_6_Figgy_HTML.png)

为您的机器/操作系统选择合适的版本并下载。对我来说是`darwin-amd64`。

解压缩档案后，编辑`prometheus-2.27.0.darwin-amd64/prometheus.yml`文件，如下所示:

```java
# my global config
global:
  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.
...
scrape_configs:
  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
  - job_name: 'prometheus'

    # metrics_path defaults to '/metrics'
    # scheme defaults to 'http'.

    static_configs:
    - targets: ['localhost:9090']

```

将定义目标`/metrics` API 主机位置的最后一行从`localhost:9090`改为`localhost:8080`。这是*应用 URL* 。

运行普罗米修斯:

```java
$ ./prometheus

...msg="Start listening for connections" address=0.0.0.0:9090

```

您可以从`http://localhost:9090/`访问它:

![img/509649_1_En_6_Figgz_HTML.png](img/509649_1_En_6_Figgz_HTML.png)

在表达式输入中，输入`system_cpu_usage`并点击执行。然后单击图表选项卡:

![img/509649_1_En_6_Figha_HTML.png](img/509649_1_En_6_Figha_HTML.png)

现在，您可以为`TokenService`创建自己的定制应用指标提供者:

*   ①为执行`getAccessToken()`方法的持续时间创建一个名为`tokensRequestsTimer`的计时器。

*   ②创建一个名为`tokensRequestsCounter`的计数器，它将在每次调用`getAccessToken()`方法时递增。

```java
@Slf4j
@RequestScoped
public class TokenService {
    private static final String TOKENS_REQUESTS_TIMER = "tokensRequestsTimer";     ①
    private static final String TOKENS_REQUESTS_COUNTER = "tokensRequestsCounter";   ②

    @Inject MeterRegistry registry;
    ...
    @PostConstruct
    public void init() {
        registry.timer(TOKENS_REQUESTS_TIMER, Tags.empty());             ①
        registry.counter(TOKENS_REQUESTS_COUNTER, Tags.empty());         ②
    }

    public String getAccessToken(String userName, String password) {
        var timer = registry.timer(TOKENS_REQUESTS_TIMER);               ①
        return timer.record(() -> { var accessToken = "";
            try {
                accessToken = getAccessToken(jwtIssuerUrlProvider.get(),
                                userName, password, clientIdProvider.get(), null);
                registry.counter(TOKENS_REQUESTS_COUNTER).increment();   ②
            } catch (IOException e) { log.error(e.getMessage());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                log.error("Cannot get the access_token");
            }
            return accessToken;
        });
    }
    ...
}

```

转到 Swagger UI 并多次请求一个`access_token`来生成一些指标。然后返回到 Prometheus UI 检查新的指标:

![img/509649_1_En_6_Fighb_HTML.png](img/509649_1_En_6_Fighb_HTML.png)

根据前面的截图，看看`tokensRequestsCounter`达到的值。它的普罗米修斯表达式是:

![img/509649_1_En_6_Fighc_HTML.png](img/509649_1_En_6_Fighc_HTML.png)

您可以检查`tokensRequests`计时器的最大值，它与 Prometheus 中的`tokensRequestsTimer_seconds_max`表达式相匹配:

![img/509649_1_En_6_Fighd_HTML.png](img/509649_1_En_6_Fighd_HTML.png)

太好了。现在，您已经拥有了基本的运行状况检查和监控组件，可以确保您的应用运行良好，并拥有所有必需的资源。

## 结论

我认为安全和监控是抗灾难层，但即使应用了这些组件，应用仍然面临许多风险。其中之一就是高可用性。*****