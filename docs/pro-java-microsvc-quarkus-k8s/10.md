# 10.满足微服务的需求和模式

当我们处理架构和设计时，我们立即开始考虑配方和模式。这些设计模式对于在云中构建可靠、可伸缩、安全的应用程序非常有用。

一个*模式*是一个在特定环境中出现的问题的可重用解决方案。这是一个源于现实世界架构的想法，已经被证明在软件架构和设计中是有用的。

实际上，微服务架构是最强大的架构模式之一。我们在第 [8](08.html) 章中详细讨论了这种模式。

当呈现一个模式时，我们从定义上下文和问题开始，然后提供模式给出的解决方案。

## 云图案

本章讨论这些模式:

*   外部化配置

*   服务发现和注册

*   断路器

*   每个服务的数据库

*   API 网关

*   CQRS(消歧义)

*   活动采购

*   日志聚合

*   分布式跟踪

*   审核日志记录

*   应用指标

*   运行状况检查 API

### 服务发现和注册

#### 背景和问题

在微服务领域，服务注册和发现扮演着重要的角色，因为您很可能会运行多个服务实例，并且需要一种机制来调用其他服务，而无需硬编码它们的主机名或端口号。除此之外，在云环境中，服务实例可能随时增加和减少。所以你需要一个自动的服务注册和发现机制。

在一个单一的应用程序中，组件之间的调用是通过语言级别的调用进行的。但是，在微服务架构中，服务通常需要使用 REST(或其他)调用来相互调用。为了发出请求，服务需要知道给定服务实例的网络位置(IP 地址和端口)。如前几章所述，微服务会动态分配网络位置。这是由许多因素造成的，例如不同的部署频率。此外，一个服务可以有多个实例，由于自动伸缩、失败等原因，这些实例可以动态地保持变化。

因此，您必须实现一种机制，使给定服务的客户端能够向一组动态变化的服务实例发出请求。

服务的客户端如何发现服务实例的位置？服务的客户端如何知道服务的可用实例？

#### 解决办法

您可以创建服务注册中心，它是可用服务实例的数据库。它是这样工作的:

*   微服务实例的网络位置在实例启动时向服务注册中心注册。

*   当实例终止时，微服务实例的网络位置将从服务注册表中删除。

*   微服务实例的可用性通常使用心跳机制定期刷新。

这种模式有两种类型:

*   **客户端发现模式**:请求服务(客户端)负责寻找可用服务实例的网络位置。客户端查询服务注册中心，然后使用一些负载平衡算法选择一个可用的服务实例并发出请求。这种机制遵循客户端发现模式。

*   **服务器端发现模式**:服务器端发现模式建议客户端通过负载均衡器向服务发出请求。负载平衡器负责查询服务注册中心，并将每个请求转发给可用的服务实例。因此，如果您想要遵循这种模式，您需要拥有(或实现)一个负载平衡器。

### 外部化配置

#### 背景和问题

应用程序通常使用一个或多个基础设施(消息代理和数据库服务器等。)和第三方服务(支付网关、电子邮件和消息等)。).这些服务需要配置信息(例如凭证)。此配置信息存储在与应用程序一起部署的文件中。

在某些情况下，可以在部署后编辑这些文件来改变应用程序的行为。但是，更改配置需要重新部署应用程序，这通常会导致不可接受的停机时间和其他管理开销。

本地配置文件还将配置限制到单个应用程序，有时在多个应用程序之间共享配置设置会很有用。示例包括数据库连接字符串以及相关应用程序集使用的队列和存储的 URL。

我们的整体被分成许多微服务。所有这些微服务都需要提供给 monolith 的配置信息。假设我们需要更新数据库的 URL。所有微服务都需要完成此任务。如果我们忘记在某个地方更新数据，可能会导致在部署更新时实例使用不同的配置设置。

#### 解决办法

将所有应用程序配置具体化，包括数据库凭证和网络位置。例如，您可以在外部存储配置信息，并提供一个可用于快速有效地读取和更新配置设置的界面。您可以将这个配置存储称为*配置服务器。*

当微服务启动时，它从给定的配置服务器中读取配置。

### 断路器

#### 背景和问题

微服务主要使用 HTTP REST 请求进行通信。当一个微服务与另一个同步时，总是存在另一个服务由于高延迟而不可用或不可达的风险，这意味着它本质上是不可用的。这些不成功的调用可能会导致资源耗尽，这将使调用服务无法处理其他请求。一个服务的失败可能会影响整个应用程序中的其他服务。

#### 解决办法

发出请求的微服务应该通过代理调用远程服务，代理的工作机制类似于电路断路器。当连续失败的次数超过阈值时，断路器跳闸，并且在超时期间，所有调用远程服务的尝试都将立即失败。超时后，断路器允许有限数量的测试请求通过。如果这些请求成功，断路器恢复正常运行。如果出现故障，超时时间将重新开始。

断路器模式，由迈克尔·尼加德在他的书*中推广开来！，*可以防止应用程序反复尝试执行可能失败的操作。这允许应用程序继续运行，而无需等待故障被修复或浪费 CPU 周期，同时确定故障是长期持续的。断路器模式还使应用程序能够检测故障是否已经解决。如果问题似乎已经解决，应用程序可以尝试调用操作。

### 每个服务的数据库

#### 背景和问题

在微服务架构世界中，服务必须是松散耦合的，这样它们才能独立开发、部署和扩展。

大多数服务需要将数据保存在某种数据库中。在我们的应用程序中，`Order Service`存储订单信息，`Customer Service`存储客户信息。

微服务应用中的数据库架构是什么？

#### 解决办法

将每个微服务的持久数据保持为该服务私有，并且只能通过其 API 访问。

该服务的数据库实际上是该服务实现的一部分。其他服务不能直接访问它。

有几种不同的方法可以使服务的持久数据保持私有。您不需要为每个服务提供一个数据库服务器。例如，如果您使用关系数据库，选项如下:

*   每个服务拥有一组只能由该服务访问的表。

*   每个服务都有一个专用于该服务的数据库模式。

*   每个服务都有自己的数据库服务器。

`Private-tables-per-service`和`schema-per-service`开销最低。为每个服务使用一个模式很有吸引力，因为它使所有权更加清晰。一些高吞吐量服务可能需要自己的数据库服务器。

创建壁垒来加强这种模块化是一个好主意。例如，您可以为每个服务分配不同的数据库用户 ID，并使用数据库访问控制机制，比如 grants。如果没有某种强制封装的障碍，开发人员总是会试图绕过服务的 API，直接访问其数据。

### 应用编程接口网关

#### 背景和问题

对于 QuarkuShop 精品店，假设您正在实现产品详细信息页面。假设您需要开发多个版本的产品详细信息用户界面:

*   **基于 HTML5/JavaScript 的桌面和移动浏览器 UI**:HTML 由服务器端 web 应用生成。

*   本地 Android 和 iPhone 客户端:这些客户端通过 REST APIs 与服务器交互。

此外，QuarkuShop 必须通过 REST API 公开产品细节，供第三方应用程序使用。

产品详细信息 UI 可以显示关于产品的大量信息。例如:

*   产品的基本信息，如名称、描述、价格等。

*   您的产品购买历史。

*   可用性。

*   购买期权。

*   经常与本产品一起购买的其他物品。

*   购买该产品的顾客购买的其他物品。

*   顾客评论。

因为 QuarkuShop 遵循微服务架构模式，所以产品细节数据分布在多个服务上:

*   **产品服务**:产品的基本信息，如名称、描述、价格、客户评论和产品可用性。

*   **订单服务**:产品的购买历史。

*   **QuarkuShop:** 顾客、推车等。

因此，显示产品详细信息的代码需要从所有这些服务中获取信息。

基于微服务的应用程序的客户端如何访问单个服务？

#### 解决办法

实现一个 API 网关，它是所有客户端的单一入口点。API 网关以两种方式之一处理请求。一些请求被简单地代理/路由到适当的服务。它通过分散到多个服务来处理其他请求。

API 网关可以为每个客户端提供不同的 API，而不是提供一种通用的 API。API 网关还可以实现安全性，例如验证客户端是否被授权执行请求。

### CQRS(消歧义)

#### 背景和问题

在传统的数据管理系统中，命令(数据更新)和查询(数据请求)都是针对单个数据存储库中的同一组实体执行的。这些实体可以是关系数据库(如 SQL Server)中一个或多个表中行的子集。

通常在这些系统中，所有创建、读取、更新和删除(CRUD)操作都应用于实体的相同表示。例如，代表客户的数据传输对象(DTO)由数据访问层(DAL)从数据存储中检索并显示在屏幕上。用户更新 DTO 的一些字段(可能通过数据绑定)，然后 DAL 将 DTO 保存回数据存储中。相同的 DTO 用于读取和写入操作。

当只有有限的业务逻辑应用于数据操作时，传统的 CRUD 设计工作得很好。开发工具提供的支架机制可以非常快速地创建数据访问代码，然后可以根据需要定制这些代码。

然而，传统的 CRUD 方法有一些缺点:

*   这通常意味着数据的读写表示之间存在不匹配，例如必须正确更新的附加列或属性，即使它们不是操作的一部分。

*   当记录被锁定在协作域中的数据存储中时，存在数据争用的风险，在协作域中，多个参与者对同一组数据进行并行操作。当使用乐观锁定时，由并发更新引起的更新冲突也是一个问题。随着系统复杂性和吞吐量的增加，这些风险也会增加。此外，由于数据存储和数据访问层的负载，以及检索信息所需的复杂查询，传统方法可能会对性能产生负面影响。

*   这可能会使管理安全性和权限变得更加复杂，因为每个实体都受到读和写操作的影响，这可能会在错误的上下文中公开数据。

#### 解决办法

命令和查询责任分离(CQRS)是一种模式，它通过使用不同的接口将读取数据(查询)的操作与更新数据(命令)的操作分离开来。这意味着用于查询和更新的数据模型是不同的。然后可以隔离这些模型。

与基于 CRUD 的系统中使用的单一数据模型相比，在基于 CQRS 的系统中为数据使用单独的查询和更新模型简化了设计和实现。然而，一个缺点是，与 CRUD 设计不同，CQRS 代码不能使用支架机制自动生成。

用于读取数据的查询模型和用于写入数据的更新模型可以访问同一个物理存储，这可能是通过使用 SQL 视图或动态生成投影来实现的。

读取存储可以是写入存储的只读副本，或者读取和写入存储可以具有完全不同的结构。使用读取存储的多个只读副本可以大大提高查询性能和应用程序 UI 响应能力，尤其是在只读副本位于应用程序实例附近的分布式方案中。

### 活动采购

#### 背景和问题

大多数应用程序处理数据，典型的方法是应用程序通过在用户处理数据时更新数据来维护数据的当前状态。例如，在传统的创建、读取、更新和删除(CRUD)模型中，典型的数据流程是从存储中读取数据，对其进行一些修改，并用新值更新数据的当前状态—通常是通过使用锁定数据的事务。

CRUD 方法有一些限制:

*   CRUD 系统直接对数据存储执行更新操作，这会降低性能和响应速度，并限制可伸缩性，因为这需要处理开销。

*   在有许多并发用户的协作域中，数据更新冲突更有可能发生，因为更新操作发生在单个数据项上。

*   除非有额外的审计机制在单独的日志中记录每个操作的细节，否则历史就会丢失。

#### 解决办法

Event Sourcing 模式定义了一种处理由一系列事件驱动的数据操作的方法，每个事件都记录在一个只加存储中。应用程序代码将一系列事件发送到事件存储区，这些事件强制性地描述了数据上发生的每个操作，事件存储区保存了这些事件。每个事件代表一组数据的变化(比如`AddedItemToOrder`)。

事件保存在事件存储中，事件存储充当有关数据当前状态的记录系统(权威数据源)。事件存储通常会发布这些事件，以便用户可以得到通知，并在需要时处理它们。例如，消费者可以启动将事件中的操作应用到其他系统的任务，或者执行完成操作所需的任何其他相关操作。请注意，生成事件的应用程序代码与订阅事件的系统是分离的。

事件存储发布的事件的典型用途是在应用程序中的操作改变实体的物化视图时维护它们，以及与外部系统集成。例如，系统可以维护所有客户订单的物化视图，该视图用于填充部分 UI。当应用程序添加新订单、添加或删除订单上的项目以及添加运输信息时，描述这些更改的事件可以被处理并用于更新物化视图。

此外，在任何时候，应用程序都可以读取事件的历史，并通过回放和使用与该实体相关的所有事件来使用它来具体化该实体的当前状态。这可以根据需要在处理请求时具体化一个域对象，也可以通过一个调度任务来实现，以便实体的状态可以存储为一个物化视图来支持表示层。

### 日志聚合

#### 背景和问题

在微服务架构中，我们的应用程序由运行在不同服务器和位置上的多个服务和服务实例组成。请求经常跨越多个服务实例。

当我们使用 monolith 时，应用程序生成一个日志流，它通常存储在一个日志文件/目录中。现在，每个服务实例都生成自己的日志文件。

当日志以这种方式分割时，如何识别应用程序的行为并解决问题？

#### 解决办法

使用集中的日志记录服务，该服务聚合来自每个服务实例的日志。当日志被聚集时，用户可以搜索和分析日志。他们可以配置当日志中出现某些消息时触发的警报。

### 分布式跟踪

#### 背景和问题

在微服务架构中，请求通常跨越多个服务。每个服务通过执行一个或多个操作来处理请求，例如数据库查询、消息发布等。

当请求失败时，您如何识别行为并解决问题？

#### 解决办法

具有以下代码的仪表服务:

*   为每个外部请求分配一个唯一的外部请求 ID

*   将外部请求 ID 传递给处理请求所涉及的所有服务

*   在所有日志消息中包含外部请求 ID

*   记录关于在集中式服务中处理外部请求时所执行的请求和操作的信息(例如，开始时间和结束时间)

### 审核日志记录

#### 背景和问题

在微服务架构中，除了日志系统之外，我们还需要更多关于服务的可见性，以监控事情的进展。

您如何监控用户和应用程序的行为并解决任何问题？

#### 解决办法

您可以在数据库或一些特殊的专用日志系统中记录用户活动。

### 应用指标

#### 背景和问题

在微服务架构中，除了我们已经拥有的指标之外，我们还需要更多关于服务的可见性，以了解正在发生的事情。

你如何识别和阐明一个应用程序的行为？

#### 解决办法

推荐的解决方案是拥有一个集中的度量服务，该服务收集和存储每个服务操作的决策支持统计信息。微服务可以将它们的度量信息推送到度量服务。另一方面，指标服务可以从微服务中提取指标。

### 运行状况检查 API

#### 背景和问题

监控 web 应用程序和后端服务是一个很好的实践，通常也是一个业务需求，目的是确保它们可用并正常运行。然而，监控云中运行的服务比监控内部服务更困难。有许多因素会影响应用程序，例如网络延迟、底层计算和存储系统的性能和可用性以及网络带宽。这些因素中的任何一个都可能导致服务完全或部分失败。因此，您必须定期验证服务是否正常运行，以确保所需的可用性级别。

#### 解决办法

通过向应用程序上的端点发送请求来实现健康监控。应用程序应该执行必要的检查，并返回其状态指示。

健康监控检查通常结合了两个因素:

*   应用程序或服务为响应对健康验证端点的请求而执行的检查(如果有)。

*   通过执行运行状况验证检查的工具或框架对结果进行分析。

响应代码指示应用程序的状态，并且可选地指示它使用的任何组件或服务的状态。延迟或响应时间检查由监控工具或框架执行。

### 服务之间的安全性:访问令牌

#### 背景和问题

在微服务架构中，通过使用 API 网关模式，应用程序由许多服务组成。API 网关是客户端请求的单一入口点。它对请求进行身份验证，并将它们转发给其他服务，这些服务可能会调用其他服务。

如何将请求者的身份传达给处理请求的服务？

#### 解决办法

API 网关对请求进行认证，并将访问令牌(例如，JSON web 令牌)传递给服务，该令牌安全地标识每个请求中的请求者。服务可以在向其他服务发出的请求中包含访问令牌。

## 结论

既然您已经拆分了 QuarkuShop monolith 并了解了一些有用的模式，那么您可以开始构建独立的微服务了。