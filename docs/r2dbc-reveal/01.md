# 1.反应式编程的案例

在软件工程界，时髦的技术是再熟悉不过的了。多年来，一些最具创造力的头脑给了我们开发创新，彻底改变了我们解决方案的面貌。另一方面，从长远来看，一些趋势性技术给我们带来了更多的痛苦。所有的炒作可能很难评估。

在第一章中，我想介绍一下几年来越来越受欢迎的*反应式编程*的范例，并帮助为我们进入反应式关系数据库连接(R2DBC)的想法奠定基础。

既然你正在读这本书，我将假设你在这之前可能至少听过或读过“反应式”和“编程”这两个词。见鬼，我甚至可以大胆地猜测，你可能听说过或读到过，为了创造一个真正的反应式解决方案，你需要反应式地思考。但是所有这些意味着什么呢？好吧，让我们来看看！

## 传统的方法

引入新技术可能具有挑战性，但我发现它有助于识别我们作为开发人员遇到的常见的真实用例，并了解它如何适应该环境。

想象一个包含客户端应用程序和服务器应用程序之间的 web 请求工作流的基本解决方案，让我们从客户端向服务器发起异步请求的地方开始。

Note

当某件事情发生*异步*时，这意味着在同一个系统内相互作用的两个或多个事件/对象之间存在关系，但不是以预定的间隔发生，也不一定依赖于彼此的存在才能发挥作用。更简单的说，就是相互不协调，同时发生的事件。

收到请求后，服务器启动一个新线程进行处理(图 [1-1](#Fig1) )。

![../images/504354_1_En_1_Chapter/504354_1_En_1_Fig1_HTML.png](../images/504354_1_En_1_Chapter/504354_1_En_1_Fig1_HTML.png)

图 1-1

从客户端到服务器执行简单的同步 web 请求

很简单，而且可以运行，所以发货吧，对吗？别这么快！请求很少会如此简单。可能是这样的情况，如图 [1-2](#Fig2) 所示，服务器线程需要访问数据库来完成客户端请求的工作。但是，在访问数据库时，服务器线程会等待，从而阻止执行更多的工作，直到数据库返回响应。

![../images/504354_1_En_1_Chapter/504354_1_En_1_Fig2_HTML.png](../images/504354_1_En_1_Chapter/504354_1_En_1_Fig2_HTML.png)

图 1-2

当数据库返回响应时，服务器线程被阻止执行工作

不幸的是，这可能不是最佳解决方案，因为没有办法知道数据库调用需要多长时间。这不太可能扩大规模。因此，为了优化客户端的时间并保持其工作，您可以添加更多的线程来并行处理多个请求，如图 [1-3](#Fig3) 所示。

![../images/504354_1_En_1_Chapter/504354_1_En_1_Fig3_HTML.png](../images/504354_1_En_1_Chapter/504354_1_En_1_Fig3_HTML.png)

图 1-3

后续传入的请求使用附加线程进行处理

现在我们在做饭！您可以继续添加线程来处理额外的处理，对吗？没那么快。就像生活中的大多数事情一样，如果有些事情看起来好得不像真的，那么它很可能就是真的。添加额外线程的代价是令人讨厌的问题，如更高的资源消耗，可能导致吞吐量降低，并且在许多情况下，由于线程上下文管理，增加了开发人员的复杂性。

Note

对于许多应用程序，使用多线程将是一个可行的解决方案。反应式编程不是银弹。然而，反应式解决方案有助于更有效地利用资源。请继续阅读，了解如何操作！

## 命令式编程与声明式编程

使用多线程来防止阻塞操作是*命令式*编程范例和语言中的一种常见方法。这是因为命令式方法是一个过程，它一步一步地描述了一个程序为了完成一个特定的目标应该处于的状态。最终，命令式进程依赖于对信息流的控制，这在某些情况下非常有用，但是正如我之前提到的那样，也会给内存和线程管理带来相当大的麻烦。

另一方面，声明式编程并不关注如何实现一个特定的目标，而是关注目标本身。但这是相当模糊的，所以让我们后退一点。

考虑以下类比:

*   **命令式编程**就像上美术课，听老师一步一步地指导你如何画风景。

*   **声明式编程**就像上艺术课，被告知要画一幅风景。老师不在乎你怎么做，只在乎你把它做完。

Tip

命令式和声明式编程范例都有优点和缺点。像任何任务一样，确保你选择了正确的工具！

对于这本书，我将在所有的例子中使用 Java 编程语言。现在，众所周知，Java 是一种命令式语言，因此它的重点是如何实现最终结果。也就是说，我们很容易想象如何使用 Java 编写命令式指令，但您可能不知道的是，您也可以编写声明式流。例如，考虑以下情况。

这里有一个从 1 到 10 逐步求和一系列数字的必要方法:

```
int sum = 0;
for (int i = 1; i <= 10; i++) {
     sum += i;
}
System.out.println(sum); // 55

```

或者，对从 1 到 10 的一系列数字求和的声明性方法涉及处理数据流，并在未来某个未知或更确切地说未指定的时间接收结果:

```
int sumByStream = IntStream.rangeClosed(0,10).sum();
System.out.println(sumByStream); // 55

```

Note

在 Java 8 中，引入流是为了提高语言的声明性编程能力。`IntStream rangeClosed(int startInclusive, int endInclusive)`从`startInclusive`(含)到`endInclusive`(含)以 1 为增量步长返回一个`IntStream`。

然而，就目前而言，理解一个`Stream`对象或底层的`IntStream`专门化并不重要。不，现在，把“流”的想法放在一边；我们会回来的。

这里真正的要点是这两种方法产生相同的结果，但是声明性方法仅仅是为操作的结果设置一个期望，而不是规定底层的实现步骤。从根本上来说，这就是*反应式编程*的工作方式。还是有点朦胧？让我们潜入更深的地方。

## 反应性思维

正如我前面提到的，反应式编程的核心是声明性的。它旨在通过消除因必须维护大量线程而导致的许多问题来规避阻塞状态。最终，这是通过管理客户机和服务器之间的期望来实现的。

事实上，追求一种更具*反应性的*方法，在收到来自客户机的请求时，服务器线程调用数据库进行处理，但不等待响应。这释放了服务器线程来继续处理传入的请求。然后，在不确定的时间量之后，服务器线程从数据库接收并响应事件形式的响应。

![../images/504354_1_En_1_Chapter/504354_1_En_1_Fig4_HTML.png](../images/504354_1_En_1_Chapter/504354_1_En_1_Fig4_HTML.png)

图 1-4

客户端不等待来自服务器的直接响应

图 [1-4](#Fig4) 中显示的非阻塞和事件驱动行为是反应式编程的基础。

## 反动宣言

我知道你在想什么。反应式编程背后的总体概念并不新鲜，那么为什么要大肆宣传呢？嗯，它开始于反应系统的形式化。

2013 年，Reactive Manifesto 作为一种解决当时应用程序开发中新需求的方式而创建，并为讨论复杂概念(如 reactive programming)提供了一个通用词汇。然后，在 2014 年，通过 2.0 版本对其进行了修订，以更准确地反映反应式设计的核心价值。

### 反应系统

创建反应宣言是为了明确定义反应系统的四个目标，逐字引用如下:

*   ***响应迅速:*** *系统尽可能及时响应。响应性是可用性和实用性的基石，但不仅如此，响应性意味着问题可以被快速检测到并得到有效处理。响应式系统专注于提供快速一致的响应时间，建立可靠的上限，以便提供一致的服务质量。这种一致的行为反过来简化了错误处理，建立了最终用户的信心，并鼓励进一步的互动。*

*   ***有弹性:*** *面对失败，系统保持反应灵敏。这不仅适用于高可用性的任务关键型系统，任何不具备弹性的系统在出现故障后都将无法响应。复原力是通过复制、遏制、隔离和授权实现的。故障包含在每个组件中，将组件彼此隔离，从而确保系统的各个部分可以在不影响整个系统的情况下发生故障并恢复。每个组件的恢复被委托给另一个(外部)组件，并且在必要时通过复制来确保高可用性。组件的客户机没有处理其故障的负担。*

*   ***弹性:*** *系统在变化的工作负载下保持响应。反应式系统可以通过增加或减少分配给这些输入的* *资源* *来对输入速率的变化做出反应。这意味着没有争用点或中心瓶颈的设计，从而能够分割或复制组件并在它们之间分配输入。反应式系统通过提供相关的实时性能测量来支持预测以及反应式扩展算法。它们在商用硬件和软件平台上以经济高效的方式实现了灵活性。*

*   ***Message Driven:*** *Reactive Systems rely on asynchronous message-passing to establish a boundary between components that ensures loose coupling, isolation and location transparency. This boundary also provides the means to delegate failures as messages. Employing explicit message-passing enables load management, elasticity, and flow control by shaping and monitoring the message queues in the system and applying back-pressure when necessary. Location transparent messaging as a means of communication makes it possible for the management of failure to work with the same constructs and semantics across a cluster or within a single host. Non-blocking communication allows recipients to only consume resources while active, leading to less system overhead.*

    ![../images/504354_1_En_1_Chapter/504354_1_En_1_Fig5_HTML.jpg](../images/504354_1_En_1_Chapter/504354_1_En_1_Fig5_HTML.jpg)

    图 1-5

    反应宣言的四个原则

更简单地说，反应式系统是一种架构方法，它寻求将多个独立的解决方案组合成一个单一的、有凝聚力的单元，作为一个整体，它对周围的世界保持响应，或者说*反应*，同时这些解决方案保持相互了解。尽可能简单地说，反应式系统是指当系统中的一个单元遵循一套准则时，它对同一系统中的其他每个单元保持反应，而这些单元使用相同的准则，对外部系统集体反应。

### 反应系统！反应式编程

在这一点上，很容易混淆术语“反应式系统”和“反应式编程”,因为它们是可以互换的，但是需要注意的是，在解决方案中使用反应式编程并不意味着解决方案是反应式系统。

如前所述，Reactive Manifesto 在创建一年后进行了修订，其中一项更新是建立 Reactive 系统的核心租户之一，以使用异步*消息传递*。另一方面，反应式编程是*事件驱动的*。

那么有什么区别呢？反应式系统依赖于消息的使用来为分布式系统创建弹性的解决方案(图 [1-6](#Fig6) )。通常，消息都有一个目标。相比之下，事件在更小、更简洁的范围内使用，并且没有预期的目的地。

![../images/504354_1_En_1_Chapter/504354_1_En_1_Fig6_HTML.png](../images/504354_1_En_1_Chapter/504354_1_En_1_Fig6_HTML.png)

图 1-6

反应式系统与反应式编程

事件是一个组件在达到某个状态时发出的信号，任何连接的侦听器都可以观察到该信号。别担心。在接下来的章节中，我将深入探讨听众是如何观察事件的。

## 异步数据流

但是处理事件并不是一个新概念。事实上，用户界面事件，像按钮点击和各种其他控件交互，只不过是可以订阅、观察和响应的异步事件流。

### 数据流

类似地，反应式编程使用的数据流是按时间顺序排列的正在进行的事件序列(图 [1-7](#Fig7) )。从数据流中可以观察到三种类型的事件:值、错误和完成信号。

![../images/504354_1_En_1_Chapter/504354_1_En_1_Fig7_HTML.png](../images/504354_1_En_1_Chapter/504354_1_En_1_Fig7_HTML.png)

图 1-7

数据流的剖析

流中发出的事件被异步观察，或者以间歇的时间间隔观察，这允许数据流订阅者依次响应，或者*被动响应*(图 [1-8](#Fig8) )。

![../images/504354_1_En_1_Chapter/504354_1_En_1_Fig8_HTML.png](../images/504354_1_En_1_Chapter/504354_1_En_1_Fig8_HTML.png)

图 1-8

订阅观察器响应数据流中发出的事件

在这一点上，重要的是要注意数据流不仅限于发送用户界面事件。事实上，如果是这样的话，反应式编程作为一个整体就不会很有趣或者很有用。因此，顾名思义，如果它是数据，大多数东西都是数据，它可以在数据流中流动。这包括但不限于变量、用户输入值、属性、对象和数据结构。

如果这一切看起来有些熟悉，很可能是因为您在生活中的某个时刻已经了解了观察者设计模式。

Note

观察者设计模式被定义为对象之间的一对多关系，例如，如果一个对象被修改，它的依赖对象将被自动通知。

### 背压

数据流在发布者、发送数据者和订阅者之间的使用很容易理解。在一个完美的世界中，数据的流动将以同样的速度发生，其中元素、项目或基本上一些未知数量的数据以同样的速度发布和消费(图 [1-9](#Fig9) )。

![../images/504354_1_En_1_Chapter/504354_1_En_1_Fig9_HTML.png](../images/504354_1_En_1_Chapter/504354_1_En_1_Fig9_HTML.png)

图 1-9

发布者和订阅者的理想状态

但是，因为我们并不是生活在一个完美的世界中，所以使用这种方法，数据的发送速率可能会高于订阅者能够处理的速率。如果发生这种情况，订户将需要创建一个待处理的工作积压(图 [1-10](#Fig10) )。

![../images/504354_1_En_1_Chapter/504354_1_En_1_Fig10_HTML.png](../images/504354_1_En_1_Chapter/504354_1_En_1_Fig10_HTML.png)

图 1-10

如果发布者发出元素的速度比订阅者处理元素的速度快，就会产生未处理元素的积压

幸运的是，这个问题可以通过简单地允许订阅者与发布者进行沟通来解决，发布者已经准备好接收更多的元素。这种反馈过程被称为背压，它在促进有效的反应解决方案方面起着至关重要的作用。然而，这并不像只允许订阅者直接与发布者沟通那么简单，因为发布者可能无法以订阅者请求的速度发布数据，这可能会简单地将工作积压的问题转移给发布者(图 [1-11](#Fig11) )。

![../images/504354_1_En_1_Chapter/504354_1_En_1_Fig11_HTML.png](../images/504354_1_En_1_Chapter/504354_1_En_1_Fig11_HTML.png)

图 1-11

背压的最简单实现

使用反压来有效地利用异步数据流在促进有效的反应式编程解决方案中起着关键作用。然而，这也不是一个要解决的小问题，但是，幸运的是，有多种方法可以实现背压。在下一章中，我将探索一个名为 Reactive Streams 的规范，R2DBC 用它来创建真正的反应式数据库通信。

## 摘要

在这一章中，你已经了解了什么是反应式编程，它什么时候有用，以及它是如何工作的。您已经对声明式编程如何帮助异步数据流创建非阻塞、反应式解决方案有了较高的理解。

在下一章中，我们将研究如何利用这些原则，通过使用反应式关系数据库连接(R2DBC)来促进与关系数据库的反应式交互。